diff -Naur '--exclude=.git' --no-dereference A/meta-iwave/conf/layer.conf B/meta-iwave/conf/layer.conf
--- A/meta-iwave/conf/layer.conf	1970-01-01 05:30:00.000000000 +0530
+++ B/meta-iwave/conf/layer.conf	2025-12-09 19:57:47.554921545 +0530
@@ -0,0 +1,13 @@
+# We have a conf and classes directory, add to BBPATH
+BBPATH .= ":${LAYERDIR}"
+
+# We have recipes-* directories, add to BBFILES
+BBFILES += "${LAYERDIR}/recipes-*/*/*.bb \
+            ${LAYERDIR}/recipes-*/*/*.bbappend"
+
+BBFILE_COLLECTIONS += "meta-iwave"
+BBFILE_PATTERN_meta-iwave = "^${LAYERDIR}/"
+BBFILE_PRIORITY_meta-iwave = "7"
+
+LAYERDEPENDS_meta-iwave = "core"
+LAYERSERIES_COMPAT_meta-iwave = "styhead"
diff -Naur '--exclude=.git' --no-dereference A/meta-iwave/conf/machine/agilex5_ig58m.conf B/meta-iwave/conf/machine/agilex5_ig58m.conf
--- A/meta-iwave/conf/machine/agilex5_ig58m.conf	1970-01-01 05:30:00.000000000 +0530
+++ B/meta-iwave/conf/machine/agilex5_ig58m.conf	2025-12-09 19:57:47.549920939 +0530
@@ -0,0 +1,65 @@
+#@TYPE: Machine
+#@NAME: iWave Global Agilex 5 SoCFPGA SOM iG-RainboW-G58M
+#@DESCRIPTION: Machine configuration for Agilex 5 SoCFPGA SOM iG-RainboW-G58M
+
+require conf/machine/include/socfpga_armv8a.inc
+require conf/machine/include/ubifs.inc
+ERROR_QA:remove = "patch-status"
+# Kernel configuration
+KBUILD_DEFCONFIG ?= "socfpga_agilex5_iG58m_defconfig"
+PREFERRED_PROVIDER_virtual/kernel = "linux-socfpga-lts-ig58m"
+
+# U-Boot configuration
+UBOOT_CONFIG ??= "agilex5_ig58m-socdk-atf"
+UBOOT_CONFIG[agilex5_ig58m-socdk] = "socfpga_agilex5_iG58m_defconfig"
+UBOOT_CONFIG[agilex5_ig58m-socdk-atf] = "socfpga_agilex5_iG58m_defconfig"
+UBOOT_CONFIG[agilex5_ig58m-socdk-qspi] = "socfpga_agilex5_iG58m_defconfig"
+UBOOT_CONFIG[agilex5_ig58m-socdk-qspi-atf] = "socfpga_agilex5_iG58m_defconfig"
+
+UBOOT_BINARY = "u-boot.itb"
+UBOOT_SUFFIX = "itb"
+PREFERRED_PROVIDER_virtual/bootloader:${MACHINE} = "u-boot-socfpga-ig58m"
+
+# Kernel image and device tree
+KERNEL_CLASSES:append = " kernel-fitimage"
+KERNEL_IMAGETYPE = "Image"
+KERNEL_DEVICETREE ?= "intel/socfpga_agilex5_iG58m.dtb"
+FIT_KERNEL_COMP_ALG = "none"
+
+# U-Boot entry and load addresses
+UBOOT_ENTRYPOINT = "0x4000000"
+UBOOT_LOADADDRESS = "0x4000000"
+
+# Serial console configuration
+SERIAL_CONSOLES ?= "115200;ttyS0"
+
+# JFFS2 image configuration
+EXTRA_IMAGECMD:jffs2 ?= "-n -q -e 0x10000"
+
+# Extlinux configuration for U-Boot
+UBOOT_EXTLINUX ?= "1"
+UBOOT_EXTLINUX_LABELS ?= "default"
+UBOOT_EXTLINUX_DEFAULT_LABEL ?= "Agilex SOCDK SDMMC"
+UBOOT_EXTLINUX_MENU_DESCRIPTION:default ?= "Agilex SOCDK SDMMC"
+UBOOT_EXTLINUX_KERNEL_IMAGE:default ?= "../${KERNEL_IMAGETYPE}"
+UBOOT_EXTLINUX_FDTDIR:default ?= ".."
+UBOOT_EXTLINUX_CONSOLE ?= "console=ttyS0,115200n8"
+UBOOT_EXTLINUX_KERNEL_ARGS:default ?= "rootwait rw earlyprintk"
+UBOOT_EXTLINUX_ROOT:default ?= "root=/dev/mmcblk0p2"
+
+# WIC image creation for SD card
+IMAGE_BOOT_FILES ?= " \
+    ${UBOOT_BINARY} \
+    Image \
+    socfpga_agilex5_iG58m.dtb \
+"
+
+
+
+WKS_FILE ?= "sdimage-stratix10-agilex.wks"
+IMAGE_FSTYPES:append = " wic"
+
+# Image packages
+IMAGE_INSTALL:append = "socfpga-intel-rsu-lib socfpga-intel-rsu-client watchdog-init gdbserver bootscript ethtool  dosfstools e2fsprogs i2c-tools vim  kernel-modules udev udev-extraconf mmc-utils tzdata openssl devmem2 nfs-utils iperf3 dhrystone phytool coreutils mtd-utils"
+IMAGE_INSTALL:remove = "packagegroup-common-essential"
+
diff -Naur '--exclude=.git' --no-dereference A/meta-iwave/conf/machine/agilex5_ig58m-gsrd.conf B/meta-iwave/conf/machine/agilex5_ig58m-gsrd.conf
--- A/meta-iwave/conf/machine/agilex5_ig58m-gsrd.conf	1970-01-01 05:30:00.000000000 +0530
+++ B/meta-iwave/conf/machine/agilex5_ig58m-gsrd.conf	2025-12-09 19:57:47.550921061 +0530
@@ -0,0 +1,25 @@
+#@TYPE: Machine
+#@NAME: iWave Global Agilex 5 SoCFPGA SOM iG-RainboW-G58M
+#@DESCRIPTION: Machine configuration for Agilex 5 SoCFPGA SOM iG-RainboW-G58M
+
+IMAGE_TYPE ?= "gsrd"
+
+UBOOT_CONFIG:agilex5_ig58m ?= "agilex5_ig58m-socdk-atf agilex5_ig58m-socdk-qspi-atf"
+
+KERNEL_DEVICETREE = "intel/socfpga_agilex5_iG58m.dtb"
+
+MACHINE_ESSENTIAL_EXTRA_RRECOMMENDS:append ?= " \
+                kernel-modules \
+                device-tree \
+                "
+
+EXTRA_IMAGEDEPENDS:append ?= " \
+                u-boot-socfpga-ig58-scr \
+                "
+
+IMAGE_BOOT_FILES = " \
+                boot.scr.uimg \
+                u-boot.itb \
+                kernel.itb \
+                "
+
diff -Naur '--exclude=.git' --no-dereference A/meta-iwave/conf/machine/include/ig58m.inc B/meta-iwave/conf/machine/include/ig58m.inc
--- A/meta-iwave/conf/machine/include/ig58m.inc	1970-01-01 05:30:00.000000000 +0530
+++ B/meta-iwave/conf/machine/include/ig58m.inc	2025-12-09 19:57:47.551921182 +0530
@@ -0,0 +1,38 @@
+require conf/machine/include/arm/arch-armv8-2a.inc
+require ${WORKSPACE}/meta-intel-fpga/conf/machine/include/ubifs_agilex5.inc
+
+KERNEL_PROVIDER ?= "linux-socfpga-lts-ig58"
+PREFERRED_PROVIDER_virtual/kernel ?= "${KERNEL_PROVIDER}"
+KERNEL_IMAGETYPE ?= "Image"
+MACHINE_EXTRA_RRECOMMENDS:append = " kernel-modules"
+
+KBUILD_DEFCONFIG ?= "defconfig"
+
+PREFERRED_PROVIDER_virtual/bootloader ?= "u-boot-socfpga-ig58"
+PREFERRED_PROVIDER_u-boot ?= "u-boot-socfpga-ig58"
+
+SPL_BINARY ?= "spl/u-boot-spl-dtb.hex"
+UBOOT_SUFFIX ?= "img"
+UBOOT_BINARY ?= "u-boot.img"
+UBOOT_ELF ?= "u-boot"
+
+# UBOOT_IMAGE = "u-boot-${MACHINE}-${PV}-${PR}.${UBOOT_SUFFIX}"
+
+
+IMAGE_FSTYPES ?= "cpio ext3 tar.gz"
+do_image_wic[depends] += "mtools-native:do_populate_sysroot dosfstools-native:do_populate_sysroot virtual/bootloader:do_deploy virtual/kernel:do_deploy"
+
+#To be updated
+ATF_URL= "https://github.com/altera-opensource/arm-trusted-firmware"
+ATF_SRCBRANCH = "socfpga_v2.12.0"
+ATF_SRCREV = "58e71a6f67a332c9e3cecf7fdaab80fbc3d40238"
+
+UBOOT_URL= "https://github.com/altera-opensource/u-boot-socfpga"
+UBOOT_SRCBRANCH = "socfpga_v2025.01"
+UBOOT_SRCREV = "cd3a9044d66128bc67c4ce60eb752ac528620f54"
+
+LINUX_URL= "https://github.com/altera-opensource/linux-socfpga"
+LINUX_SRCBRANCH = "socfpga-6.12.11-lts"
+LINUX_SRCREV = "2f0b0270dbabe9acc602bd269b4f85253e8a6e6d"
+                                                                                            
+
diff -Naur '--exclude=.git' --no-dereference A/meta-iwave/conf/machine/include/socfpga_armv8a.inc B/meta-iwave/conf/machine/include/socfpga_armv8a.inc
--- A/meta-iwave/conf/machine/include/socfpga_armv8a.inc	1970-01-01 05:30:00.000000000 +0530
+++ B/meta-iwave/conf/machine/include/socfpga_armv8a.inc	2025-12-09 19:57:47.552921303 +0530
@@ -0,0 +1,21 @@
+require conf/machine/include/arm/arch-armv8a.inc
+
+KERNEL_PROVIDER ?= "linux-socfpga"
+PREFERRED_PROVIDER_virtual/kernel ?= "${KERNEL_PROVIDER}"
+KERNEL_IMAGETYPE ?= "Image"
+MACHINE_EXTRA_RRECOMMENDS:append = " kernel-modules"
+
+KBUILD_DEFCONFIG ?= "defconfig"
+
+PREFERRED_PROVIDER_virtual/bootloader ?= "u-boot-socfpga"
+PREFERRED_PROVIDER_u-boot ?= "u-boot-socfpga"
+
+SPL_BINARY ?= "spl/u-boot-spl-dtb.hex"
+UBOOT_SUFFIX ?= "img"
+UBOOT_BINARY ?= "u-boot.img"
+UBOOT_ELF ?= "u-boot"
+
+# UBOOT_IMAGE = "u-boot-${MACHINE}-${PV}-${PR}.${UBOOT_SUFFIX}"
+
+IMAGE_FSTYPES ?= "cpio ext3 tar.gz"
+do_image_wic[depends] += "mtools-native:do_populate_sysroot dosfstools-native:do_populate_sysroot virtual/bootloader:do_deploy virtual/kernel:do_deploy"
diff -Naur '--exclude=.git' --no-dereference A/meta-iwave/recipes-bsp/arm-trusted-firmware/arm-trusted-firmware-ig58m_v2.12.bb B/meta-iwave/recipes-bsp/arm-trusted-firmware/arm-trusted-firmware-ig58m_v2.12.bb
--- A/meta-iwave/recipes-bsp/arm-trusted-firmware/arm-trusted-firmware-ig58m_v2.12.bb	1970-01-01 05:30:00.000000000 +0530
+++ B/meta-iwave/recipes-bsp/arm-trusted-firmware/arm-trusted-firmware-ig58m_v2.12.bb	2025-12-09 19:57:47.491913915 +0530
@@ -0,0 +1,12 @@
+# Copyright (C) 2025 iWave Global
+
+DESCRIPTION = "Generate ARM Trusted Firmware for Agilex5 based iG-RainboW-G58M SoM"
+
+# Include base ARM Trusted Firmware recipe and machine-specific settings
+require ${WORKSPACE}/meta-intel-fpga/recipes-bsp/arm-trusted-firmware/arm-trusted-firmware_v2.12.bb
+require conf/machine/include/ig58m.inc
+
+# Set machine compatibility
+COMPATIBLE_MACHINE = "agilex5_ig58m"
+ATFPLAT:agilex5_ig58m = "agilex5"
+
diff -Naur '--exclude=.git' --no-dereference A/meta-iwave/recipes-bsp/device-tree/device-tree.bb B/meta-iwave/recipes-bsp/device-tree/device-tree.bb
--- A/meta-iwave/recipes-bsp/device-tree/device-tree.bb	1970-01-01 05:30:00.000000000 +0530
+++ B/meta-iwave/recipes-bsp/device-tree/device-tree.bb	2025-12-09 19:57:47.541919971 +0530
@@ -0,0 +1,30 @@
+SUMMARY = "Intel SoCFPGA Development Kit devicetrees"
+DESCRIPTION = "Devicetree addons for Agilex5 based iG-RainboW-G58M SoM"
+SECTION = "bsp"
+
+LICENSE = "MIT & GPL-2.0-only"
+
+FILESEXTRAPATHS:prepend := "${THISDIR}/files:"
+
+KERNEL_INCLUDE = " \
+        ${STAGING_KERNEL_DIR}/arch/${ARCH}/boot/dts \
+        ${STAGING_KERNEL_DIR}/arch/${ARCH}/boot/dts/* \
+        ${STAGING_KERNEL_DIR}/scripts/dtc/include-prefixes \
+        "
+inherit devicetree
+
+PROVIDES = "virtual/dtb"
+
+SRC_URI:append:${MACHINE} = " \
+                                        "
+
+do_configure[depends] += "virtual/kernel:do_configure"
+
+COMPATIBLE_MACHINE = "(agilex5_ig58m)"
+
+do_configure:append() {
+        # IG58M
+        if [[ "${MACHINE}" == "agilex5_ig58m" ]]; then
+                cp ${STAGING_KERNEL_DIR}/arch/${ARCH}/boot/dts/intel/socfpga_agilex5_iG58m.dts ${WORKDIR}/socfpga_agilex5_iG58m.dts
+        fi
+}
diff -Naur '--exclude=.git' --no-dereference A/meta-iwave/recipes-bsp/u-boot/files/P01-iG-PRHSZ-SC-01-R2.0-REL0.1-SD2.0-Q25.1-UBoot25.01.patch B/meta-iwave/recipes-bsp/u-boot/files/P01-iG-PRHSZ-SC-01-R2.0-REL0.1-SD2.0-Q25.1-UBoot25.01.patch
--- A/meta-iwave/recipes-bsp/u-boot/files/P01-iG-PRHSZ-SC-01-R2.0-REL0.1-SD2.0-Q25.1-UBoot25.01.patch	1970-01-01 05:30:00.000000000 +0530
+++ B/meta-iwave/recipes-bsp/u-boot/files/P01-iG-PRHSZ-SC-01-R2.0-REL0.1-SD2.0-Q25.1-UBoot25.01.patch	2025-12-09 19:57:47.512916458 +0530
@@ -0,0 +1,5244 @@
+diff -Naur --no-dereference '--exclude=.git' A/arch/arm/dts/Makefile B/arch/arm/dts/Makefile
+--- A/arch/arm/dts/Makefile	2025-12-09 11:50:06.154593868 +0530
++++ B/arch/arm/dts/Makefile	2025-12-09 16:47:51.977683406 +0530
+@@ -472,6 +472,8 @@
+ 	socfpga_stratix10_socdk_nand.dtb                \
+ 	socfpga_stratix10_socdk_qspi.dtb
+ 
++dtb-$(CONFIG_TARGET_SOCFPGA_AGILEX5_IG58M) += socfpga_agilex5_iG58m.dtb
++
+ dtb-$(CONFIG_TARGET_DRA7XX_EVM) += dra72-evm.dtb dra7-evm.dtb	\
+ 	dra72-evm-revc.dtb dra71-evm.dtb dra76-evm.dtb
+ dtb-$(CONFIG_TARGET_AM57XX_EVM) += am57xx-beagle-x15.dtb \
+diff -Naur --no-dereference '--exclude=.git' A/arch/arm/dts/socfpga_agilex5_iG58m.dts B/arch/arm/dts/socfpga_agilex5_iG58m.dts
+--- A/arch/arm/dts/socfpga_agilex5_iG58m.dts	1970-01-01 05:30:00.000000000 +0530
++++ B/arch/arm/dts/socfpga_agilex5_iG58m.dts	2025-12-09 16:47:51.979683433 +0530
+@@ -0,0 +1,298 @@
++// SPDX-License-Identifier: GPL-2.0
++/*
++ * Copyright (C) 2025 iWave Global
++ * IP Support <support.ip@iwave-global.com>
++ */
++#include "socfpga_agilex5.dtsi"
++#include <dt-bindings/interrupt-controller/irq.h>
++
++/ {
++	model = "SoCFPGA Agilex5 based iG58M development platform";
++
++	aliases {
++		serial0 = &uart0;
++		ethernet0 = &gmac2;
++		i2c0 = &i2c0;
++	};
++
++	memory {
++		device_type = "memory";
++		/* We expect the bootloader to fill in the reg */
++		reg = <0 0 0 0>;
++	};
++
++	soc {
++		clocks {
++			osc1 {
++				clock-frequency = <25000000>;
++			};
++		};
++	};
++
++	usb_en {
++		usb-en = <&gpio3 14 GPIO_ACTIVE_HIGH>;
++	};
++
++	pmic {
++		/* By default, 1.8V is set on PMIC-1 LDO2, LDO3 & LDO4.
++		* The supported voltage range is from 1.8V to 3.3V in the steps of 0.05V (50mV).
++		*
++		* Modify the pmic-ldo*_millivolt to the desired voltage level.
++		* Mention the voltage in millivolts.
++		* For example:
++		*  - 2.0V  => 2000
++		*  - 2.5V  => 2500
++		*
++		* Do not modify this if you are unsure.
++		*/
++
++		pmic-ldo2-millivolt = <1800>;
++		pmic-ldo3-millivolt = <1800>;
++		pmic-ldo4-millivolt = <1800>;
++
++		/*
++		* By default, 1.2V is set on PMIC-1 BUCK3.
++		* The supported voltage range is from 1.2V to 1.3V in the steps of 0.02V (20mV).
++		*
++		* Modify the pmic-vbuck3-millivolt to the desired voltage level (millivolts).
++		* For example:
++		*  - 1.3V => 1300
++		*
++		* Do not modify this if you are unsure.
++		*/
++
++		pmic-vbuck3-millivolt = <1200>;
++	};
++
++	fmc_plus {
++		/*
++		* By default, FMC+ Connector power is disabled.
++		* 1.2V compatibility is checked while booting by reading
++		* FMC+ module's EEPROM to enable corresponding FMC+ connector power.
++		*/
++		vadj-millivolt = <1200>;
++		prsnt-m2c = <&gpio3 2 GPIO_ACTIVE_HIGH>;
++		vcc-adj   = <&gpio3 7 GPIO_ACTIVE_HIGH>;
++		vcc-12v   = <&gpio3 5 GPIO_ACTIVE_HIGH>;
++		vcc-3v3   = <&gpio3 6 GPIO_ACTIVE_HIGH>;
++		pg-c2m    = <&gpio3 4 GPIO_ACTIVE_HIGH>;
++	};
++};
++
++&gpio0 {
++	status = "okay";
++};
++
++&gpio1 {
++	status = "okay";
++};
++
++&i2c0 {
++	status = "okay";
++	clock-frequency = <400000>;
++
++	cc_eeprom: eeprom@52 {
++		compatible = "atmel,24c04";
++		reg = <0x52>;
++		pagesize = <16>;
++		address-width = <8>;
++		size = <512>;
++	};
++
++	som_eeprom: eeprom@56 {
++		compatible = "atmel,24mac402";
++	        reg = <0x56>;
++        	pagesize = <16>;
++	        address-width = <8>;
++	        size = <256>;
++};
++
++	i2c_mux: msd9548@71 {
++		compatible = "nxp,pca9548";
++		reg = <0x71>;
++		status = "okay";
++		#address-cells = <1>;
++		#size-cells = <0>;
++
++		i2c@0 {
++			#address-cells = <1>;
++			#size-cells = <0>;
++			reg = <0>;
++
++			gpio2: gpio-controller@20 {
++				compatible = "ti,tca6416";
++				reg = <0x20>;
++				#gpio-cells = <2>;
++				gpio-controller;
++				interrupt-controller;
++				#interrupt-cells = <2>;
++				interrupt-parent = <&porta>;
++				interrupts = <10 IRQ_TYPE_EDGE_FALLING>;
++			};
++		};
++
++		i2c@1 {
++			#address-cells = <1>;
++			#size-cells = <0>;
++			reg = <1>;
++
++			gpio3: gpio-controller@21 {
++				compatible = "ti,tca6416";
++				reg = <0x21>;
++				#gpio-cells = <2>;
++				gpio-controller;
++				interrupt-controller;
++				#interrupt-cells = <2>;
++				interrupt-parent = <&gpio2>;
++				interrupts = <6 IRQ_TYPE_EDGE_FALLING>;
++			};
++		};
++
++		i2c@2 {
++			#address-cells = <1>;
++			#size-cells = <0>;
++			reg = <2>;
++
++			eeprom@50 {
++			compatible = "atmel,24c32";
++				reg = <0x50>;
++				pagesize = <32>;
++				address-width = <16>;
++				size = <4096>;
++			};
++		};
++
++		i2c@3 {
++			#address-cells = <1>;
++			#size-cells = <0>;
++			reg = <3>;
++		};
++	};
++};
++
++&mmc {
++	status = "okay";
++	bus-width = <8>;
++	sdhci-caps = <0x00000000 0x00040000>;
++	sdhci-caps-mask = <0x00000000 0x00040000>;
++	cap-mmc-highspeed;
++};
++
++&combophy0 {
++	status = "okay";
++};
++
++&uart0 {
++	status = "okay";
++};
++
++&usbphy0 {
++	status = "okay";
++};
++
++&usb31 {
++	status = "okay";
++};
++
++&timer0 {
++	status = "okay";
++};
++
++&timer1 {
++	status = "okay";
++};
++
++&timer2 {
++	status = "okay";
++};
++
++&timer3 {
++	status = "okay";
++};
++
++&qspi {
++	status = "okay";
++
++	flash0: flash@0 {
++		#address-cells = <1>;
++		#size-cells = <1>;
++		compatible = "jedec,spi-nor", "micron,mt25qu01g";
++		reg = <0>;
++		spi-max-frequency = <25000000>;
++		spi-tx-bus-width = <4>;
++		spi-rx-bus-width = <4>;
++		m25p,fast-read;
++		cdns,page-size = <256>;
++		cdns,block-size = <64>;
++		cdns,tshsl-ns = <50>;
++		cdns,tsd2d-ns = <50>;
++		cdns,tchsh-ns = <4>;
++		cdns,tslch-ns = <4>;
++
++		partitions {
++			compatible = "fixed-partitions";
++			#address-cells = <1>;
++			#size-cells = <1>;
++
++			qspi_boot: partition@0 {
++				label = "u-boot";
++				reg = <0x0 0x00600000>;
++			};
++
++			root: partition@4200000 {
++			label = "root";
++			reg = <0x00600000 0x07a00000>;
++			};
++		};
++	};
++};
++
++&gmac2 {
++	status = "okay";
++	phy-mode = "rgmii";
++	phy-handle = <&emac2_phy0>;
++	max-frame-size = <9000>;
++
++	mdio0 {
++		#address-cells = <1>;
++		#size-cells = <0>;
++		compatible = "snps,dwxgmac-mdio";
++
++		emac2_phy0: ethernet-phy@4 {
++			reg = <4>;
++			phy-mode = "rgmii";
++			compatible = "ethernet-phy-ieee802.3-c22";
++			phy-reset-gpio = <&portb 3 GPIO_ACTIVE_LOW>;
++			phy-reset-active-low;
++			phy-reset-duration = <15>;
++			phy-reset-post-delay = <100>;
++			reset-assert-us = <10000>;
++			qca,clk-out-frequency = <125000000>;
++			qca,keep-pll-enabled;
++			rxc-skew-ps = <3000>;
++			rxdv-skew-ps = <0>;
++			txc-skew-ps = <3000>;
++			txen-skew-ps = <0>;
++			rxd0-skew-ps = <0>;
++			rxd1-skew-ps = <0>;
++			rxd2-skew-ps = <0>;
++			rxd3-skew-ps = <0>;
++			txd0-skew-ps = <3000>;
++			txd1-skew-ps = <3000>;
++			txd2-skew-ps = <3000>;
++			txd3-skew-ps = <3000>;
++
++			vddio-supply = <&vddio>;
++
++			vddio: vddio-regulator {
++				regulator-min-microvolt = <1800000>;
++				regulator-max-microvolt = <1800000>;
++			};
++
++			vddh: vddh-regulator {
++				regulator-name = "VDDH";
++			};
++		};
++	};
++};
++
+diff -Naur --no-dereference '--exclude=.git' A/arch/arm/dts/socfpga_agilex5_iG58m-u-boot.dtsi B/arch/arm/dts/socfpga_agilex5_iG58m-u-boot.dtsi
+--- A/arch/arm/dts/socfpga_agilex5_iG58m-u-boot.dtsi	1970-01-01 05:30:00.000000000 +0530
++++ B/arch/arm/dts/socfpga_agilex5_iG58m-u-boot.dtsi	2025-12-09 16:47:51.979683433 +0530
+@@ -0,0 +1,114 @@
++// SPDX-License-Identifier:     GPL-2.0
++/*
++ * U-Boot additions
++ *
++ * Copyright (C) 2025 iWave Global 
++ * IP Support <support.ip@iwave-global.com>
++ */
++
++#include "socfpga_agilex5-u-boot.dtsi"
++
++/{
++	memory {
++		/* 2GB */
++		reg = <0 0x80000000 0 0x80000000>;
++	};
++	
++
++	aliases {
++		spi0 = &qspi;
++	};
++
++	chosen {
++		stdout-path = "serial0:115200n8";
++		u-boot,spl-boot-order = &flash0,&mmc,"/memory";
++	};
++};
++
++&flash0 {
++	compatible = "jedec,spi-nor";
++	spi-tx-bus-width = <4>;
++	spi-rx-bus-width = <4>;
++	bootph-all;
++	/delete-property/ cdns,read-delay;
++};
++
++
++&mmc {
++	bootph-all;
++};
++
++&combophy0 {
++	status = "okay";
++	bootph-all;
++	cdns,phy-use-ext-lpbk-dqs = <1>;
++	cdns,phy-use-lpbk-dqs = <1>;
++	cdns,phy-use-phony-dqs = <1>;
++	cdns,phy-use-phony-dqs-cmd = <1>;
++	cdns,phy-io-mask-always-on = <0>;
++	cdns,phy-io-mask-end = <5>;
++	cdns,phy-io-mask-start = <0>;
++	cdns,phy-data-select-oe-end = <1>;
++	cdns,phy-sync-method = <1>;
++	cdns,phy-sw-half-cycle-shift = <0>;
++	cdns,phy-rd-del-sel = <52>;
++	cdns,phy-underrun-suppress = <1>;
++	cdns,phy-gate-cfg-always-on = <1>;
++	cdns,phy-param-dll-bypass-mode = <1>;
++	cdns,phy-param-phase-detect-sel = <2>;
++	cdns,phy-param-dll-start-point = <254>;
++	cdns,phy-read-dqs-cmd-delay = <0>;
++	cdns,phy-clk-wrdqs-delay = <0>;
++	cdns,phy-clk-wr-delay = <0>;
++	cdns,phy-read-dqs-delay = <0>;
++	cdns,phy-phony-dqs-timing = <0>;
++	cdns,hrs09-rddata-en = <1>;
++	cdns,hrs09-rdcmd-en = <1>;
++	cdns,hrs09-extended-wr-mode = <1>;
++	cdns,hrs09-extended-rd-mode = <1>;
++	cdns,hrs10-hcsdclkadj = <3>;
++	cdns,hrs16-wrdata1-sdclk-dly = <0>;
++	cdns,hrs16-wrdata0-sdclk-dly = <0>;
++	cdns,hrs16-wrcmd1-sdclk-dly = <0>;
++	cdns,hrs16-wrcmd0-sdclk-dly = <0>;
++	cdns,hrs16-wrdata1-dly = <0>;
++	cdns,hrs16-wrdata0-dly = <0>;
++	cdns,hrs16-wrcmd1-dly = <0>;
++	cdns,hrs16-wrcmd0-dly = <0>;
++	cdns,hrs07-rw-compensate = <10>;
++	cdns,hrs07-idelay-val = <0>;
++};
++
++&uart0 {
++	bootph-all;
++};
++
++&timer0 {
++	bootph-all;
++};
++
++&timer1 {
++	bootph-all;
++};
++
++&timer2 {
++	bootph-all;
++};
++
++&timer3 {
++	bootph-all;
++};
++
++#if !defined(CONFIG_SOCFPGA_SECURE_VAB_AUTH)
++&fdt_0_blob {
++	filename = "arch/arm/dts/socfpga_agilex5_iG58m.dtb";
++};
++
++
++&binman {
++	/delete-node/ kernel;
++};
++#endif
++
++// Delete the hog
++/delete-node/ &{/soc/gpio@10c03300/gpio-controller@0/sdio_sel};
+diff -Naur --no-dereference '--exclude=.git' A/arch/arm/mach-socfpga/Kconfig B/arch/arm/mach-socfpga/Kconfig
+--- A/arch/arm/mach-socfpga/Kconfig	2025-12-09 11:50:06.282595737 +0530
++++ B/arch/arm/mach-socfpga/Kconfig	2025-12-09 16:47:52.024684055 +0530
+@@ -242,6 +242,10 @@
+ 	bool "Intel SOCFPGA SoCDK (Agilex5)"
+ 	select TARGET_SOCFPGA_AGILEX5
+ 
++config TARGET_SOCFPGA_AGILEX5_IG58M
++	bool "iG-RainboW-G58M SoM (Agilex5)"
++	select TARGET_SOCFPGA_AGILEX5
++
+ config TARGET_SOCFPGA_AGILEX7M_SOCDK
+ 	bool "Intel SOCFPGA SoCDK (Agilex7)"
+ 	select TARGET_SOCFPGA_AGILEX7M
+@@ -321,6 +325,7 @@
+ config SYS_BOARD
+ 	default "agilex7m-socdk" if TARGET_SOCFPGA_AGILEX7M_SOCDK
+ 	default "agilex5-socdk" if TARGET_SOCFPGA_AGILEX5_SOCDK
++	default "agilex5-iG58m" if TARGET_SOCFPGA_AGILEX5_IG58M
+ 	default "agilex-n6010" if TARGET_SOCFPGA_AGILEX_N6010
+ 	default "agilex-socdk" if TARGET_SOCFPGA_AGILEX_SOCDK
+ 	default "arria5-socdk" if TARGET_SOCFPGA_ARRIA5_SOCDK
+@@ -345,6 +350,7 @@
+ config SYS_VENDOR
+ 	default "intel" if TARGET_SOCFPGA_AGILEX7M_SOCDK
+ 	default "intel" if TARGET_SOCFPGA_AGILEX5_SOCDK
++	default "intel" if TARGET_SOCFPGA_AGILEX5_IG58M
+ 	default "intel" if TARGET_SOCFPGA_AGILEX_N6010
+ 	default "intel" if TARGET_SOCFPGA_AGILEX_SOCDK
+ 	default "intel" if TARGET_SOCFPGA_N5X_SOCDK
+@@ -370,6 +376,7 @@
+ config SYS_CONFIG_NAME
+ 	default "socfpga_agilex7m_socdk" if TARGET_SOCFPGA_AGILEX7M_SOCDK
+ 	default "socfpga_agilex5_socdk" if TARGET_SOCFPGA_AGILEX5_SOCDK
++	default "socfpga_agilex5_iG58m" if TARGET_SOCFPGA_AGILEX5_IG58M
+ 	default "socfpga_agilex_n6010" if TARGET_SOCFPGA_AGILEX_N6010
+ 	default "socfpga_agilex_socdk" if TARGET_SOCFPGA_AGILEX_SOCDK
+ 	default "socfpga_arria5_secu1" if TARGET_SOCFPGA_ARRIA5_SECU1
+diff -Naur --no-dereference '--exclude=.git' A/arch/arm/mach-socfpga/rsu_s10.c B/arch/arm/mach-socfpga/rsu_s10.c
+--- A/arch/arm/mach-socfpga/rsu_s10.c	2025-12-09 11:50:06.284595766 +0530
++++ B/arch/arm/mach-socfpga/rsu_s10.c	2025-12-09 16:47:52.024684055 +0530
+@@ -28,10 +28,10 @@
+ 	}
+ 	puts("RSU: Remote System Update Status\n");
+ 	printf("Current Image\t: 0x%08llx\n", status_info.current_image);
+-	printf("Last Fail Image\t: 0x%08llx\n", status_info.fail_image);
++	printf("Last Fail Image: 0x%08llx\n", status_info.fail_image);
+ 	printf("State\t\t: 0x%08x\n", status_info.state);
+-	printf("Version\t\t: 0x%08x\n", status_info.version);
+-	printf("Error location\t: 0x%08x\n", status_info.error_location);
++	printf("Version\t: 0x%08x\n", status_info.version);
++	printf("Error location: 0x%08x\n", status_info.error_location);
+ 	printf("Error details\t: 0x%08x\n", status_info.error_details);
+ 	if (RSU_VERSION_ACMF_VERSION(status_info.version) &&
+ 	    RSU_VERSION_DCMF_VERSION(status_info.version))
+diff -Naur --no-dereference '--exclude=.git' A/board/intel/agilex5-iG58m/MAINTAINERS B/board/intel/agilex5-iG58m/MAINTAINERS
+--- A/board/intel/agilex5-iG58m/MAINTAINERS	1970-01-01 05:30:00.000000000 +0530
++++ B/board/intel/agilex5-iG58m/MAINTAINERS	2025-12-09 16:47:52.135685588 +0530
+@@ -0,0 +1,6 @@
++SoCFPGA Agilex5 based iG58M development platform
++M:	IP Support <support.ip@iwave-global.com>
++S:	Maintained
++F:	board/intel/agilex5-iG58m/
++F:	include/configs/socfpga_agilex5_iG58m.h
++F:	configs/socfpga_agilex5_iG58m_defconfig
+diff -Naur --no-dereference '--exclude=.git' A/board/intel/agilex5-iG58m/Makefile B/board/intel/agilex5-iG58m/Makefile
+--- A/board/intel/agilex5-iG58m/Makefile	1970-01-01 05:30:00.000000000 +0530
++++ B/board/intel/agilex5-iG58m/Makefile	2025-12-09 16:47:52.135685588 +0530
+@@ -0,0 +1,7 @@
++#
++# Copyright (C) 2022 Intel Corporation <www.intel.com>
++#
++# SPDX-License-Identifier:	GPL-2.0
++#
++
++obj-y	:= socfpga-iG58m.o
+diff -Naur --no-dereference '--exclude=.git' A/board/intel/agilex5-iG58m/Si5332-cs2-reg.h B/board/intel/agilex5-iG58m/Si5332-cs2-reg.h
+--- A/board/intel/agilex5-iG58m/Si5332-cs2-reg.h	1970-01-01 05:30:00.000000000 +0530
++++ B/board/intel/agilex5-iG58m/Si5332-cs2-reg.h	2025-12-09 16:47:52.135685588 +0530
+@@ -0,0 +1,386 @@
++/*
++ * Si5332-GM1 Rev D Configuration Register Export Header File
++ *
++ * This file represents a series of Skyworks Si5332-GM1 Rev D 
++ * register writes that can be performed to load a single configuration 
++ * on a device. It was created by a Skyworks ClockBuilder Pro
++ * export tool.
++ *
++ * Part:		                                       Si5332-GM1 Rev D
++ * Design ID:                                          Si5332
++ * Includes Pre/Post Download Control Register Writes: Yes
++ * Created By:                                         ClockBuilder Pro v4.8 [2023-02-14]
++ * Timestamp:                                          2025-12-04 17:50:26 GMT+05:30
++ *
++ * A complete design report corresponding to this export is included at the end 
++ * of this header file.
++ *
++ */
++
++#ifndef SI5332_GM1_REVD_REG_CONFIG_HEADER
++#define SI5332_GM1_REVD_REG_CONFIG_HEADER
++
++#define SI5332_GM1_REVD_REG_CONFIG_NUM_REGS				63
++
++typedef struct
++{
++	unsigned int address; /* 8-bit register address */
++	unsigned char value; /* 8-bit register data */
++
++} si5332_gm1_revd_register_t;
++
++si5332_gm1_revd_register_t const si5332_gm1_revd_registers[SI5332_GM1_REVD_REG_CONFIG_NUM_REGS] =
++{
++
++	/* Start configuration preamble */
++	/*    Set device in Ready mode */
++	{ 0x0006, 0x01 },
++	/* End configuration preamble */
++
++	/* Start configuration registers */
++	{ 0x0017, 0x53 },
++	{ 0x0018, 0x69 },
++	{ 0x0019, 0x35 },
++	{ 0x001A, 0x33 },
++	{ 0x001B, 0x33 },
++	{ 0x001C, 0x32 },
++	{ 0x0021, 0x6A },
++	{ 0x0024, 0x02 },
++	{ 0x0025, 0x00 },
++	{ 0x0026, 0x00 },
++	{ 0x0027, 0x00 },
++	{ 0x0028, 0x00 },
++	{ 0x0029, 0x00 },
++	{ 0x002B, 0x10 },
++	{ 0x003C, 0x00 },
++	{ 0x0048, 0x00 },
++	{ 0x0054, 0x00 },
++	{ 0x0060, 0x00 },
++	{ 0x0067, 0x32 },
++	{ 0x0068, 0x00 },
++	{ 0x0069, 0x00 },
++	{ 0x006A, 0x00 },
++	{ 0x006B, 0x00 },
++	{ 0x006C, 0x01 },
++	{ 0x0073, 0x01 },
++	{ 0x0074, 0x00 },
++	{ 0x0075, 0x01 },
++	{ 0x007A, 0x06 },
++	{ 0x007B, 0x01 },
++	{ 0x007C, 0x00 },
++	{ 0x007D, 0x00 },
++	{ 0x007F, 0x06 },
++	{ 0x0080, 0x01 },
++	{ 0x0081, 0x00 },
++	{ 0x0082, 0x00 },
++	{ 0x0089, 0x06 },
++	{ 0x008A, 0x01 },
++	{ 0x008B, 0x00 },
++	{ 0x008C, 0x00 },
++	{ 0x0098, 0x06 },
++	{ 0x0099, 0x01 },
++	{ 0x009A, 0x00 },
++	{ 0x009B, 0x00 },
++	{ 0x00A7, 0x06 },
++	{ 0x00A8, 0x01 },
++	{ 0x00A9, 0x00 },
++	{ 0x00AA, 0x00 },
++	{ 0x00AC, 0x06 },
++	{ 0x00AE, 0x00 },
++	{ 0x00AF, 0x00 },
++	{ 0x00B6, 0x4B },
++	{ 0x00B7, 0x02 },
++	{ 0x00B9, 0x00 },
++	{ 0x00BA, 0x7E },
++	{ 0x00BB, 0x20 },
++	{ 0x00BC, 0x00 },
++	{ 0x00BD, 0x04 },
++	{ 0x00BE, 0x10 },
++	{ 0x00BF, 0x01 },
++	{ 0x00C0, 0x30 },
++	{ 0x00C1, 0x30 },
++	/* End configuration registers */
++
++	/* Start configuration postamble */
++	/*    Set device in Active mode */
++	{ 0x0006, 0x02 },
++	/* End configuration postamble */
++
++};
++
++/*
++ * Design Report
++ *
++ * Overview
++ * ========
++ * 
++ * Part:               Si5332ABCD Rev D
++ * Project File:       C:\Users\vikas\Desktop\G58D-Si5332-CS2-REL1.0-Si5332.slabtimeproj
++ * Design ID:          Si5332
++ * Created By:         ClockBuilder Pro v4.8 [2023-02-14]
++ * Timestamp:          2025-12-04 17:50:26 GMT+05:30
++ * 
++ * Design Rule Check
++ * =================
++ * 
++ * Errors:
++ * - No errors
++ * 
++ * Warnings:
++ * - No warnings
++ * 
++ * Device Grade
++ * ============
++ * Maximum Output Frequency: 156.25 MHz
++ * Frequency Synthesis Mode: Integer
++ * Frequency Plan Grade:     D
++ * Minimum Base OPN:         Si5332D*
++ * 
++ * Base       Output Clock         Supported Frequency Synthesis Modes
++ * OPN Grade  Frequency Range      (Typical Jitter)
++ * ---------  ------------------  --------------------------------------------
++ * Si5332A    5 MHz to 334 MHz    Integer (~230 fs) and fractional (~500 fs)
++ * Si5332B    5 MHz to 200 MHz    "
++ * Si5332C    5 MHz to 334 MHz    Integer only (~230 fs)
++ * Si5332D*   5 MHz to 200 MHz    "
++ * 
++ * * Based on your calculated frequency plan, a Si5332D grade device is
++ * sufficient for your design. For more in-system configuration flexibility
++ * (higher frequencies and/or to enable fractional synthesis), consider
++ * selecting device grade Si5332A when specifying an ordering part number (OPN)
++ * for your application. See the datasheet Ordering Guide for more information.
++ * 
++ * Design
++ * ======
++ * Base I2C Address: 0x6A
++ * 
++ * Universal Hardware Input Pins:
++ *    INPUT1 (P8) : I2C Address                   (input: LOW = 0x6A / HIGH = 0x6B)
++ *    INPUT2 (P17): CLKIN_SEL[0]                  (See Table CLKIN_SEL GPIO)
++ *    INPUT3 (P24): CLKIN_SEL[1]                  (See Table CLKIN_SEL GPIO)
++ *    INPUT4 (P28): None                          
++ *    INPUT5 (P29): None                          
++ * 
++ * (Table CLKIN_SEL GPIO)
++ * CLKIN_SEL[1]  CLKIN_SEL[0]  PLL Input
++ * ------------  ------------  ---------
++ * LOW           LOW           Disabled 
++ * LOW           HIGH          XAXB     
++ * HIGH          LOW           CLKIN2   
++ * HIGH          HIGH          Unused   
++ * 
++ * Inputs:
++ *    XAXB: 25 MHz
++ *          Crystal Mode
++ *          Adjusted Capacitance: 18 pF
++ *  CLKIN2: 25 MHz Differential
++ * 
++ * Outputs:
++ *    OUT0: 156.25 MHz LVDS Fast 3.3 V, Disabled-State: Stop Low
++ *          Power-up state: Enabled
++ *    OUT1: 156.25 MHz LVDS Fast 3.3 V, Disabled-State: Stop Low
++ *          Power-up state: Enabled
++ *    OUT2: 156.25 MHz LVDS Fast 3.3 V, Disabled-State: Stop Low
++ *          Power-up state: Enabled
++ *    OUT3: 156.25 MHz LVDS Fast 3.3 V, Disabled-State: Stop Low
++ *          Power-up state: Enabled
++ *    OUT4: 156.25 MHz LVDS Fast 3.3 V, Disabled-State: Stop Low
++ *          Power-up state: Enabled
++ *    OUT5: Unused
++ * 
++ * Frequency Plan
++ * ==============
++ * 
++ * Fpfd = 25 MHz
++ * Fvco = 2.5 GHz
++ * 
++ * P divider = 1
++ * M = 100
++ * N dividers:
++ *    N0:
++ *       Unused
++ *    N1:
++ *       Unused
++ * 
++ * O dividers:
++ *    O0:
++ *       Value: 16
++ *       OUT0: 156.25 MHz, Error: 0 ppm
++ *       OUT1: 156.25 MHz, Error: 0 ppm
++ *       OUT2: 156.25 MHz, Error: 0 ppm
++ *       OUT3: 156.25 MHz, Error: 0 ppm
++ *       OUT4: 156.25 MHz, Error: 0 ppm
++ *    O1:
++ *       Unused
++ *    O2:
++ *       Unused
++ *    O3:
++ *       Unused
++ *    O4:
++ *       Unused
++ * 
++ * R dividers:
++ *    R0 = 1
++ *    R1 = 1
++ *    R2 = 1
++ *    R3 = 1
++ *    R4 = 1
++ *    R5 = Unused
++ * 
++ * Estimated Power
++ * ===============
++ * Assumptions:
++ * 
++ * VDD:      1.8 V
++ * Ta:       25 �C
++ * Theta-JA: 23.00 �C/W (JEDEC Board with 2 m/s airflow)
++ * 
++ *                               Overall  On Chip
++ * Condition                     Power    Power    Ta    Tj
++ * ----------------------------  -------  -------  ----  ----
++ * Typical Ta, Voltage, Current  242 mW   234 mW   25 C  30 C
++ * 
++ *                                         -----------------------
++ *                                                 Typical        
++ *                                         -----------------------
++ *                                         Voltage  Current  Power
++ *           Output  Frequency   Format      (V)     (mA)    (mW) 
++ *           ------  ----------  --------  -------  -------  -----
++ * VDDA                                       1.80       20     36
++ * VDD Dig                                    1.80        5      8
++ * VDD Xtal                                   1.80        8     14
++ * VDDO0     OUT0    156.25 MHz  LVDSFast     3.30       11     37
++ * VDDO1     OUT1    156.25 MHz  LVDSFast     3.30       11     37
++ * VDDO2     OUT2    156.25 MHz  LVDSFast     3.30       11     37
++ * VDDO3     OUT3    156.25 MHz  LVDSFast     3.30       11     37
++ * VDDO4     OUT4    156.25 MHz  LVDSFast     3.30       11     37
++ * VDDO5     OUT5        Unused          
++ *                                         -------  -------  -----
++ *                                            1.80       32     58
++ *                                            3.30       56    184
++ *                                         -------  -------  -----
++ *                                           Total             242
++ *                                         -------  -------  -----
++ * 
++ * Note:
++ * 
++ * - Tj is junction temperature. Tj must be less than 125 �C (on Si5332-GM1
++ *   Revision D) for device to comply with datasheet specifications. Tj = Ta +
++ *   Theta_JA*On_Chip_Power.
++ * - Overall power includes on-chip power dissipation and adds differential load
++ *   power dissipation to estimate total power requirements.
++ * - Above are estimates only: power and temperature should be measured on your
++ *   PCB.
++ * 
++ * Settings
++ * ========
++ * 
++ * Location    Setting Name     Decimal Value      Hex Value        
++ * ----------  ---------------  -----------------  -----------------
++ * 0x17[7:0]   DESIGN_ID0       83                 0x53             
++ * 0x18[7:0]   DESIGN_ID1       105                0x69             
++ * 0x19[7:0]   DESIGN_ID2       53                 0x35             
++ * 0x1A[7:0]   DESIGN_ID3       51                 0x33             
++ * 0x1B[7:0]   DESIGN_ID4       51                 0x33             
++ * 0x1C[7:0]   DESIGN_ID5       50                 0x32             
++ * 0x21[6:0]   I2C_ADDR         106                0x6A             
++ * 0x24[1:0]   IMUX_SEL         2                  0x2              
++ * 0x25[1:0]   OMUX0_SEL0       0                  0x0              
++ * 0x25[6:4]   OMUX0_SEL1       0                  0x0              
++ * 0x26[1:0]   OMUX1_SEL0       0                  0x0              
++ * 0x26[6:4]   OMUX1_SEL1       0                  0x0              
++ * 0x27[1:0]   OMUX2_SEL0       0                  0x0              
++ * 0x27[6:4]   OMUX2_SEL1       0                  0x0              
++ * 0x28[1:0]   OMUX3_SEL0       0                  0x0              
++ * 0x28[6:4]   OMUX3_SEL1       0                  0x0              
++ * 0x29[1:0]   OMUX4_SEL0       0                  0x0              
++ * 0x29[6:4]   OMUX4_SEL1       0                  0x0              
++ * 0x2B[7:0]   HSDIV0A_DIV      16                 0x10             
++ * 0x3C[0]     ID0A_SS_ENA      0                  0x0              
++ * 0x3C[2:1]   ID0A_SS_MODE     0                  0x0              
++ * 0x48[0]     ID0B_SS_ENA      0                  0x0              
++ * 0x48[2:1]   ID0B_SS_MODE     0                  0x0              
++ * 0x54[0]     ID1A_SS_ENA      0                  0x0              
++ * 0x54[2:1]   ID1A_SS_MODE     0                  0x0              
++ * 0x60[0]     ID1B_SS_ENA      0                  0x0              
++ * 0x60[2:1]   ID1B_SS_MODE     0                  0x0              
++ * 0x67[14:0]  IDPA_INTG        12800              0x3200           
++ * 0x69[14:0]  IDPA_RES         0                  0x0000           
++ * 0x6B[14:0]  IDPA_DEN         1                  0x0001           
++ * 0x73[1:0]   CLKIN_2_CLK_SEL  1                  0x1              
++ * 0x74[1:0]   CLKIN_3_CLK_SEL  0                  0x0              
++ * 0x75[4:0]   P_VAL            1                  0x01             
++ * 0x7A[3:0]   OUT0_MODE        6                  0x6              
++ * 0x7B[5:0]   OUT0_DIV         1                  0x01             
++ * 0x7C[2:0]   OUT0_SKEW        0                  0x0              
++ * 0x7D[0]     OUT0_STOP_HIGHZ  0                  0x0              
++ * 0x7D[5:4]   OUT0_CMOS_INV    0                  0x0              
++ * 0x7D[6]     OUT0_DIFF_INV    0                  0x0              
++ * 0x7F[3:0]   OUT1_MODE        6                  0x6              
++ * 0x80[5:0]   OUT1_DIV         1                  0x01             
++ * 0x81[2:0]   OUT1_SKEW        0                  0x0              
++ * 0x82[0]     OUT1_STOP_HIGHZ  0                  0x0              
++ * 0x82[5:4]   OUT1_CMOS_INV    0                  0x0              
++ * 0x82[6]     OUT1_DIFF_INV    0                  0x0              
++ * 0x89[3:0]   OUT2_MODE        6                  0x6              
++ * 0x8A[5:0]   OUT2_DIV         1                  0x01             
++ * 0x8B[2:0]   OUT2_SKEW        0                  0x0              
++ * 0x8C[0]     OUT2_STOP_HIGHZ  0                  0x0              
++ * 0x8C[5:4]   OUT2_CMOS_INV    0                  0x0              
++ * 0x8C[6]     OUT2_DIFF_INV    0                  0x0              
++ * 0x98[3:0]   OUT3_MODE        6                  0x6              
++ * 0x99[5:0]   OUT3_DIV         1                  0x01             
++ * 0x9A[2:0]   OUT3_SKEW        0                  0x0              
++ * 0x9B[0]     OUT3_STOP_HIGHZ  0                  0x0              
++ * 0x9B[5:4]   OUT3_CMOS_INV    0                  0x0              
++ * 0x9B[6]     OUT3_DIFF_INV    0                  0x0              
++ * 0xA7[3:0]   OUT4_MODE        6                  0x6              
++ * 0xA8[5:0]   OUT4_DIV         1                  0x01             
++ * 0xA9[2:0]   OUT4_SKEW        0                  0x0              
++ * 0xAA[0]     OUT4_STOP_HIGHZ  0                  0x0              
++ * 0xAA[5:4]   OUT4_CMOS_INV    0                  0x0              
++ * 0xAA[6]     OUT4_DIFF_INV    0                  0x0              
++ * 0xAC[3:0]   OUT5_MODE        6                  0x6              
++ * 0xAE[2:0]   OUT5_SKEW        0                  0x0              
++ * 0xAF[0]     OUT5_STOP_HIGHZ  0                  0x0              
++ * 0xAF[5:4]   OUT5_CMOS_INV    0                  0x0              
++ * 0xAF[6]     OUT5_DIFF_INV    0                  0x0              
++ * 0xB6[0]     OUT0_OE          1                  0x1              
++ * 0xB6[1]     OUT1_OE          1                  0x1              
++ * 0xB6[3]     OUT2_OE          1                  0x1              
++ * 0xB6[6]     OUT3_OE          1                  0x1              
++ * 0xB7[1]     OUT4_OE          1                  0x1              
++ * 0xB7[2]     OUT5_OE          0                  0x0              
++ * 0xB9[0]     XOSC_DIS         0                  0x0              
++ * 0xB9[1]     IBUF0_DIS        0                  0x0              
++ * 0xB9[3]     IMUX_DIS         0                  0x0              
++ * 0xB9[4]     PDIV_DIS         0                  0x0              
++ * 0xB9[5]     PLL_DIS          0                  0x0              
++ * 0xBA[5]     ID0_DIS          1                  0x1              
++ * 0xBA[6]     ID1_DIS          1                  0x1              
++ * 0xBA[0]     HSDIV0_DIS       0                  0x0              
++ * 0xBA[1]     HSDIV1_DIS       1                  0x1              
++ * 0xBA[2]     HSDIV2_DIS       1                  0x1              
++ * 0xBA[3]     HSDIV3_DIS       1                  0x1              
++ * 0xBA[4]     HSDIV4_DIS       1                  0x1              
++ * 0xBB[0]     OMUX0_DIS        0                  0x0              
++ * 0xBB[1]     OMUX1_DIS        0                  0x0              
++ * 0xBB[2]     OMUX2_DIS        0                  0x0              
++ * 0xBB[3]     OMUX3_DIS        0                  0x0              
++ * 0xBB[4]     OMUX4_DIS        0                  0x0              
++ * 0xBB[5]     OMUX5_DIS        1                  0x1              
++ * 0xBC[0]     OUT0_DIS         0                  0x0              
++ * 0xBC[1]     OUT1_DIS         0                  0x0              
++ * 0xBC[3]     OUT2_DIS         0                  0x0              
++ * 0xBC[6]     OUT3_DIS         0                  0x0              
++ * 0xBD[1]     OUT4_DIS         0                  0x0              
++ * 0xBD[2]     OUT5_DIS         1                  0x1              
++ * 0xBE[7:0]   PLL_MODE         16                 0x10             
++ * 0xBF[0]     XOSC_CINT_ENA    1                  0x1              
++ * 0xC0[5:0]   XOSC_CTRIM_XIN   48                 0x30             
++ * 0xC1[5:0]   XOSC_CTRIM_XOUT  48                 0x30
++ * 
++ *
++ */
++
++#endif
+\ No newline at end of file
+diff -Naur --no-dereference '--exclude=.git' A/board/intel/agilex5-iG58m/socfpga-iG58m.c B/board/intel/agilex5-iG58m/socfpga-iG58m.c
+--- A/board/intel/agilex5-iG58m/socfpga-iG58m.c	1970-01-01 05:30:00.000000000 +0530
++++ B/board/intel/agilex5-iG58m/socfpga-iG58m.c	2025-12-09 16:47:52.135685588 +0530
+@@ -0,0 +1,592 @@
++/* SPDX-License-Identifier: GPL-2.0 */
++/*
++ * Copyright (C) 2025 iWave Global 
++ * IP Support <support.ip@iwave-global.com>
++ */
++
++#include <command.h>
++#include <asm/gpio.h>
++#include <i2c.h>
++#include <linux/delay.h>
++#include <phy.h>
++#include <asm/arch/mailbox_s10.h>
++#include <asm/arch/rsu.h>
++#include <asm/arch/rsu_s10.h>
++#include <string.h>
++#include <asm/io.h>
++#include <iG_fru.h>
++#include "zl30733-cs1-reg.h"
++#include "Si5332-cs2-reg.h"
++
++#define I2C_BUS_0			0x0
++#define IOEXP2_I2C_BUS			0x2
++#define FMC_PLUS_I2C_BUS		0x3
++#define PMIC_I2C_SLAVE_ADDR		0x58
++#define ZL30733_CB_CS1_I2C_SLAVE_ADDR	0x70
++#define SI5332_CB_CS2_I2C_SLAVE_ADDR	0x6A
++#define EEPROM_I2C_SLAVE_ADDR		0x52
++#define I2CEXP_I2C_SLAVE_ADDR		0x71
++#define IOEXP2_I2C_SLAVE_ADDR		0x21
++#define FMC_PLUS_I2C_SLAVE_ADDR		0x50
++#define SOM_I2C_BUS                     0x0
++#define SOM_EEPROM_ADDR                 0x56
++#define BSP_VERSION			"iG-PRHSZ-SC-01-R2.0-REL0.1-SD2.0-Q25.1-L6.12.11"
++
++
++
++int configure_pmic_ldo2(void);
++int configure_pmic_ldo3(void);
++int configure_pmic_ldo4(void);
++int configure_pmic_vbuck3(void);
++int config_zl30733_cs(void);
++int config_si5332_cs(void);
++int usb_power_enable(void);
++void iG58m_agilex5_board_info(void);
++int print_carrier_board_version(void);
++int board_soft_reset(void);
++int io_expander2_init(void);
++int fmc_plus_power_sequence(void);
++int print_SOM_version(void);
++
++
++int board_soft_reset(void)
++{
++	struct gpio_desc eth_reset;
++	int nodeoffset;
++	const void *blob = gd->fdt_blob;
++	/*IG58M: Reset: Same reset is used for both GMAC2 PHY and I2C-MUX*/
++ 
++	nodeoffset = fdt_path_offset(blob, "/soc/ethernet@10830000/mdio0/ethernet-phy@4");
++	if (nodeoffset < 0) {
++		printf("GMAC2:\tFailed to find gmac2 node in device tree\n");
++		return -1;
++	}
++ 
++	gpio_request_by_name_nodev(offset_to_ofnode(nodeoffset), "phy-reset-gpio", 0, &eth_reset, 0);
++	if (!dm_gpio_is_valid(&eth_reset)) {
++		printf("GMAC2:\tphy-reset-gpio pin not valid\n");
++		return -1;
++	}
++ 
++	dm_gpio_set_dir_flags(&eth_reset, GPIOD_IS_OUT);
++	/*IG58M: Assert PHY reset (active-low means set=1 drives low) */
++	dm_gpio_set_value(&eth_reset, 1);
++	udelay(1000);
++ 
++	/*IG58M: Release PHY reset (set=0 drives high) */
++	dm_gpio_set_value(&eth_reset, 0);
++	udelay(10000);
++ 
++	return 0;
++}
++
++int board_late_init(void)
++{
++    const char *rbffile = "af4_fpga.core.rbf";
++    ulong rbf_addr = 0x87000000;
++    char cmd[128];
++    int rbf_load_success = 0;
++    u32 reset_val;
++
++    udelay(1500000);
++
++    configure_pmic_ldo2();
++    configure_pmic_ldo3();
++    configure_pmic_ldo4();
++    configure_pmic_vbuck3();
++    config_zl30733_cs();
++    config_si5332_cs();
++    udelay(500000);
++
++    reset_val = readl(0x10D11000);
++    printf("RESET STATUS: [0x10D11000] = 0x%08x\n", reset_val);
++
++	/* Check cold reset condition */
++    	if (reset_val & 0x00000001) {
++		printf("Cold Reset: FPGA already configured. Skipping RBF load.\n");
++		rbf_load_success = 1;
++		goto post_rbf_load;
++	}
++		printf("POR: Proceeding with RBF load.\n");
++		udelay(300000);
++	/* Load RBF from MMC */
++		snprintf(cmd, sizeof(cmd),"fatload mmc 0:1 0x%lx %s", rbf_addr, rbffile);
++		udelay(200000); 
++	if (run_command(cmd, 0) == 0) {
++		printf("RBF load success: %s loaded into 0x%lx\n", rbffile, rbf_addr);
++		/* Program FPGA using actual file size */
++		udelay(300000);
++		snprintf(cmd, sizeof(cmd), "fpga load 0 0x%lx ${filesize}", rbf_addr);
++		udelay(300000);
++		if (run_command(cmd, 0) == 0) {
++		udelay(200000);
++			rbf_load_success = 1;
++			printf("FPGA programming successful.\n");
++		}
++ 
++	} else {
++		printf("RBF load failed: %s not found on MMC 0:1.\n", rbffile);
++	}
++     post_rbf_load:
++	if (rbf_load_success) {
++        	udelay(200000);
++        	run_command("bridge enable 0x3", 0);
++	} else {
++        	printf("ERROR: FPGA programming failed. Bridges will not be enabled.\n");
++    }
++
++    usb_power_enable();
++    iG58m_agilex5_board_info();
++
++	if (io_expander2_init()) {
++        printf("ERROR: IO Expander 2 initialization failed.\n");
++        return -1;
++    }
++
++    fmc_plus_power_sequence();
++    board_soft_reset();
++
++    	return 0;
++}
++
++/* PMIC LDIO2 configuration */
++int configure_pmic_ldo2(void)
++{
++	u8 data;
++	u32 voltage;
++	int volt, voltage1, ret, nodeoffset;
++	struct udevice *dev;
++	const void *blob = gd->fdt_blob;
++
++	nodeoffset = fdt_path_offset(blob, "/pmic");
++	ofnode_read_u32(offset_to_ofnode(nodeoffset), "pmic-ldo2-millivolt", &voltage);
++
++	if ((voltage < 1000) || (voltage > 3300) || (voltage % 50)) {
++		printf("PMIC:\tVoltage Out of range. Supported voltage range 1.0V to 3.3V in steps of 0.05v\n");
++		return -1;
++	}
++
++	ret = i2c_get_chip_for_busnum(0, PMIC_I2C_SLAVE_ADDR, 1, &dev);
++
++	if (ret) {
++		printf("PMIC:\tFailed to find PMIC !!!\n");
++		return -1;
++	}
++
++	i2c_set_chip_flags(dev, DM_I2C_CHIP_RD_ADDRESS | DM_I2C_CHIP_WR_ADDRESS);
++
++	voltage1 = ((voltage - 900) / 50);
++	volt = (int)voltage1;
++	volt += 2;
++	data = volt;
++
++	dm_i2c_write(dev, 0xAA, &data, 1);
++	data = 1;
++	dm_i2c_write(dev, 0x27, &data, 1);
++
++	printf("PMIC:\tLD02 (HVIO BANK 5A) set to %d.%2dV\n", voltage / 1000, voltage % 1000);
++
++	return 0;
++}
++
++/* PMIC LDIO3 configuration */
++int configure_pmic_ldo3(void)
++{
++	u8 data;
++	u32 voltage;
++	int volt, voltage1, ret, nodeoffset;
++	struct udevice *dev;
++	const void *blob = gd->fdt_blob;
++
++	nodeoffset = fdt_path_offset(blob, "/pmic");
++	ofnode_read_u32(offset_to_ofnode(nodeoffset), "pmic-ldo3-millivolt", &voltage);
++
++	if ((voltage < 1000) || (voltage > 3300) || (voltage % 50)) {
++		printf("PMIC:\tVoltage Out of range. Supported voltage range 1.0V to 3.3V in steps of 0.05v\n");
++		return -1;
++	}
++
++	ret = i2c_get_chip_for_busnum(0, PMIC_I2C_SLAVE_ADDR, 1, &dev);
++
++	if (ret) {
++		printf("PMIC:\tFailed to find PMIC !!!\n");
++		return -1;
++	}
++
++	i2c_set_chip_flags(dev, DM_I2C_CHIP_RD_ADDRESS | DM_I2C_CHIP_WR_ADDRESS);
++
++	voltage1 = ((voltage - 900) / 50);
++	volt = (int)voltage1;
++	volt += 2;
++	data = volt;
++
++	dm_i2c_write(dev, 0xAB, &data, 1);
++	data = 1;
++	dm_i2c_write(dev, 0x28, &data, 1);
++
++	printf("PMIC:\tLD03 (HVIO BANK 6C) set to %d.%2dV\n", voltage / 1000, voltage % 1000);
++
++	return 0;
++}
++
++/* PMIC LDIO4 configuration */
++int configure_pmic_ldo4(void)
++{
++	u8 data;
++	u32 voltage;
++	int volt, voltage1, ret, nodeoffset;
++	struct udevice *dev;
++	const void *blob = gd->fdt_blob;
++
++	nodeoffset = fdt_path_offset(blob, "/pmic");
++	ofnode_read_u32(offset_to_ofnode(nodeoffset), "pmic-ldo4-millivolt", &voltage);
++
++	if ((voltage < 1000) || (voltage > 3300) || (voltage % 50)) {
++		printf("PMIC:\tVoltage Out of range. Supported voltage range 1.0V to 3.3V in steps of 0.05v\n");
++		return -1;
++	}
++
++	ret = i2c_get_chip_for_busnum(0, PMIC_I2C_SLAVE_ADDR, 1, &dev);
++
++	if (ret) {
++		printf("PMIC:\tFailed to find PMIC !!!\n");
++		return -1;
++	}
++
++	i2c_set_chip_flags(dev, DM_I2C_CHIP_RD_ADDRESS | DM_I2C_CHIP_WR_ADDRESS);
++
++	voltage1 = ((voltage - 900) / 50);
++	volt = (int)voltage1;
++	volt += 2;
++	data = volt;
++	dm_i2c_write(dev, 0xAC, &data, 1);
++	data = 1;
++	dm_i2c_write(dev, 0x29, &data, 1);
++	printf("PMIC:\tLD04 (HVIO BANK 5B and 6D) set to %d.%2dV\n", voltage / 1000, voltage % 1000);
++
++	return 0;
++}
++
++/* PMIC VBUCK3 configuration */
++int configure_pmic_vbuck3(void)
++{
++	u8 data;
++	u32 voltage;
++	int volt, voltage1, ret, nodeoffset;
++	struct udevice *dev;
++	const void *blob = gd->fdt_blob;
++
++	nodeoffset = fdt_path_offset(blob, "/pmic");
++	ofnode_read_u32(offset_to_ofnode(nodeoffset), "pmic-vbuck3-millivolt", &voltage);
++
++	if ((voltage < 1200) || (voltage > 1300) || (voltage % 20)) {
++		printf("PMIC:\tVoltage Out of range. Supported voltage range 1.2V to 1.3V in steps of 0.02v\n");
++		return -1;
++	}
++
++	ret = i2c_get_chip_for_busnum(0, PMIC_I2C_SLAVE_ADDR, 1, &dev);
++
++	if (ret) {
++		printf("PMIC:\tFailed to find PMIC !!!\n");
++		return -1;
++	}
++
++	i2c_set_chip_flags(dev, DM_I2C_CHIP_RD_ADDRESS | DM_I2C_CHIP_WR_ADDRESS);
++
++	voltage1 = ((voltage - 800) / 20);
++	volt = (int)voltage1;
++	data = volt;
++	dm_i2c_write(dev, 0xA7, &data, 1);
++	data = 1;
++	dm_i2c_write(dev, 0x24, &data, 1);
++
++	printf("PMIC:\tBUCK3 (HSIO BANK 2A) set to %d.%2dV\n", voltage / 1000, voltage % 1000);
++
++	return 0;
++}
++
++int config_zl30733_cs(void)
++{
++	struct udevice *dev;
++	int ret;
++	int counter = 0;
++	u8 data;
++
++	ret = i2c_get_chip_for_busnum(I2C_BUS_0, ZL30733_CB_CS1_I2C_SLAVE_ADDR, 1, &dev);
++	if (ret) {
++		printf("CLK:\tCarrierboard Clk synthesizer-1 configuration failed\r\n");
++		return ret;
++	}
++
++	for (counter = 0; counter < ZL30733_REG_CONFIG_NUM_COMMANDS; counter++) {
++		if (zl30733_registers[counter].cmd != W) {
++			data = (zl30733_registers[counter].address & 0xFF80) >> 7;
++			ret = dm_i2c_write(dev, 0x7F, &data, 1);
++			if (ret) {
++				printf("CLK:\tCarrierboard Clk synthesizer-1 configuration failed\r\n");
++				return ret;
++			}
++
++			data = zl30733_registers[counter].value;
++			ret = dm_i2c_write(dev, zl30733_registers[counter].address & 0x007F, &data, 1);
++			if (ret) {
++				printf("CLK:\tCarrierboard Clk synthesizer-1 configuration failed\r\n");
++				return ret;
++			}
++		} else {
++			mdelay(zl30733_registers[counter].address / 1000);
++		}
++	}
++	printf("CLK:\tCarrierboard Clk synthesizer-1 configured\r\n");
++
++	return 0;
++}
++
++int config_si5332_cs(void)
++{
++	struct udevice *dev;
++	int ret;
++	int counter = 0;
++	unsigned char value_buf[1];
++	unsigned char page_buf[1];
++	unsigned int page;
++	unsigned int addr;
++	si5332_gm1_revd_register_t si5332_gm1_reg_2;
++
++	ret = i2c_get_chip_for_busnum(0, SI5332_CB_CS2_I2C_SLAVE_ADDR, 1, &dev);
++	if (ret) {
++		printf("CLK:\tCarrierboard Clk synthesizer-2 configuration failed\r\n");
++		return ret;
++	}
++
++	i2c_set_chip_flags(dev, DM_I2C_CHIP_RD_ADDRESS | DM_I2C_CHIP_WR_ADDRESS);
++
++	mdelay(300);
++
++	for (counter = 0; counter < SI5332_GM1_REVD_REG_CONFIG_NUM_REGS; counter++) {
++		si5332_gm1_reg_2 = si5332_gm1_revd_registers[counter];
++		page = si5332_gm1_reg_2.address / 256;
++		addr = si5332_gm1_reg_2.address % 256;
++		page_buf[0] = page & 0xFF;
++		value_buf[0] = si5332_gm1_reg_2.value & 0xFF;
++		dm_i2c_write(dev, 0x01, (const uint8_t *)&page_buf, 1);
++		dm_i2c_write(dev, addr, (const uint8_t *)&value_buf, 1);
++	}
++	printf("CLK:\tCarrierboard Clk synthesizer-2 configured\r\n");
++
++	return 0;
++}
++
++int board_phy_config(struct phy_device *phydev)
++{
++	if (phydev->drv->config)
++		phydev->drv->config(phydev);
++
++	/* Enable RGMII RXC skew and PHY mode select to RGMII copper */
++	phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x1f);
++	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, 0x8);
++
++	/* set IO voltage to 1.8V */
++	phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x00);
++	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, 0x82ee);
++	phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x05);
++	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, 0x100);
++
++	return 0;
++}
++
++int usb_power_enable(void)
++{
++	struct gpio_desc usb_en;
++	int nodeoffset;
++	const void *blob = gd->fdt_blob;
++
++	nodeoffset = fdt_path_offset(blob, "/usb_en");
++	if (nodeoffset < 0) {
++		printf("USB_PWR:\tFailed to find USB enable node in device tree\n");
++		return -1;
++	}
++
++	gpio_request_by_name_nodev(offset_to_ofnode(nodeoffset), "usb-en", 0, &usb_en, 0);
++	if (!dm_gpio_is_valid(&usb_en)) {
++		printf("USB_PWR:\tusb-en pin not valid\n");
++		return -1;
++	}
++
++	dm_gpio_set_dir_flags(&usb_en, GPIOD_IS_OUT);
++	dm_gpio_set_value(&usb_en, 1);
++
++	return 0;
++}
++int print_SOM_version()
++{
++    char bsp_ver[54], som_serial_ver[20], som_num[20];
++    int ret;
++    struct udevice *dev;
++
++    ret = i2c_get_chip_for_busnum(SOM_I2C_BUS, SOM_EEPROM_ADDR, 1, &dev);
++
++    if (ret) {
++        printf("I2C:\tFailed to find EEPROM !!!\n");
++        printf("Unable to read SOM information from EEPROM !!!\n\n");
++        return -1;
++    }
++
++    i2c_set_chip_flags(dev, DM_I2C_CHIP_RD_ADDRESS | DM_I2C_CHIP_WR_ADDRESS);
++
++    dm_i2c_read(dev, 0x40, bsp_ver, 54);
++    dm_i2c_read(dev, 0x20, som_serial_ver, 16);
++    dm_i2c_read(dev, 0x30, som_num, 12);
++
++    bsp_ver[54] = '\0';
++    som_serial_ver[16] = '\0';
++    som_num[12] = '\0';
++
++    printf("\nBoard Info:\n");
++    printf("\tSOM Version\t: %s-%s\n", som_serial_ver, som_num);
++    printf("\tBSP Version (Shipped)\t: %s\n", bsp_ver);
++    return 0;
++}
++
++void iG58m_agilex5_board_info(void)
++{
++	printf("\nBSP Info:\n");
++	printf ("\tBSP Version\t: %s\n", BSP_VERSION);
++	print_SOM_version();
++	print_carrier_board_version();
++}
++
++int print_carrier_board_version(void)
++{
++	char crb_ver[20], crb_num[20];
++	int ret;
++	struct udevice *dev;
++
++	ret = i2c_get_chip_for_busnum(I2C_BUS_0, EEPROM_I2C_SLAVE_ADDR, 1, &dev);
++
++	if (ret) {
++		printf("I2C:\tFailed to find EEPROM !!!\n");
++		printf("Unable to read Carrier board information from EEPROM !!!\n\n");
++		return -1;
++	}
++
++	i2c_set_chip_flags(dev, DM_I2C_CHIP_RD_ADDRESS | DM_I2C_CHIP_WR_ADDRESS);
++
++	dm_i2c_read(dev, 0x20, crb_ver, 16);
++	dm_i2c_read(dev, 0x30, crb_num, 12);
++
++	crb_ver[16] = '\0';
++	crb_num[12] = '\0';
++
++	printf("\tCarrier Serial Number\t: %s-%s\n", crb_ver, crb_num);
++
++	return 0;
++}
++
++int io_expander2_init(void)
++{
++	int ret;
++	struct udevice *bus, *dev;
++	ret = uclass_get_device(UCLASS_I2C, I2C_BUS_0, &bus);
++	if (ret)
++		return -1;
++
++	ret = dm_i2c_probe(bus, I2CEXP_I2C_SLAVE_ADDR, 0x0, &dev);
++	if (ret)
++		return -1;
++
++	/* iG58M: I2C: No register address will be sent. So, set to 0 */
++	i2c_set_chip_offset_len(dev, 0);
++
++	ret = uclass_get_device(UCLASS_I2C, IOEXP2_I2C_BUS, &bus);
++	if (ret)
++		return -1;
++
++	ret = dm_i2c_probe(bus, IOEXP2_I2C_SLAVE_ADDR, DM_I2C_CHIP_RD_ADDRESS | DM_I2C_CHIP_WR_ADDRESS, &dev);
++	if (ret)
++		return -1;
++
++	/* iG58M: I2C: 8bit register address will be sent. So, set to 1 */
++	i2c_set_chip_offset_len(dev, 1);
++
++	return 0;
++}
++
++int fmc_plus_power_sequence(void)
++{
++	int ret;
++	struct gpio_desc prsnt_m2c, vcc_adj, vcc_3v3, vcc_12v, pg_c2m;
++	int nodeoffset;
++	const void *blob = gd->fdt_blob;
++	u32 vadj_volt;
++
++	nodeoffset = fdt_path_offset(blob, "/fmc_plus");
++
++	ofnode_read_u32(offset_to_ofnode(nodeoffset), "vadj-millivolt", &vadj_volt);
++
++	gpio_request_by_name_nodev(offset_to_ofnode(nodeoffset), "prsnt-m2c", 0, &prsnt_m2c, 0);
++	if (!dm_gpio_is_valid(&prsnt_m2c)) {
++		printf("FMC+:\tPRSNT_M2C Pin not valid\n");
++		goto end;
++	}
++
++	gpio_request_by_name_nodev(offset_to_ofnode(nodeoffset), "vcc-adj", 0, &vcc_adj, 0);
++	if (!dm_gpio_is_valid(&vcc_adj)) {
++		printf("FMC+:\tVCC_ADJ Pin not valid\n");
++		goto end;
++	}
++
++	gpio_request_by_name_nodev(offset_to_ofnode(nodeoffset), "vcc-3v3", 0, &vcc_3v3, 0);
++	if (!dm_gpio_is_valid(&vcc_3v3)) {
++		printf("FMC+:\tVCC_3V3 Pin not valid\n");
++		goto end;
++	}
++
++	gpio_request_by_name_nodev(offset_to_ofnode(nodeoffset), "vcc-12v", 0, &vcc_12v, 0);
++	if (!dm_gpio_is_valid(&vcc_12v)) {
++		printf("FMC+:\tVCC_12V Pin not valid\n");
++		goto end;
++	}
++
++	gpio_request_by_name_nodev(offset_to_ofnode(nodeoffset), "pg-c2m", 0, &pg_c2m, 0);
++	if (!dm_gpio_is_valid(&pg_c2m)) {
++		printf("FMC+:\tPG_C2M Pin not valid\n");
++		goto end;
++	}
++
++	dm_gpio_set_dir_flags(&prsnt_m2c, GPIOD_IS_IN);
++	dm_gpio_set_dir_flags(&vcc_12v, GPIOD_IS_OUT);
++	dm_gpio_set_dir_flags(&vcc_3v3, GPIOD_IS_OUT);
++	dm_gpio_set_dir_flags(&pg_c2m, GPIOD_IS_OUT);
++	dm_gpio_set_dir_flags(&vcc_adj, GPIOD_IS_OUT);
++
++	if (dm_gpio_get_value(&prsnt_m2c)) {
++		printf("FMC+:\tFMC+ Not connected\n");
++		goto end;
++	}
++
++	int fmc_vadj_support(int i2c_bus, int i2c_address, u32 vadj_volt);
++	ret = fmc_vadj_support(FMC_PLUS_I2C_BUS, FMC_PLUS_I2C_SLAVE_ADDR, vadj_volt);
++	if (ret) {
++		dm_gpio_set_value(&vcc_12v, 1);
++		dm_gpio_set_value(&vcc_3v3, 1);
++		dm_gpio_set_value(&pg_c2m, 1);
++		dm_gpio_set_value(&vcc_adj, 1);
++		printf("FMC+:\tFMC+ Vadj Voltage set to %d.%dV\n", vadj_volt / 1000, (vadj_volt % 1000) / 100);
++	} else {
++		printf("FMC+:\tFMC+ connected does not support %d.%dV\n", vadj_volt / 1000, (vadj_volt % 1000) / 100);
++		goto end;
++	}
++
++	if (!(dm_gpio_get_value(&vcc_adj) && dm_gpio_get_value(&vcc_3v3) && dm_gpio_get_value(&vcc_12v) && dm_gpio_get_value(&pg_c2m))) {
++		printf("FMC+:\tError on FMC+ power up ..!!\n");
++		goto end;
++	}
++
++	printf("FMC+:\tFMC+ Powered up\n");
++	return 0;
++
++end:
++	printf("FMC+:\tFMC+ Power up failed ...!!!\n");
++	return -1;
++}
+diff -Naur --no-dereference '--exclude=.git' A/board/intel/agilex5-iG58m/zl30733-cs1-reg.h B/board/intel/agilex5-iG58m/zl30733-cs1-reg.h
+--- A/board/intel/agilex5-iG58m/zl30733-cs1-reg.h	1970-01-01 05:30:00.000000000 +0530
++++ B/board/intel/agilex5-iG58m/zl30733-cs1-reg.h	2025-12-09 16:47:52.135685588 +0530
+@@ -0,0 +1,1660 @@
++/*
++ * ZL30733
++ * GUI Version               : 2.1.0
++ * File Generation Date      : 2023/10/05 09:40:59
++ * DUT FW Version            : not connected (work-offline mode)
++ * =============================================================================
++ * NOTE:
++ * This is an incremental configuration script.
++ * For proper device operation, all register write and wait commands in
++ * this file must be performed in the sequence listed.
++ * =============================================================================
++ * Configuration script commands
++ * 1. Register Write Command:
++ *         X , <register_address> , <data_bytes>
++ *         Both <register_address> and <data_bytes> are in hexadecimal
++ *         format and must have the "0x" prefix.
++ *         The register_address contains the page number and page offset.
++ *         The page number is stored in register_address[14:7].
++ *         The page offset is stored in register_address[6:0].
++ * 2. Wait Command:
++ *         W , <time_microseconds>
++ *         The wait time is specified in microseconds.
++ * =============================================================================
++ */
++#ifndef ZL30733_REG_CONFIG_HEADER
++#define ZL30733_REG_CONFIG_HEADER
++
++#define ZL30733_REG_CONFIG_NUM_COMMANDS		1572
++
++typedef enum {
++	X,                            // Register Write command
++	W                             // Wait Command
++} config_script_cmd;
++
++typedef struct
++{
++	config_script_cmd cmd;        // Configuration script command
++	unsigned int address;         // 16-bit register address
++	unsigned char value;          // 8-bit register data
++
++} zl30733_register_t;
++
++zl30733_register_t const zl30733_registers[ZL30733_REG_CONFIG_NUM_COMMANDS] =
++{
++	{X , 0x0007 , 0xFF},             // custom_config_ver
++	{X , 0x0008 , 0xFF},             // custom_config_ver
++	{X , 0x0009 , 0xFF},             // custom_config_ver
++	{X , 0x000A , 0xFF},             // custom_config_ver
++	{X , 0x000B , 0x02},             // central_freq_offset
++	{X , 0x000C , 0x76},             // central_freq_offset
++	{X , 0x000D , 0x91},             // central_freq_offset
++	{X , 0x000E , 0x40},             // central_freq_offset
++	{X , 0x0021 , 0x00},             // xo_amp_sel
++	{X , 0x0022 , 0x00},             // xo_osci_sel
++	{X , 0x0023 , 0x00},             // xo_osco_sel
++	{X , 0x0025 , 0x00},             // xo_tst_ctrl
++	{X , 0x0026 , 0x01},             // xo_config
++	{X , 0x0027 , 0x43},             // sys_apll_source_priority
++	{X , 0x0028 , 0x21},             // sys_apll_source_priority
++	{X , 0x0029 , 0x40},             // sys_apll_source_config
++	{X , 0x002A , 0x34},             // sys_apll_primary_div_int
++	{X , 0x002B , 0x00},             // sys_apll_primary_div_frac
++	{X , 0x002C , 0x00},             // sys_apll_primary_div_frac
++	{X , 0x002D , 0x00},             // sys_apll_primary_div_frac
++	{X , 0x002E , 0x00},             // sys_apll_primary_div_frac
++	{X , 0x002F , 0x00},             // sys_apll_primary_div_frac
++	{X , 0x0030 , 0x02},             // sys_apll_secondary_div
++	{X , 0x0034 , 0x00},             // pi_online_cal_ctrl
++	{X , 0x0035 , 0x04},             // pi_online_cal_select
++	{X , 0x0036 , 0x00},             // pi_online_cal_synth_mask
++	{X , 0x0046 , 0x00},             // master_clk_ofst
++	{X , 0x0047 , 0x00},             // master_clk_ofst
++	{X , 0x0048 , 0x00},             // master_clk_ofst
++	{X , 0x0049 , 0x00},             // master_clk_ofst
++	{X , 0x004A , 0x00},             // master_clk_ofst
++	{X , 0x004B , 0x00},             // gui_switches
++	{X , 0x004C , 0x00},             // gui_switches
++	{X , 0x0033 , 0x01},             // master_clk_cfg_ready
++	{W , 100000},
++
++	{X , 0x0502 , 0x00},             // ref_mb_mask
++	{X , 0x0503 , 0x01},             // ref_mb_mask
++	{X , 0x0504 , 0x02},             // ref_mb_sem
++	{W , 20000},
++	{X , 0x0505 , 0x27},             // ref0p_freq_base
++	{X , 0x0506 , 0x10},             // ref0p_freq_base
++	{X , 0x0507 , 0x27},             // ref0p_freq_mult
++	{X , 0x0508 , 0x10},             // ref0p_freq_mult
++	{X , 0x0509 , 0x00},             // ref0p_ratio_m
++	{X , 0x050A , 0x01},             // ref0p_ratio_m
++	{X , 0x050B , 0x00},             // ref0p_ratio_n
++	{X , 0x050C , 0x01},             // ref0p_ratio_n
++	{X , 0x050D , 0x25},             // ref0p_config
++	{X , 0x050E , 0x00},             // ref0p_clk_domain
++	{X , 0x050F , 0x05},             // ref0p_scm
++	{X , 0x0510 , 0x00},             // ref0p_scm_fine
++	{X , 0x0511 , 0x00},             // ref0p_scm_fine
++	{X , 0x0512 , 0x00},             // ref0p_scm_fine
++	{X , 0x0513 , 0x00},             // ref0p_scm_fine
++	{X , 0x0514 , 0x05},             // ref0p_cfm
++	{X , 0x0516 , 0x00},             // ref0p_gst_disqual
++	{X , 0x0517 , 0x05},             // ref0p_gst_disqual
++	{X , 0x0518 , 0x00},             // ref0p_gst_qual
++	{X , 0x0519 , 0x14},             // ref0p_gst_qual
++	{X , 0x051A , 0x01},             // ref0p_meas_freq_period
++	{X , 0x051B , 0x00},             // ref0p_pfm_ctrl
++	{X , 0x051C , 0x09},             // ref0p_pfm_disqualify
++	{X , 0x051D , 0x60},             // ref0p_pfm_disqualify
++	{X , 0x051E , 0x07},             // ref0p_pfm_qualify
++	{X , 0x051F , 0x30},             // ref0p_pfm_qualify
++	{X , 0x0520 , 0x00},             // ref0p_pfm_period
++	{X , 0x0521 , 0x00},             // ref0p_pfm_period
++	{X , 0x0522 , 0x28},             // ref0p_pfm_filter_limit
++	{X , 0x0528 , 0x00},             // ref0p_phase_offset_compensation
++	{X , 0x0529 , 0x00},             // ref0p_phase_offset_compensation
++	{X , 0x052A , 0x00},             // ref0p_phase_offset_compensation
++	{X , 0x052B , 0x00},             // ref0p_phase_offset_compensation
++	{X , 0x052E , 0x01},             // ref0p_sync_ctrl
++	{X , 0x052F , 0x00},             // ref0p_sync_misc
++	{X , 0x0530 , 0x00},             // ref0p_esync_div
++	{X , 0x0531 , 0x00},             // ref0p_esync_div
++	{X , 0x0532 , 0x00},             // ref0p_esync_div
++	{X , 0x0533 , 0x00},             // ref0p_esync_div
++	{X , 0x0534 , 0x00},             // ref0p_gpi_select
++	{X , 0x0535 , 0x00},             // ref0p_gpi_select
++	{X , 0x0536 , 0x00},             // ref0p_gpi_config
++	{X , 0x0537 , 0x00},             // ref0p_esync_min_low_pulse
++	{X , 0x0538 , 0x00},             // ref0p_esync_min_hi_pulse
++	{X , 0x0539 , 0x00},             // ref0p_esync_max_low_pulse
++	{X , 0x053A , 0x00},             // ref0p_esync_max_hi_pulse
++	{X , 0x0504 , 0x01},             // ref_mb_sem
++	{W , 20000},
++
++	{X , 0x0502 , 0x00},             // ref_mb_mask
++	{X , 0x0503 , 0x02},             // ref_mb_mask
++	{X , 0x0504 , 0x02},             // ref_mb_sem
++	{W , 20000},
++	{X , 0x0505 , 0x61},             // ref0n_freq_base
++	{X , 0x0506 , 0xA8},             // ref0n_freq_base
++	{X , 0x0507 , 0x03},             // ref0n_freq_mult
++	{X , 0x0508 , 0xE8},             // ref0n_freq_mult
++	{X , 0x0509 , 0x00},             // ref0n_ratio_m
++	{X , 0x050A , 0x01},             // ref0n_ratio_m
++	{X , 0x050B , 0x00},             // ref0n_ratio_n
++	{X , 0x050C , 0x01},             // ref0n_ratio_n
++	{X , 0x050D , 0x01},             // ref0n_config
++	{X , 0x050E , 0x00},             // ref0n_clk_domain
++	{X , 0x050F , 0x05},             // ref0n_scm
++	{X , 0x0510 , 0x00},             // ref0n_scm_fine
++	{X , 0x0511 , 0x00},             // ref0n_scm_fine
++	{X , 0x0512 , 0x00},             // ref0n_scm_fine
++	{X , 0x0513 , 0x00},             // ref0n_scm_fine
++	{X , 0x0514 , 0x05},             // ref0n_cfm
++	{X , 0x0516 , 0x00},             // ref0n_gst_disqual
++	{X , 0x0517 , 0x05},             // ref0n_gst_disqual
++	{X , 0x0518 , 0x00},             // ref0n_gst_qual
++	{X , 0x0519 , 0x14},             // ref0n_gst_qual
++	{X , 0x051A , 0x01},             // ref0n_meas_freq_period
++	{X , 0x051B , 0x00},             // ref0n_pfm_ctrl
++	{X , 0x051C , 0xB3},             // ref0n_pfm_disqualify
++	{X , 0x051D , 0xB0},             // ref0n_pfm_disqualify
++	{X , 0x051E , 0x9C},             // ref0n_pfm_qualify
++	{X , 0x051F , 0x40},             // ref0n_pfm_qualify
++	{X , 0x0520 , 0x00},             // ref0n_pfm_period
++	{X , 0x0521 , 0x00},             // ref0n_pfm_period
++	{X , 0x0522 , 0x28},             // ref0n_pfm_filter_limit
++	{X , 0x0528 , 0x00},             // ref0n_phase_offset_compensation
++	{X , 0x0529 , 0x00},             // ref0n_phase_offset_compensation
++	{X , 0x052A , 0x00},             // ref0n_phase_offset_compensation
++	{X , 0x052B , 0x00},             // ref0n_phase_offset_compensation
++	{X , 0x052E , 0x00},             // ref0n_sync_ctrl
++	{X , 0x052F , 0x00},             // ref0n_sync_misc
++	{X , 0x0530 , 0x00},             // ref0n_esync_div
++	{X , 0x0531 , 0x00},             // ref0n_esync_div
++	{X , 0x0532 , 0x00},             // ref0n_esync_div
++	{X , 0x0533 , 0x00},             // ref0n_esync_div
++	{X , 0x0534 , 0x00},             // ref0n_gpi_select
++	{X , 0x0535 , 0x00},             // ref0n_gpi_select
++	{X , 0x0536 , 0x00},             // ref0n_gpi_config
++	{X , 0x0537 , 0x00},             // ref0n_esync_min_low_pulse
++	{X , 0x0538 , 0x00},             // ref0n_esync_min_hi_pulse
++	{X , 0x0539 , 0x00},             // ref0n_esync_max_low_pulse
++	{X , 0x053A , 0x00},             // ref0n_esync_max_hi_pulse
++	{X , 0x0504 , 0x01},             // ref_mb_sem
++	{W , 20000},
++
++	{X , 0x0502 , 0x00},             // ref_mb_mask
++	{X , 0x0503 , 0x04},             // ref_mb_mask
++	{X , 0x0504 , 0x02},             // ref_mb_sem
++	{W , 20000},
++	{X , 0x0505 , 0x61},             // ref1p_freq_base
++	{X , 0x0506 , 0xA8},             // ref1p_freq_base
++	{X , 0x0507 , 0x03},             // ref1p_freq_mult
++	{X , 0x0508 , 0xE8},             // ref1p_freq_mult
++	{X , 0x0509 , 0x00},             // ref1p_ratio_m
++	{X , 0x050A , 0x01},             // ref1p_ratio_m
++	{X , 0x050B , 0x00},             // ref1p_ratio_n
++	{X , 0x050C , 0x01},             // ref1p_ratio_n
++	{X , 0x050D , 0x00},             // ref1p_config
++	{X , 0x050E , 0x00},             // ref1p_clk_domain
++	{X , 0x050F , 0x05},             // ref1p_scm
++	{X , 0x0510 , 0x00},             // ref1p_scm_fine
++	{X , 0x0511 , 0x00},             // ref1p_scm_fine
++	{X , 0x0512 , 0x00},             // ref1p_scm_fine
++	{X , 0x0513 , 0x00},             // ref1p_scm_fine
++	{X , 0x0514 , 0x05},             // ref1p_cfm
++	{X , 0x0516 , 0x00},             // ref1p_gst_disqual
++	{X , 0x0517 , 0x05},             // ref1p_gst_disqual
++	{X , 0x0518 , 0x00},             // ref1p_gst_qual
++	{X , 0x0519 , 0x14},             // ref1p_gst_qual
++	{X , 0x051A , 0x01},             // ref1p_meas_freq_period
++	{X , 0x051B , 0x00},             // ref1p_pfm_ctrl
++	{X , 0x051C , 0xB3},             // ref1p_pfm_disqualify
++	{X , 0x051D , 0xB0},             // ref1p_pfm_disqualify
++	{X , 0x051E , 0x9C},             // ref1p_pfm_qualify
++	{X , 0x051F , 0x40},             // ref1p_pfm_qualify
++	{X , 0x0520 , 0x00},             // ref1p_pfm_period
++	{X , 0x0521 , 0x00},             // ref1p_pfm_period
++	{X , 0x0522 , 0x28},             // ref1p_pfm_filter_limit
++	{X , 0x0528 , 0x00},             // ref1p_phase_offset_compensation
++	{X , 0x0529 , 0x00},             // ref1p_phase_offset_compensation
++	{X , 0x052A , 0x00},             // ref1p_phase_offset_compensation
++	{X , 0x052B , 0x00},             // ref1p_phase_offset_compensation
++	{X , 0x052E , 0x00},             // ref1p_sync_ctrl
++	{X , 0x052F , 0x00},             // ref1p_sync_misc
++	{X , 0x0530 , 0x00},             // ref1p_esync_div
++	{X , 0x0531 , 0x00},             // ref1p_esync_div
++	{X , 0x0532 , 0x00},             // ref1p_esync_div
++	{X , 0x0533 , 0x00},             // ref1p_esync_div
++	{X , 0x0534 , 0x00},             // ref1p_gpi_select
++	{X , 0x0535 , 0x00},             // ref1p_gpi_select
++	{X , 0x0536 , 0x00},             // ref1p_gpi_config
++	{X , 0x0537 , 0x00},             // ref1p_esync_min_low_pulse
++	{X , 0x0538 , 0x00},             // ref1p_esync_min_hi_pulse
++	{X , 0x0539 , 0x00},             // ref1p_esync_max_low_pulse
++	{X , 0x053A , 0x00},             // ref1p_esync_max_hi_pulse
++	{X , 0x0504 , 0x01},             // ref_mb_sem
++	{W , 20000},
++
++	{X , 0x0502 , 0x00},             // ref_mb_mask
++	{X , 0x0503 , 0x08},             // ref_mb_mask
++	{X , 0x0504 , 0x02},             // ref_mb_sem
++	{W , 20000},
++	{X , 0x0505 , 0x61},             // ref1n_freq_base
++	{X , 0x0506 , 0xA8},             // ref1n_freq_base
++	{X , 0x0507 , 0x03},             // ref1n_freq_mult
++	{X , 0x0508 , 0xE8},             // ref1n_freq_mult
++	{X , 0x0509 , 0x00},             // ref1n_ratio_m
++	{X , 0x050A , 0x01},             // ref1n_ratio_m
++	{X , 0x050B , 0x00},             // ref1n_ratio_n
++	{X , 0x050C , 0x01},             // ref1n_ratio_n
++	{X , 0x050D , 0x00},             // ref1n_config
++	{X , 0x050E , 0x00},             // ref1n_clk_domain
++	{X , 0x050F , 0x05},             // ref1n_scm
++	{X , 0x0510 , 0x00},             // ref1n_scm_fine
++	{X , 0x0511 , 0x00},             // ref1n_scm_fine
++	{X , 0x0512 , 0x00},             // ref1n_scm_fine
++	{X , 0x0513 , 0x00},             // ref1n_scm_fine
++	{X , 0x0514 , 0x05},             // ref1n_cfm
++	{X , 0x0516 , 0x00},             // ref1n_gst_disqual
++	{X , 0x0517 , 0x05},             // ref1n_gst_disqual
++	{X , 0x0518 , 0x00},             // ref1n_gst_qual
++	{X , 0x0519 , 0x14},             // ref1n_gst_qual
++	{X , 0x051A , 0x01},             // ref1n_meas_freq_period
++	{X , 0x051B , 0x00},             // ref1n_pfm_ctrl
++	{X , 0x051C , 0xB3},             // ref1n_pfm_disqualify
++	{X , 0x051D , 0xB0},             // ref1n_pfm_disqualify
++	{X , 0x051E , 0x9C},             // ref1n_pfm_qualify
++	{X , 0x051F , 0x40},             // ref1n_pfm_qualify
++	{X , 0x0520 , 0x00},             // ref1n_pfm_period
++	{X , 0x0521 , 0x00},             // ref1n_pfm_period
++	{X , 0x0522 , 0x28},             // ref1n_pfm_filter_limit
++	{X , 0x0528 , 0x00},             // ref1n_phase_offset_compensation
++	{X , 0x0529 , 0x00},             // ref1n_phase_offset_compensation
++	{X , 0x052A , 0x00},             // ref1n_phase_offset_compensation
++	{X , 0x052B , 0x00},             // ref1n_phase_offset_compensation
++	{X , 0x052E , 0x00},             // ref1n_sync_ctrl
++	{X , 0x052F , 0x00},             // ref1n_sync_misc
++	{X , 0x0530 , 0x00},             // ref1n_esync_div
++	{X , 0x0531 , 0x00},             // ref1n_esync_div
++	{X , 0x0532 , 0x00},             // ref1n_esync_div
++	{X , 0x0533 , 0x00},             // ref1n_esync_div
++	{X , 0x0534 , 0x00},             // ref1n_gpi_select
++	{X , 0x0535 , 0x00},             // ref1n_gpi_select
++	{X , 0x0536 , 0x00},             // ref1n_gpi_config
++	{X , 0x0537 , 0x00},             // ref1n_esync_min_low_pulse
++	{X , 0x0538 , 0x00},             // ref1n_esync_min_hi_pulse
++	{X , 0x0539 , 0x00},             // ref1n_esync_max_low_pulse
++	{X , 0x053A , 0x00},             // ref1n_esync_max_hi_pulse
++	{X , 0x0504 , 0x01},             // ref_mb_sem
++	{W , 20000},
++
++	{X , 0x0502 , 0x00},             // ref_mb_mask
++	{X , 0x0503 , 0x10},             // ref_mb_mask
++	{X , 0x0504 , 0x02},             // ref_mb_sem
++	{W , 20000},
++	{X , 0x0505 , 0x61},             // ref2p_freq_base
++	{X , 0x0506 , 0xA8},             // ref2p_freq_base
++	{X , 0x0507 , 0x03},             // ref2p_freq_mult
++	{X , 0x0508 , 0xE8},             // ref2p_freq_mult
++	{X , 0x0509 , 0x00},             // ref2p_ratio_m
++	{X , 0x050A , 0x01},             // ref2p_ratio_m
++	{X , 0x050B , 0x00},             // ref2p_ratio_n
++	{X , 0x050C , 0x01},             // ref2p_ratio_n
++	{X , 0x050D , 0x00},             // ref2p_config
++	{X , 0x050E , 0x00},             // ref2p_clk_domain
++	{X , 0x050F , 0x05},             // ref2p_scm
++	{X , 0x0510 , 0x00},             // ref2p_scm_fine
++	{X , 0x0511 , 0x00},             // ref2p_scm_fine
++	{X , 0x0512 , 0x00},             // ref2p_scm_fine
++	{X , 0x0513 , 0x00},             // ref2p_scm_fine
++	{X , 0x0514 , 0x05},             // ref2p_cfm
++	{X , 0x0516 , 0x00},             // ref2p_gst_disqual
++	{X , 0x0517 , 0x05},             // ref2p_gst_disqual
++	{X , 0x0518 , 0x00},             // ref2p_gst_qual
++	{X , 0x0519 , 0x14},             // ref2p_gst_qual
++	{X , 0x051A , 0x01},             // ref2p_meas_freq_period
++	{X , 0x051B , 0x00},             // ref2p_pfm_ctrl
++	{X , 0x051C , 0xB3},             // ref2p_pfm_disqualify
++	{X , 0x051D , 0xB0},             // ref2p_pfm_disqualify
++	{X , 0x051E , 0x9C},             // ref2p_pfm_qualify
++	{X , 0x051F , 0x40},             // ref2p_pfm_qualify
++	{X , 0x0520 , 0x00},             // ref2p_pfm_period
++	{X , 0x0521 , 0x00},             // ref2p_pfm_period
++	{X , 0x0522 , 0x28},             // ref2p_pfm_filter_limit
++	{X , 0x0528 , 0x00},             // ref2p_phase_offset_compensation
++	{X , 0x0529 , 0x00},             // ref2p_phase_offset_compensation
++	{X , 0x052A , 0x00},             // ref2p_phase_offset_compensation
++	{X , 0x052B , 0x00},             // ref2p_phase_offset_compensation
++	{X , 0x052E , 0x00},             // ref2p_sync_ctrl
++	{X , 0x052F , 0x00},             // ref2p_sync_misc
++	{X , 0x0530 , 0x00},             // ref2p_esync_div
++	{X , 0x0531 , 0x00},             // ref2p_esync_div
++	{X , 0x0532 , 0x00},             // ref2p_esync_div
++	{X , 0x0533 , 0x00},             // ref2p_esync_div
++	{X , 0x0534 , 0x00},             // ref2p_gpi_select
++	{X , 0x0535 , 0x00},             // ref2p_gpi_select
++	{X , 0x0536 , 0x00},             // ref2p_gpi_config
++	{X , 0x0537 , 0x00},             // ref2p_esync_min_low_pulse
++	{X , 0x0538 , 0x00},             // ref2p_esync_min_hi_pulse
++	{X , 0x0539 , 0x00},             // ref2p_esync_max_low_pulse
++	{X , 0x053A , 0x00},             // ref2p_esync_max_hi_pulse
++	{X , 0x0504 , 0x01},             // ref_mb_sem
++	{W , 20000},
++
++	{X , 0x0502 , 0x00},             // ref_mb_mask
++	{X , 0x0503 , 0x20},             // ref_mb_mask
++	{X , 0x0504 , 0x02},             // ref_mb_sem
++	{W , 20000},
++	{X , 0x0505 , 0x61},             // ref2n_freq_base
++	{X , 0x0506 , 0xA8},             // ref2n_freq_base
++	{X , 0x0507 , 0x03},             // ref2n_freq_mult
++	{X , 0x0508 , 0xE8},             // ref2n_freq_mult
++	{X , 0x0509 , 0x00},             // ref2n_ratio_m
++	{X , 0x050A , 0x01},             // ref2n_ratio_m
++	{X , 0x050B , 0x00},             // ref2n_ratio_n
++	{X , 0x050C , 0x01},             // ref2n_ratio_n
++	{X , 0x050D , 0x00},             // ref2n_config
++	{X , 0x050E , 0x00},             // ref2n_clk_domain
++	{X , 0x050F , 0x05},             // ref2n_scm
++	{X , 0x0510 , 0x00},             // ref2n_scm_fine
++	{X , 0x0511 , 0x00},             // ref2n_scm_fine
++	{X , 0x0512 , 0x00},             // ref2n_scm_fine
++	{X , 0x0513 , 0x00},             // ref2n_scm_fine
++	{X , 0x0514 , 0x05},             // ref2n_cfm
++	{X , 0x0516 , 0x00},             // ref2n_gst_disqual
++	{X , 0x0517 , 0x05},             // ref2n_gst_disqual
++	{X , 0x0518 , 0x00},             // ref2n_gst_qual
++	{X , 0x0519 , 0x14},             // ref2n_gst_qual
++	{X , 0x051A , 0x01},             // ref2n_meas_freq_period
++	{X , 0x051B , 0x00},             // ref2n_pfm_ctrl
++	{X , 0x051C , 0xB3},             // ref2n_pfm_disqualify
++	{X , 0x051D , 0xB0},             // ref2n_pfm_disqualify
++	{X , 0x051E , 0x9C},             // ref2n_pfm_qualify
++	{X , 0x051F , 0x40},             // ref2n_pfm_qualify
++	{X , 0x0520 , 0x00},             // ref2n_pfm_period
++	{X , 0x0521 , 0x00},             // ref2n_pfm_period
++	{X , 0x0522 , 0x28},             // ref2n_pfm_filter_limit
++	{X , 0x0528 , 0x00},             // ref2n_phase_offset_compensation
++	{X , 0x0529 , 0x00},             // ref2n_phase_offset_compensation
++	{X , 0x052A , 0x00},             // ref2n_phase_offset_compensation
++	{X , 0x052B , 0x00},             // ref2n_phase_offset_compensation
++	{X , 0x052E , 0x00},             // ref2n_sync_ctrl
++	{X , 0x052F , 0x00},             // ref2n_sync_misc
++	{X , 0x0530 , 0x00},             // ref2n_esync_div
++	{X , 0x0531 , 0x00},             // ref2n_esync_div
++	{X , 0x0532 , 0x00},             // ref2n_esync_div
++	{X , 0x0533 , 0x00},             // ref2n_esync_div
++	{X , 0x0534 , 0x00},             // ref2n_gpi_select
++	{X , 0x0535 , 0x00},             // ref2n_gpi_select
++	{X , 0x0536 , 0x00},             // ref2n_gpi_config
++	{X , 0x0537 , 0x00},             // ref2n_esync_min_low_pulse
++	{X , 0x0538 , 0x00},             // ref2n_esync_min_hi_pulse
++	{X , 0x0539 , 0x00},             // ref2n_esync_max_low_pulse
++	{X , 0x053A , 0x00},             // ref2n_esync_max_hi_pulse
++	{X , 0x0504 , 0x01},             // ref_mb_sem
++	{W , 20000},
++
++	{X , 0x0502 , 0x00},             // ref_mb_mask
++	{X , 0x0503 , 0x40},             // ref_mb_mask
++	{X , 0x0504 , 0x02},             // ref_mb_sem
++	{W , 20000},
++	{X , 0x0505 , 0x61},             // ref3p_freq_base
++	{X , 0x0506 , 0xA8},             // ref3p_freq_base
++	{X , 0x0507 , 0x03},             // ref3p_freq_mult
++	{X , 0x0508 , 0xE8},             // ref3p_freq_mult
++	{X , 0x0509 , 0x00},             // ref3p_ratio_m
++	{X , 0x050A , 0x01},             // ref3p_ratio_m
++	{X , 0x050B , 0x00},             // ref3p_ratio_n
++	{X , 0x050C , 0x01},             // ref3p_ratio_n
++	{X , 0x050D , 0x00},             // ref3p_config
++	{X , 0x050E , 0x00},             // ref3p_clk_domain
++	{X , 0x050F , 0x05},             // ref3p_scm
++	{X , 0x0510 , 0x00},             // ref3p_scm_fine
++	{X , 0x0511 , 0x00},             // ref3p_scm_fine
++	{X , 0x0512 , 0x00},             // ref3p_scm_fine
++	{X , 0x0513 , 0x00},             // ref3p_scm_fine
++	{X , 0x0514 , 0x05},             // ref3p_cfm
++	{X , 0x0516 , 0x00},             // ref3p_gst_disqual
++	{X , 0x0517 , 0x05},             // ref3p_gst_disqual
++	{X , 0x0518 , 0x00},             // ref3p_gst_qual
++	{X , 0x0519 , 0x14},             // ref3p_gst_qual
++	{X , 0x051A , 0x01},             // ref3p_meas_freq_period
++	{X , 0x051B , 0x00},             // ref3p_pfm_ctrl
++	{X , 0x051C , 0xB3},             // ref3p_pfm_disqualify
++	{X , 0x051D , 0xB0},             // ref3p_pfm_disqualify
++	{X , 0x051E , 0x9C},             // ref3p_pfm_qualify
++	{X , 0x051F , 0x40},             // ref3p_pfm_qualify
++	{X , 0x0520 , 0x00},             // ref3p_pfm_period
++	{X , 0x0521 , 0x00},             // ref3p_pfm_period
++	{X , 0x0522 , 0x28},             // ref3p_pfm_filter_limit
++	{X , 0x0528 , 0x00},             // ref3p_phase_offset_compensation
++	{X , 0x0529 , 0x00},             // ref3p_phase_offset_compensation
++	{X , 0x052A , 0x00},             // ref3p_phase_offset_compensation
++	{X , 0x052B , 0x00},             // ref3p_phase_offset_compensation
++	{X , 0x052E , 0x00},             // ref3p_sync_ctrl
++	{X , 0x052F , 0x00},             // ref3p_sync_misc
++	{X , 0x0530 , 0x00},             // ref3p_esync_div
++	{X , 0x0531 , 0x00},             // ref3p_esync_div
++	{X , 0x0532 , 0x00},             // ref3p_esync_div
++	{X , 0x0533 , 0x00},             // ref3p_esync_div
++	{X , 0x0534 , 0x00},             // ref3p_gpi_select
++	{X , 0x0535 , 0x00},             // ref3p_gpi_select
++	{X , 0x0536 , 0x00},             // ref3p_gpi_config
++	{X , 0x0537 , 0x00},             // ref3p_esync_min_low_pulse
++	{X , 0x0538 , 0x00},             // ref3p_esync_min_hi_pulse
++	{X , 0x0539 , 0x00},             // ref3p_esync_max_low_pulse
++	{X , 0x053A , 0x00},             // ref3p_esync_max_hi_pulse
++	{X , 0x0504 , 0x01},             // ref_mb_sem
++	{W , 20000},
++
++	{X , 0x0502 , 0x00},             // ref_mb_mask
++	{X , 0x0503 , 0x80},             // ref_mb_mask
++	{X , 0x0504 , 0x02},             // ref_mb_sem
++	{W , 20000},
++	{X , 0x0505 , 0x61},             // ref3n_freq_base
++	{X , 0x0506 , 0xA8},             // ref3n_freq_base
++	{X , 0x0507 , 0x03},             // ref3n_freq_mult
++	{X , 0x0508 , 0xE8},             // ref3n_freq_mult
++	{X , 0x0509 , 0x00},             // ref3n_ratio_m
++	{X , 0x050A , 0x01},             // ref3n_ratio_m
++	{X , 0x050B , 0x00},             // ref3n_ratio_n
++	{X , 0x050C , 0x01},             // ref3n_ratio_n
++	{X , 0x050D , 0x00},             // ref3n_config
++	{X , 0x050E , 0x00},             // ref3n_clk_domain
++	{X , 0x050F , 0x05},             // ref3n_scm
++	{X , 0x0510 , 0x00},             // ref3n_scm_fine
++	{X , 0x0511 , 0x00},             // ref3n_scm_fine
++	{X , 0x0512 , 0x00},             // ref3n_scm_fine
++	{X , 0x0513 , 0x00},             // ref3n_scm_fine
++	{X , 0x0514 , 0x05},             // ref3n_cfm
++	{X , 0x0516 , 0x00},             // ref3n_gst_disqual
++	{X , 0x0517 , 0x05},             // ref3n_gst_disqual
++	{X , 0x0518 , 0x00},             // ref3n_gst_qual
++	{X , 0x0519 , 0x14},             // ref3n_gst_qual
++	{X , 0x051A , 0x01},             // ref3n_meas_freq_period
++	{X , 0x051B , 0x00},             // ref3n_pfm_ctrl
++	{X , 0x051C , 0xB3},             // ref3n_pfm_disqualify
++	{X , 0x051D , 0xB0},             // ref3n_pfm_disqualify
++	{X , 0x051E , 0x9C},             // ref3n_pfm_qualify
++	{X , 0x051F , 0x40},             // ref3n_pfm_qualify
++	{X , 0x0520 , 0x00},             // ref3n_pfm_period
++	{X , 0x0521 , 0x00},             // ref3n_pfm_period
++	{X , 0x0522 , 0x28},             // ref3n_pfm_filter_limit
++	{X , 0x0528 , 0x00},             // ref3n_phase_offset_compensation
++	{X , 0x0529 , 0x00},             // ref3n_phase_offset_compensation
++	{X , 0x052A , 0x00},             // ref3n_phase_offset_compensation
++	{X , 0x052B , 0x00},             // ref3n_phase_offset_compensation
++	{X , 0x052E , 0x00},             // ref3n_sync_ctrl
++	{X , 0x052F , 0x00},             // ref3n_sync_misc
++	{X , 0x0530 , 0x00},             // ref3n_esync_div
++	{X , 0x0531 , 0x00},             // ref3n_esync_div
++	{X , 0x0532 , 0x00},             // ref3n_esync_div
++	{X , 0x0533 , 0x00},             // ref3n_esync_div
++	{X , 0x0534 , 0x00},             // ref3n_gpi_select
++	{X , 0x0535 , 0x00},             // ref3n_gpi_select
++	{X , 0x0536 , 0x00},             // ref3n_gpi_config
++	{X , 0x0537 , 0x00},             // ref3n_esync_min_low_pulse
++	{X , 0x0538 , 0x00},             // ref3n_esync_min_hi_pulse
++	{X , 0x0539 , 0x00},             // ref3n_esync_max_low_pulse
++	{X , 0x053A , 0x00},             // ref3n_esync_max_hi_pulse
++	{X , 0x0504 , 0x01},             // ref_mb_sem
++	{W , 20000},
++
++	{X , 0x0502 , 0x01},             // ref_mb_mask
++	{X , 0x0503 , 0x00},             // ref_mb_mask
++	{X , 0x0504 , 0x02},             // ref_mb_sem
++	{W , 20000},
++	{X , 0x0505 , 0x61},             // ref4p_freq_base
++	{X , 0x0506 , 0xA8},             // ref4p_freq_base
++	{X , 0x0507 , 0x03},             // ref4p_freq_mult
++	{X , 0x0508 , 0xE8},             // ref4p_freq_mult
++	{X , 0x0509 , 0x00},             // ref4p_ratio_m
++	{X , 0x050A , 0x01},             // ref4p_ratio_m
++	{X , 0x050B , 0x00},             // ref4p_ratio_n
++	{X , 0x050C , 0x01},             // ref4p_ratio_n
++	{X , 0x050D , 0x00},             // ref4p_config
++	{X , 0x050E , 0x00},             // ref4p_clk_domain
++	{X , 0x050F , 0x05},             // ref4p_scm
++	{X , 0x0510 , 0x00},             // ref4p_scm_fine
++	{X , 0x0511 , 0x00},             // ref4p_scm_fine
++	{X , 0x0512 , 0x00},             // ref4p_scm_fine
++	{X , 0x0513 , 0x00},             // ref4p_scm_fine
++	{X , 0x0514 , 0x05},             // ref4p_cfm
++	{X , 0x0516 , 0x00},             // ref4p_gst_disqual
++	{X , 0x0517 , 0x05},             // ref4p_gst_disqual
++	{X , 0x0518 , 0x00},             // ref4p_gst_qual
++	{X , 0x0519 , 0x14},             // ref4p_gst_qual
++	{X , 0x051A , 0x01},             // ref4p_meas_freq_period
++	{X , 0x051B , 0x00},             // ref4p_pfm_ctrl
++	{X , 0x051C , 0xB3},             // ref4p_pfm_disqualify
++	{X , 0x051D , 0xB0},             // ref4p_pfm_disqualify
++	{X , 0x051E , 0x9C},             // ref4p_pfm_qualify
++	{X , 0x051F , 0x40},             // ref4p_pfm_qualify
++	{X , 0x0520 , 0x00},             // ref4p_pfm_period
++	{X , 0x0521 , 0x00},             // ref4p_pfm_period
++	{X , 0x0522 , 0x28},             // ref4p_pfm_filter_limit
++	{X , 0x0528 , 0x00},             // ref4p_phase_offset_compensation
++	{X , 0x0529 , 0x00},             // ref4p_phase_offset_compensation
++	{X , 0x052A , 0x00},             // ref4p_phase_offset_compensation
++	{X , 0x052B , 0x00},             // ref4p_phase_offset_compensation
++	{X , 0x052E , 0x00},             // ref4p_sync_ctrl
++	{X , 0x052F , 0x00},             // ref4p_sync_misc
++	{X , 0x0530 , 0x00},             // ref4p_esync_div
++	{X , 0x0531 , 0x00},             // ref4p_esync_div
++	{X , 0x0532 , 0x00},             // ref4p_esync_div
++	{X , 0x0533 , 0x00},             // ref4p_esync_div
++	{X , 0x0534 , 0x00},             // ref4p_gpi_select
++	{X , 0x0535 , 0x00},             // ref4p_gpi_select
++	{X , 0x0536 , 0x00},             // ref4p_gpi_config
++	{X , 0x0537 , 0x00},             // ref4p_esync_min_low_pulse
++	{X , 0x0538 , 0x00},             // ref4p_esync_min_hi_pulse
++	{X , 0x0539 , 0x00},             // ref4p_esync_max_low_pulse
++	{X , 0x053A , 0x00},             // ref4p_esync_max_hi_pulse
++	{X , 0x0504 , 0x01},             // ref_mb_sem
++	{W , 20000},
++
++	{X , 0x0502 , 0x02},             // ref_mb_mask
++	{X , 0x0503 , 0x00},             // ref_mb_mask
++	{X , 0x0504 , 0x02},             // ref_mb_sem
++	{W , 20000},
++	{X , 0x0505 , 0x61},             // ref4n_freq_base
++	{X , 0x0506 , 0xA8},             // ref4n_freq_base
++	{X , 0x0507 , 0x03},             // ref4n_freq_mult
++	{X , 0x0508 , 0xE8},             // ref4n_freq_mult
++	{X , 0x0509 , 0x00},             // ref4n_ratio_m
++	{X , 0x050A , 0x01},             // ref4n_ratio_m
++	{X , 0x050B , 0x00},             // ref4n_ratio_n
++	{X , 0x050C , 0x01},             // ref4n_ratio_n
++	{X , 0x050D , 0x00},             // ref4n_config
++	{X , 0x050E , 0x00},             // ref4n_clk_domain
++	{X , 0x050F , 0x05},             // ref4n_scm
++	{X , 0x0510 , 0x00},             // ref4n_scm_fine
++	{X , 0x0511 , 0x00},             // ref4n_scm_fine
++	{X , 0x0512 , 0x00},             // ref4n_scm_fine
++	{X , 0x0513 , 0x00},             // ref4n_scm_fine
++	{X , 0x0514 , 0x05},             // ref4n_cfm
++	{X , 0x0516 , 0x00},             // ref4n_gst_disqual
++	{X , 0x0517 , 0x05},             // ref4n_gst_disqual
++	{X , 0x0518 , 0x00},             // ref4n_gst_qual
++	{X , 0x0519 , 0x14},             // ref4n_gst_qual
++	{X , 0x051A , 0x01},             // ref4n_meas_freq_period
++	{X , 0x051B , 0x00},             // ref4n_pfm_ctrl
++	{X , 0x051C , 0xB3},             // ref4n_pfm_disqualify
++	{X , 0x051D , 0xB0},             // ref4n_pfm_disqualify
++	{X , 0x051E , 0x9C},             // ref4n_pfm_qualify
++	{X , 0x051F , 0x40},             // ref4n_pfm_qualify
++	{X , 0x0520 , 0x00},             // ref4n_pfm_period
++	{X , 0x0521 , 0x00},             // ref4n_pfm_period
++	{X , 0x0522 , 0x28},             // ref4n_pfm_filter_limit
++	{X , 0x0528 , 0x00},             // ref4n_phase_offset_compensation
++	{X , 0x0529 , 0x00},             // ref4n_phase_offset_compensation
++	{X , 0x052A , 0x00},             // ref4n_phase_offset_compensation
++	{X , 0x052B , 0x00},             // ref4n_phase_offset_compensation
++	{X , 0x052E , 0x00},             // ref4n_sync_ctrl
++	{X , 0x052F , 0x00},             // ref4n_sync_misc
++	{X , 0x0530 , 0x00},             // ref4n_esync_div
++	{X , 0x0531 , 0x00},             // ref4n_esync_div
++	{X , 0x0532 , 0x00},             // ref4n_esync_div
++	{X , 0x0533 , 0x00},             // ref4n_esync_div
++	{X , 0x0534 , 0x00},             // ref4n_gpi_select
++	{X , 0x0535 , 0x00},             // ref4n_gpi_select
++	{X , 0x0536 , 0x00},             // ref4n_gpi_config
++	{X , 0x0537 , 0x00},             // ref4n_esync_min_low_pulse
++	{X , 0x0538 , 0x00},             // ref4n_esync_min_hi_pulse
++	{X , 0x0539 , 0x00},             // ref4n_esync_max_low_pulse
++	{X , 0x053A , 0x00},             // ref4n_esync_max_hi_pulse
++	{X , 0x0504 , 0x01},             // ref_mb_sem
++	{W , 20000},
++
++	{X , 0x0602 , 0x00},             // dpll_mb_mask
++	{X , 0x0603 , 0x01},             // dpll_mb_mask
++	{X , 0x0604 , 0x02},             // dpll_mb_sem
++	{W , 20000},
++	{X , 0x0605 , 0x01},             // dpll0_config
++	{X , 0x0609 , 0x01},             // dpll0_fast_lock_ctrl
++	{X , 0x060A , 0x00},             // dpll0_fast_lock_target_time
++	{X , 0x060B , 0x00},             // dpll0_fast_lock_target_time
++	{X , 0x060C , 0x07},             // dpll0_fast_lock_phase_rate
++	{X , 0x060D , 0xD0},             // dpll0_fast_lock_phase_rate
++	{X , 0x060E , 0x00},             // dpll0_fast_lock_fcl
++	{X , 0x060F , 0x00},             // dpll0_fast_lock_fcl
++	{X , 0x0610 , 0x01},             // dpll0_fast_lock_phase_err
++	{X , 0x0611 , 0x00},             // dpll0_fast_lock_phase_err
++	{X , 0x0612 , 0x04},             // dpll0_fast_lock_freq_err
++	{X , 0x0620 , 0x07},             // dpll0_bw_fixed
++	{X , 0x0621 , 0x81},             // dpll0_bw_var
++	{X , 0x0622 , 0x1D},             // dpll0_psl
++	{X , 0x0623 , 0x4C},             // dpll0_psl
++	{X , 0x0626 , 0x00},             // dpll0_damping
++	{X , 0x0627 , 0x09},             // dpll0_duration_good
++	{X , 0x0628 , 0x00},             // dpll0_phase_good
++	{X , 0x0629 , 0x0F},             // dpll0_phase_good
++	{X , 0x062A , 0x42},             // dpll0_phase_good
++	{X , 0x062B , 0x40},             // dpll0_phase_good
++	{X , 0x062C , 0x00},             // dpll0_phase_bad
++	{X , 0x062D , 0x1E},             // dpll0_phase_bad
++	{X , 0x062E , 0x84},             // dpll0_phase_bad
++	{X , 0x062F , 0x80},             // dpll0_phase_bad
++	{X , 0x0638 , 0x77},             // dpll0_step_time_thresh
++	{X , 0x0639 , 0x35},             // dpll0_step_time_thresh
++	{X , 0x063A , 0x94},             // dpll0_step_time_thresh
++	{X , 0x063B , 0x00},             // dpll0_step_time_thresh
++	{X , 0x0640 , 0xEE},             // dpll0_step_time_reso
++	{X , 0x0641 , 0x6B},             // dpll0_step_time_reso
++	{X , 0x0642 , 0x28},             // dpll0_step_time_reso
++	{X , 0x0643 , 0x00},             // dpll0_step_time_reso
++	{X , 0x0644 , 0x00},             // dpll0_phase_align_speedup_thresh
++	{X , 0x0645 , 0x07},             // dpll0_range
++	{X , 0x0646 , 0xD0},             // dpll0_range
++	{X , 0x064D , 0x00},             // dpll0_tie_wr_thresh
++	{X , 0x064E , 0x02},             // dpll0_tie_wr_thresh
++	{X , 0x064F , 0x00},             // dpll0_lock_delay
++	{X , 0x0650 , 0x1E},             // dpll0_ref_sw_mask
++	{X , 0x0652 , 0x10},             // dpll0_ref_prio_0
++	{X , 0x0653 , 0x32},             // dpll0_ref_prio_1
++	{X , 0x0654 , 0x54},             // dpll0_ref_prio_2
++	{X , 0x0655 , 0x76},             // dpll0_ref_prio_3
++	{X , 0x0656 , 0x98},             // dpll0_ref_prio_4
++	{X , 0x0660 , 0x1E},             // dpll0_ref_ho_mask
++	{X , 0x0662 , 0x08},             // dpll0_ho_filter
++	{X , 0x0663 , 0x86},             // dpll0_ho_delay
++	{X , 0x0668 , 0x7F},             // dpll0_fp_first_realign
++	{X , 0x0669 , 0x80},             // dpll0_fp_realign_intvl
++	{X , 0x066A , 0x00},             // dpll0_fp_lock_thresh
++	{X , 0x066B , 0x00},             // dpll0_fp_lock_thresh
++	{X , 0x066C , 0xFF},             // dpll0_fp_sync_mask
++	{X , 0x0677 , 0x00},             // dpll0_clk_domain_color
++	{X , 0x0678 , 0x00},             // dpll0_clk_domain_name
++	{X , 0x0679 , 0x00},             // dpll0_clk_domain_name
++	{X , 0x067A , 0x00},             // dpll0_clk_domain_name
++	{X , 0x067B , 0x00},             // dpll0_clk_domain_name
++	{X , 0x067C , 0x00},             // dpll0_clk_domain_name
++	{X , 0x067D , 0x00},             // dpll0_clk_domain_name
++	{X , 0x0604 , 0x01},             // dpll_mb_sem
++	{W , 20000},
++
++	{X , 0x0602 , 0x00},             // dpll_mb_mask
++	{X , 0x0603 , 0x02},             // dpll_mb_mask
++	{X , 0x0604 , 0x02},             // dpll_mb_sem
++	{W , 20000},
++	{X , 0x0605 , 0x01},             // dpll1_config
++	{X , 0x0609 , 0x01},             // dpll1_fast_lock_ctrl
++	{X , 0x060A , 0x00},             // dpll1_fast_lock_target_time
++	{X , 0x060B , 0x00},             // dpll1_fast_lock_target_time
++	{X , 0x060C , 0x07},             // dpll1_fast_lock_phase_rate
++	{X , 0x060D , 0xD0},             // dpll1_fast_lock_phase_rate
++	{X , 0x060E , 0x00},             // dpll1_fast_lock_fcl
++	{X , 0x060F , 0x00},             // dpll1_fast_lock_fcl
++	{X , 0x0610 , 0x01},             // dpll1_fast_lock_phase_err
++	{X , 0x0611 , 0x00},             // dpll1_fast_lock_phase_err
++	{X , 0x0612 , 0x04},             // dpll1_fast_lock_freq_err
++	{X , 0x0620 , 0x07},             // dpll1_bw_fixed
++	{X , 0x0621 , 0x81},             // dpll1_bw_var
++	{X , 0x0622 , 0x1D},             // dpll1_psl
++	{X , 0x0623 , 0x4C},             // dpll1_psl
++	{X , 0x0626 , 0x00},             // dpll1_damping
++	{X , 0x0627 , 0x09},             // dpll1_duration_good
++	{X , 0x0628 , 0x02},             // dpll1_phase_good
++	{X , 0x0629 , 0x25},             // dpll1_phase_good
++	{X , 0x062A , 0x51},             // dpll1_phase_good
++	{X , 0x062B , 0x64},             // dpll1_phase_good
++	{X , 0x062C , 0x00},             // dpll1_phase_bad
++	{X , 0x062D , 0x1E},             // dpll1_phase_bad
++	{X , 0x062E , 0x84},             // dpll1_phase_bad
++	{X , 0x062F , 0x80},             // dpll1_phase_bad
++	{X , 0x0638 , 0x77},             // dpll1_step_time_thresh
++	{X , 0x0639 , 0x35},             // dpll1_step_time_thresh
++	{X , 0x063A , 0x94},             // dpll1_step_time_thresh
++	{X , 0x063B , 0x00},             // dpll1_step_time_thresh
++	{X , 0x0640 , 0xEE},             // dpll1_step_time_reso
++	{X , 0x0641 , 0x6B},             // dpll1_step_time_reso
++	{X , 0x0642 , 0x28},             // dpll1_step_time_reso
++	{X , 0x0643 , 0x00},             // dpll1_step_time_reso
++	{X , 0x0644 , 0x00},             // dpll1_phase_align_speedup_thresh
++	{X , 0x0645 , 0x0B},             // dpll1_range
++	{X , 0x0646 , 0xB8},             // dpll1_range
++	{X , 0x064D , 0x00},             // dpll1_tie_wr_thresh
++	{X , 0x064E , 0x02},             // dpll1_tie_wr_thresh
++	{X , 0x064F , 0x00},             // dpll1_lock_delay
++	{X , 0x0650 , 0x1E},             // dpll1_ref_sw_mask
++	{X , 0x0652 , 0x10},             // dpll1_ref_prio_0
++	{X , 0x0653 , 0x32},             // dpll1_ref_prio_1
++	{X , 0x0654 , 0x54},             // dpll1_ref_prio_2
++	{X , 0x0655 , 0x76},             // dpll1_ref_prio_3
++	{X , 0x0656 , 0x98},             // dpll1_ref_prio_4
++	{X , 0x0660 , 0x1E},             // dpll1_ref_ho_mask
++	{X , 0x0662 , 0x00},             // dpll1_ho_filter
++	{X , 0x0663 , 0x4C},             // dpll1_ho_delay
++	{X , 0x0668 , 0x7F},             // dpll1_fp_first_realign
++	{X , 0x0669 , 0x80},             // dpll1_fp_realign_intvl
++	{X , 0x066A , 0x00},             // dpll1_fp_lock_thresh
++	{X , 0x066B , 0x00},             // dpll1_fp_lock_thresh
++	{X , 0x066C , 0xFF},             // dpll1_fp_sync_mask
++	{X , 0x0677 , 0x00},             // dpll1_clk_domain_color
++	{X , 0x0678 , 0x00},             // dpll1_clk_domain_name
++	{X , 0x0679 , 0x00},             // dpll1_clk_domain_name
++	{X , 0x067A , 0x00},             // dpll1_clk_domain_name
++	{X , 0x067B , 0x00},             // dpll1_clk_domain_name
++	{X , 0x067C , 0x00},             // dpll1_clk_domain_name
++	{X , 0x067D , 0x00},             // dpll1_clk_domain_name
++	{X , 0x0604 , 0x01},             // dpll_mb_sem
++	{W , 20000},
++
++	{X , 0x0602 , 0x00},             // dpll_mb_mask
++	{X , 0x0603 , 0x04},             // dpll_mb_mask
++	{X , 0x0604 , 0x02},             // dpll_mb_sem
++	{W , 20000},
++	{X , 0x0605 , 0x01},             // dpll2_config
++	{X , 0x0609 , 0x01},             // dpll2_fast_lock_ctrl
++	{X , 0x060A , 0x00},             // dpll2_fast_lock_target_time
++	{X , 0x060B , 0x00},             // dpll2_fast_lock_target_time
++	{X , 0x060C , 0x07},             // dpll2_fast_lock_phase_rate
++	{X , 0x060D , 0xD0},             // dpll2_fast_lock_phase_rate
++	{X , 0x060E , 0x00},             // dpll2_fast_lock_fcl
++	{X , 0x060F , 0x00},             // dpll2_fast_lock_fcl
++	{X , 0x0610 , 0x01},             // dpll2_fast_lock_phase_err
++	{X , 0x0611 , 0x00},             // dpll2_fast_lock_phase_err
++	{X , 0x0612 , 0x04},             // dpll2_fast_lock_freq_err
++	{X , 0x0620 , 0x07},             // dpll2_bw_fixed
++	{X , 0x0621 , 0x00},             // dpll2_bw_var
++	{X , 0x0622 , 0x00},             // dpll2_psl
++	{X , 0x0623 , 0x00},             // dpll2_psl
++	{X , 0x0626 , 0x00},             // dpll2_damping
++	{X , 0x0627 , 0x09},             // dpll2_duration_good
++	{X , 0x0628 , 0x02},             // dpll2_phase_good
++	{X , 0x0629 , 0x25},             // dpll2_phase_good
++	{X , 0x062A , 0x51},             // dpll2_phase_good
++	{X , 0x062B , 0x00},             // dpll2_phase_good
++	{X , 0x062C , 0x02},             // dpll2_phase_bad
++	{X , 0x062D , 0x25},             // dpll2_phase_bad
++	{X , 0x062E , 0x51},             // dpll2_phase_bad
++	{X , 0x062F , 0x00},             // dpll2_phase_bad
++	{X , 0x0638 , 0x77},             // dpll2_step_time_thresh
++	{X , 0x0639 , 0x35},             // dpll2_step_time_thresh
++	{X , 0x063A , 0x94},             // dpll2_step_time_thresh
++	{X , 0x063B , 0x00},             // dpll2_step_time_thresh
++	{X , 0x0640 , 0xEE},             // dpll2_step_time_reso
++	{X , 0x0641 , 0x6B},             // dpll2_step_time_reso
++	{X , 0x0642 , 0x28},             // dpll2_step_time_reso
++	{X , 0x0643 , 0x00},             // dpll2_step_time_reso
++	{X , 0x0644 , 0x00},             // dpll2_phase_align_speedup_thresh
++	{X , 0x0645 , 0x0B},             // dpll2_range
++	{X , 0x0646 , 0xB8},             // dpll2_range
++	{X , 0x064D , 0x00},             // dpll2_tie_wr_thresh
++	{X , 0x064E , 0x02},             // dpll2_tie_wr_thresh
++	{X , 0x064F , 0x00},             // dpll2_lock_delay
++	{X , 0x0650 , 0x08},             // dpll2_ref_sw_mask
++	{X , 0x0652 , 0x10},             // dpll2_ref_prio_0
++	{X , 0x0653 , 0x32},             // dpll2_ref_prio_1
++	{X , 0x0654 , 0x54},             // dpll2_ref_prio_2
++	{X , 0x0655 , 0x76},             // dpll2_ref_prio_3
++	{X , 0x0656 , 0x98},             // dpll2_ref_prio_4
++	{X , 0x0660 , 0x17},             // dpll2_ref_ho_mask
++	{X , 0x0662 , 0x00},             // dpll2_ho_filter
++	{X , 0x0663 , 0x4C},             // dpll2_ho_delay
++	{X , 0x0668 , 0x7F},             // dpll2_fp_first_realign
++	{X , 0x0669 , 0x00},             // dpll2_fp_realign_intvl
++	{X , 0x066A , 0x00},             // dpll2_fp_lock_thresh
++	{X , 0x066B , 0x00},             // dpll2_fp_lock_thresh
++	{X , 0x066C , 0xFF},             // dpll2_fp_sync_mask
++	{X , 0x0677 , 0x00},             // dpll2_clk_domain_color
++	{X , 0x0678 , 0x00},             // dpll2_clk_domain_name
++	{X , 0x0679 , 0x00},             // dpll2_clk_domain_name
++	{X , 0x067A , 0x00},             // dpll2_clk_domain_name
++	{X , 0x067B , 0x00},             // dpll2_clk_domain_name
++	{X , 0x067C , 0x00},             // dpll2_clk_domain_name
++	{X , 0x067D , 0x00},             // dpll2_clk_domain_name
++	{X , 0x0604 , 0x01},             // dpll_mb_sem
++	{W , 20000},
++
++	{X , 0x0602 , 0x00},             // dpll_mb_mask
++	{X , 0x0603 , 0x20},             // dpll_mb_mask
++	{X , 0x0604 , 0x02},             // dpll_mb_sem
++	{W , 20000},
++	{X , 0x0605 , 0x01},             // dpll5_config
++	{X , 0x0609 , 0x01},             // dpll5_fast_lock_ctrl
++	{X , 0x060A , 0x00},             // dpll5_fast_lock_target_time
++	{X , 0x060B , 0x00},             // dpll5_fast_lock_target_time
++	{X , 0x060C , 0x07},             // dpll5_fast_lock_phase_rate
++	{X , 0x060D , 0xD0},             // dpll5_fast_lock_phase_rate
++	{X , 0x060E , 0x00},             // dpll5_fast_lock_fcl
++	{X , 0x060F , 0x00},             // dpll5_fast_lock_fcl
++	{X , 0x0610 , 0x01},             // dpll5_fast_lock_phase_err
++	{X , 0x0611 , 0x00},             // dpll5_fast_lock_phase_err
++	{X , 0x0612 , 0x04},             // dpll5_fast_lock_freq_err
++	{X , 0x0620 , 0x00},             // dpll5_bw_fixed
++	{X , 0x0621 , 0x00},             // dpll5_bw_var
++	{X , 0x0622 , 0x00},             // dpll5_psl
++	{X , 0x0623 , 0x00},             // dpll5_psl
++	{X , 0x0626 , 0x00},             // dpll5_damping
++	{X , 0x0627 , 0x09},             // dpll5_duration_good
++	{X , 0x0628 , 0x02},             // dpll5_phase_good
++	{X , 0x0629 , 0x25},             // dpll5_phase_good
++	{X , 0x062A , 0x51},             // dpll5_phase_good
++	{X , 0x062B , 0x00},             // dpll5_phase_good
++	{X , 0x062C , 0x02},             // dpll5_phase_bad
++	{X , 0x062D , 0x25},             // dpll5_phase_bad
++	{X , 0x062E , 0x51},             // dpll5_phase_bad
++	{X , 0x062F , 0x00},             // dpll5_phase_bad
++	{X , 0x0638 , 0x77},             // dpll5_step_time_thresh
++	{X , 0x0639 , 0x35},             // dpll5_step_time_thresh
++	{X , 0x063A , 0x94},             // dpll5_step_time_thresh
++	{X , 0x063B , 0x00},             // dpll5_step_time_thresh
++	{X , 0x0640 , 0xEE},             // dpll5_step_time_reso
++	{X , 0x0641 , 0x6B},             // dpll5_step_time_reso
++	{X , 0x0642 , 0x28},             // dpll5_step_time_reso
++	{X , 0x0643 , 0x00},             // dpll5_step_time_reso
++	{X , 0x0644 , 0x00},             // dpll5_phase_align_speedup_thresh
++	{X , 0x0645 , 0x0B},             // dpll5_range
++	{X , 0x0646 , 0xB8},             // dpll5_range
++	{X , 0x064D , 0x00},             // dpll5_tie_wr_thresh
++	{X , 0x064E , 0x02},             // dpll5_tie_wr_thresh
++	{X , 0x064F , 0x00},             // dpll5_lock_delay
++	{X , 0x0650 , 0x08},             // dpll5_ref_sw_mask
++	{X , 0x0652 , 0x10},             // dpll5_ref_prio_0
++	{X , 0x0653 , 0x32},             // dpll5_ref_prio_1
++	{X , 0x0654 , 0x54},             // dpll5_ref_prio_2
++	{X , 0x0655 , 0x76},             // dpll5_ref_prio_3
++	{X , 0x0656 , 0x98},             // dpll5_ref_prio_4
++	{X , 0x0660 , 0x17},             // dpll5_ref_ho_mask
++	{X , 0x0662 , 0x00},             // dpll5_ho_filter
++	{X , 0x0663 , 0x4C},             // dpll5_ho_delay
++	{X , 0x0668 , 0x7F},             // dpll5_fp_first_realign
++	{X , 0x0669 , 0x00},             // dpll5_fp_realign_intvl
++	{X , 0x066A , 0x00},             // dpll5_fp_lock_thresh
++	{X , 0x066B , 0x00},             // dpll5_fp_lock_thresh
++	{X , 0x066C , 0xFF},             // dpll5_fp_sync_mask
++	{X , 0x0677 , 0x00},             // dpll5_clk_domain_color
++	{X , 0x0678 , 0x00},             // dpll5_clk_domain_name
++	{X , 0x0679 , 0x00},             // dpll5_clk_domain_name
++	{X , 0x067A , 0x00},             // dpll5_clk_domain_name
++	{X , 0x067B , 0x00},             // dpll5_clk_domain_name
++	{X , 0x067C , 0x00},             // dpll5_clk_domain_name
++	{X , 0x067D , 0x00},             // dpll5_clk_domain_name
++	{X , 0x0604 , 0x01},             // dpll_mb_sem
++	{W , 20000},
++
++	{X , 0x0602 , 0x00},             // dpll_mb_mask
++	{X , 0x0603 , 0x40},             // dpll_mb_mask
++	{X , 0x0604 , 0x02},             // dpll_mb_sem
++	{W , 20000},
++	{X , 0x0605 , 0x01},             // dpll6_config
++	{X , 0x0609 , 0x01},             // dpll6_fast_lock_ctrl
++	{X , 0x060A , 0x00},             // dpll6_fast_lock_target_time
++	{X , 0x060B , 0x00},             // dpll6_fast_lock_target_time
++	{X , 0x060C , 0x07},             // dpll6_fast_lock_phase_rate
++	{X , 0x060D , 0xD0},             // dpll6_fast_lock_phase_rate
++	{X , 0x060E , 0x00},             // dpll6_fast_lock_fcl
++	{X , 0x060F , 0x00},             // dpll6_fast_lock_fcl
++	{X , 0x0610 , 0x01},             // dpll6_fast_lock_phase_err
++	{X , 0x0611 , 0x00},             // dpll6_fast_lock_phase_err
++	{X , 0x0612 , 0x04},             // dpll6_fast_lock_freq_err
++	{X , 0x0620 , 0x00},             // dpll6_bw_fixed
++	{X , 0x0621 , 0x00},             // dpll6_bw_var
++	{X , 0x0622 , 0x00},             // dpll6_psl
++	{X , 0x0623 , 0x00},             // dpll6_psl
++	{X , 0x0626 , 0x00},             // dpll6_damping
++	{X , 0x0627 , 0x09},             // dpll6_duration_good
++	{X , 0x0628 , 0x02},             // dpll6_phase_good
++	{X , 0x0629 , 0x25},             // dpll6_phase_good
++	{X , 0x062A , 0x51},             // dpll6_phase_good
++	{X , 0x062B , 0x00},             // dpll6_phase_good
++	{X , 0x062C , 0x02},             // dpll6_phase_bad
++	{X , 0x062D , 0x25},             // dpll6_phase_bad
++	{X , 0x062E , 0x51},             // dpll6_phase_bad
++	{X , 0x062F , 0x00},             // dpll6_phase_bad
++	{X , 0x0638 , 0x77},             // dpll6_step_time_thresh
++	{X , 0x0639 , 0x35},             // dpll6_step_time_thresh
++	{X , 0x063A , 0x94},             // dpll6_step_time_thresh
++	{X , 0x063B , 0x00},             // dpll6_step_time_thresh
++	{X , 0x0640 , 0xEE},             // dpll6_step_time_reso
++	{X , 0x0641 , 0x6B},             // dpll6_step_time_reso
++	{X , 0x0642 , 0x28},             // dpll6_step_time_reso
++	{X , 0x0643 , 0x00},             // dpll6_step_time_reso
++	{X , 0x0644 , 0x00},             // dpll6_phase_align_speedup_thresh
++	{X , 0x0645 , 0x0B},             // dpll6_range
++	{X , 0x0646 , 0xB8},             // dpll6_range
++	{X , 0x064D , 0x00},             // dpll6_tie_wr_thresh
++	{X , 0x064E , 0x02},             // dpll6_tie_wr_thresh
++	{X , 0x064F , 0x00},             // dpll6_lock_delay
++	{X , 0x0650 , 0x08},             // dpll6_ref_sw_mask
++	{X , 0x0652 , 0x10},             // dpll6_ref_prio_0
++	{X , 0x0653 , 0x32},             // dpll6_ref_prio_1
++	{X , 0x0654 , 0x54},             // dpll6_ref_prio_2
++	{X , 0x0655 , 0x76},             // dpll6_ref_prio_3
++	{X , 0x0656 , 0x98},             // dpll6_ref_prio_4
++	{X , 0x0660 , 0x17},             // dpll6_ref_ho_mask
++	{X , 0x0662 , 0x00},             // dpll6_ho_filter
++	{X , 0x0663 , 0x4C},             // dpll6_ho_delay
++	{X , 0x0668 , 0x7F},             // dpll6_fp_first_realign
++	{X , 0x0669 , 0x00},             // dpll6_fp_realign_intvl
++	{X , 0x066A , 0x00},             // dpll6_fp_lock_thresh
++	{X , 0x066B , 0x00},             // dpll6_fp_lock_thresh
++	{X , 0x066C , 0xFF},             // dpll6_fp_sync_mask
++	{X , 0x0677 , 0x00},             // dpll6_clk_domain_color
++	{X , 0x0678 , 0x00},             // dpll6_clk_domain_name
++	{X , 0x0679 , 0x00},             // dpll6_clk_domain_name
++	{X , 0x067A , 0x00},             // dpll6_clk_domain_name
++	{X , 0x067B , 0x00},             // dpll6_clk_domain_name
++	{X , 0x067C , 0x00},             // dpll6_clk_domain_name
++	{X , 0x067D , 0x00},             // dpll6_clk_domain_name
++	{X , 0x0604 , 0x01},             // dpll_mb_sem
++	{W , 20000},
++
++	{X , 0x0602 , 0x00},             // dpll_mb_mask
++	{X , 0x0603 , 0x80},             // dpll_mb_mask
++	{X , 0x0604 , 0x02},             // dpll_mb_sem
++	{W , 20000},
++	{X , 0x0605 , 0x01},             // dpll7_config
++	{X , 0x0609 , 0x01},             // dpll7_fast_lock_ctrl
++	{X , 0x060A , 0x00},             // dpll7_fast_lock_target_time
++	{X , 0x060B , 0x00},             // dpll7_fast_lock_target_time
++	{X , 0x060C , 0x07},             // dpll7_fast_lock_phase_rate
++	{X , 0x060D , 0xD0},             // dpll7_fast_lock_phase_rate
++	{X , 0x060E , 0x00},             // dpll7_fast_lock_fcl
++	{X , 0x060F , 0x00},             // dpll7_fast_lock_fcl
++	{X , 0x0610 , 0x01},             // dpll7_fast_lock_phase_err
++	{X , 0x0611 , 0x00},             // dpll7_fast_lock_phase_err
++	{X , 0x0612 , 0x04},             // dpll7_fast_lock_freq_err
++	{X , 0x0620 , 0x00},             // dpll7_bw_fixed
++	{X , 0x0621 , 0x00},             // dpll7_bw_var
++	{X , 0x0622 , 0x00},             // dpll7_psl
++	{X , 0x0623 , 0x00},             // dpll7_psl
++	{X , 0x0626 , 0x00},             // dpll7_damping
++	{X , 0x0627 , 0x09},             // dpll7_duration_good
++	{X , 0x0628 , 0x02},             // dpll7_phase_good
++	{X , 0x0629 , 0x25},             // dpll7_phase_good
++	{X , 0x062A , 0x51},             // dpll7_phase_good
++	{X , 0x062B , 0x00},             // dpll7_phase_good
++	{X , 0x062C , 0x02},             // dpll7_phase_bad
++	{X , 0x062D , 0x25},             // dpll7_phase_bad
++	{X , 0x062E , 0x51},             // dpll7_phase_bad
++	{X , 0x062F , 0x00},             // dpll7_phase_bad
++	{X , 0x0638 , 0x77},             // dpll7_step_time_thresh
++	{X , 0x0639 , 0x35},             // dpll7_step_time_thresh
++	{X , 0x063A , 0x94},             // dpll7_step_time_thresh
++	{X , 0x063B , 0x00},             // dpll7_step_time_thresh
++	{X , 0x0640 , 0xEE},             // dpll7_step_time_reso
++	{X , 0x0641 , 0x6B},             // dpll7_step_time_reso
++	{X , 0x0642 , 0x28},             // dpll7_step_time_reso
++	{X , 0x0643 , 0x00},             // dpll7_step_time_reso
++	{X , 0x0644 , 0x00},             // dpll7_phase_align_speedup_thresh
++	{X , 0x0645 , 0x0B},             // dpll7_range
++	{X , 0x0646 , 0xB8},             // dpll7_range
++	{X , 0x064D , 0x00},             // dpll7_tie_wr_thresh
++	{X , 0x064E , 0x02},             // dpll7_tie_wr_thresh
++	{X , 0x064F , 0x00},             // dpll7_lock_delay
++	{X , 0x0650 , 0x08},             // dpll7_ref_sw_mask
++	{X , 0x0652 , 0x10},             // dpll7_ref_prio_0
++	{X , 0x0653 , 0x32},             // dpll7_ref_prio_1
++	{X , 0x0654 , 0x54},             // dpll7_ref_prio_2
++	{X , 0x0655 , 0x76},             // dpll7_ref_prio_3
++	{X , 0x0656 , 0x98},             // dpll7_ref_prio_4
++	{X , 0x0660 , 0x17},             // dpll7_ref_ho_mask
++	{X , 0x0662 , 0x00},             // dpll7_ho_filter
++	{X , 0x0663 , 0x4C},             // dpll7_ho_delay
++	{X , 0x0668 , 0x7F},             // dpll7_fp_first_realign
++	{X , 0x0669 , 0x00},             // dpll7_fp_realign_intvl
++	{X , 0x066A , 0x00},             // dpll7_fp_lock_thresh
++	{X , 0x066B , 0x00},             // dpll7_fp_lock_thresh
++	{X , 0x066C , 0xFF},             // dpll7_fp_sync_mask
++	{X , 0x0677 , 0x00},             // dpll7_clk_domain_color
++	{X , 0x0678 , 0x00},             // dpll7_clk_domain_name
++	{X , 0x0679 , 0x00},             // dpll7_clk_domain_name
++	{X , 0x067A , 0x00},             // dpll7_clk_domain_name
++	{X , 0x067B , 0x00},             // dpll7_clk_domain_name
++	{X , 0x067C , 0x00},             // dpll7_clk_domain_name
++	{X , 0x067D , 0x00},             // dpll7_clk_domain_name
++	{X , 0x0604 , 0x01},             // dpll_mb_sem
++	{W , 20000},
++
++	{X , 0x0682 , 0x00},             // synth_mb_mask
++	{X , 0x0683 , 0x01},             // synth_mb_mask
++	{X , 0x0684 , 0x02},             // synth_mb_sem
++	{W , 20000},
++	{X , 0x0686 , 0x00},             // synth0_freq_base
++	{X , 0x0687 , 0x01},             // synth0_freq_base
++	{X , 0x0688 , 0x10},             // synth0_freq_mult
++	{X , 0x0689 , 0x17},             // synth0_freq_mult
++	{X , 0x068A , 0xDF},             // synth0_freq_mult
++	{X , 0x068B , 0x80},             // synth0_freq_mult
++	{X , 0x068C , 0x00},             // synth0_freq_m
++	{X , 0x068D , 0x01},             // synth0_freq_m
++	{X , 0x068E , 0x00},             // synth0_freq_n
++	{X , 0x068F , 0x01},             // synth0_freq_n
++	{X , 0x0690 , 0x00},             // synth0_phase_compensation
++	{X , 0x0691 , 0x00},             // synth0_phase_compensation
++	{X , 0x0692 , 0x00},             // synth0_align_compensation
++	{X , 0x0694 , 0x00},             // synth0_spread_spectrum_cfg
++	{X , 0x0695 , 0x00},             // synth0_spread_spectrum_rate
++	{X , 0x0696 , 0x00},             // synth0_spread_spectrum_rate
++	{X , 0x0697 , 0x00},             // synth0_spread_spectrum_spread
++	{X , 0x0684 , 0x01},             // synth_mb_sem
++	{W , 20000},
++
++	{X , 0x0682 , 0x00},             // synth_mb_mask
++	{X , 0x0683 , 0x02},             // synth_mb_mask
++	{X , 0x0684 , 0x02},             // synth_mb_sem
++	{W , 20000},
++	{X , 0x0686 , 0x00},             // synth1_freq_base
++	{X , 0x0687 , 0x01},             // synth1_freq_base
++	{X , 0x0688 , 0x1D},             // synth1_freq_mult
++	{X , 0x0689 , 0xCD},             // synth1_freq_mult
++	{X , 0x068A , 0x65},             // synth1_freq_mult
++	{X , 0x068B , 0x00},             // synth1_freq_mult
++	{X , 0x068C , 0x00},             // synth1_freq_m
++	{X , 0x068D , 0x01},             // synth1_freq_m
++	{X , 0x068E , 0x00},             // synth1_freq_n
++	{X , 0x068F , 0x01},             // synth1_freq_n
++	{X , 0x0690 , 0x00},             // synth1_phase_compensation
++	{X , 0x0691 , 0x00},             // synth1_phase_compensation
++	{X , 0x0692 , 0x00},             // synth1_align_compensation
++	{X , 0x0694 , 0x00},             // synth1_spread_spectrum_cfg
++	{X , 0x0695 , 0x00},             // synth1_spread_spectrum_rate
++	{X , 0x0696 , 0x00},             // synth1_spread_spectrum_rate
++	{X , 0x0697 , 0x00},             // synth1_spread_spectrum_spread
++	{X , 0x0684 , 0x01},             // synth_mb_sem
++	{W , 20000},
++
++	{X , 0x0682 , 0x00},             // synth_mb_mask
++	{X , 0x0683 , 0x04},             // synth_mb_mask
++	{X , 0x0684 , 0x02},             // synth_mb_sem
++	{W , 20000},
++	{X , 0x0686 , 0x00},             // synth2_freq_base
++	{X , 0x0687 , 0x01},             // synth2_freq_base
++	{X , 0x0688 , 0x0C},             // synth2_freq_mult
++	{X , 0x0689 , 0x65},             // synth2_freq_mult
++	{X , 0x068A , 0xD4},             // synth2_freq_mult
++	{X , 0x068B , 0x00},             // synth2_freq_mult
++	{X , 0x068C , 0x00},             // synth2_freq_m
++	{X , 0x068D , 0x01},             // synth2_freq_m
++	{X , 0x068E , 0x00},             // synth2_freq_n
++	{X , 0x068F , 0x01},             // synth2_freq_n
++	{X , 0x0690 , 0x00},             // synth2_phase_compensation
++	{X , 0x0691 , 0x00},             // synth2_phase_compensation
++	{X , 0x0692 , 0x00},             // synth2_align_compensation
++	{X , 0x0694 , 0x00},             // synth2_spread_spectrum_cfg
++	{X , 0x0695 , 0x00},             // synth2_spread_spectrum_rate
++	{X , 0x0696 , 0x00},             // synth2_spread_spectrum_rate
++	{X , 0x0697 , 0x00},             // synth2_spread_spectrum_spread
++	{X , 0x0684 , 0x01},             // synth_mb_sem
++	{W , 20000},
++
++	{X , 0x0682 , 0x00},             // synth_mb_mask
++	{X , 0x0683 , 0x08},             // synth_mb_mask
++	{X , 0x0684 , 0x02},             // synth_mb_sem
++	{W , 20000},
++	{X , 0x0686 , 0x00},             // synth3_freq_base
++	{X , 0x0687 , 0x01},             // synth3_freq_base
++	{X , 0x0688 , 0x23},             // synth3_freq_mult
++	{X , 0x0689 , 0xC3},             // synth3_freq_mult
++	{X , 0x068A , 0x46},             // synth3_freq_mult
++	{X , 0x068B , 0x00},             // synth3_freq_mult
++	{X , 0x068C , 0x00},             // synth3_freq_m
++	{X , 0x068D , 0x01},             // synth3_freq_m
++	{X , 0x068E , 0x00},             // synth3_freq_n
++	{X , 0x068F , 0x01},             // synth3_freq_n
++	{X , 0x0690 , 0x00},             // synth3_phase_compensation
++	{X , 0x0691 , 0x00},             // synth3_phase_compensation
++	{X , 0x0692 , 0x00},             // synth3_align_compensation
++	{X , 0x0694 , 0x00},             // synth3_spread_spectrum_cfg
++	{X , 0x0695 , 0x00},             // synth3_spread_spectrum_rate
++	{X , 0x0696 , 0x00},             // synth3_spread_spectrum_rate
++	{X , 0x0697 , 0x00},             // synth3_spread_spectrum_spread
++	{X , 0x0684 , 0x01},             // synth_mb_sem
++	{W , 20000},
++
++	{X , 0x0682 , 0x00},             // synth_mb_mask
++	{X , 0x0683 , 0x10},             // synth_mb_mask
++	{X , 0x0684 , 0x02},             // synth_mb_sem
++	{W , 20000},
++	{X , 0x0686 , 0x00},             // synth4_freq_base
++	{X , 0x0687 , 0x01},             // synth4_freq_base
++	{X , 0x0688 , 0x23},             // synth4_freq_mult
++	{X , 0x0689 , 0x67},             // synth4_freq_mult
++	{X , 0x068A , 0xB8},             // synth4_freq_mult
++	{X , 0x068B , 0x80},             // synth4_freq_mult
++	{X , 0x068C , 0x00},             // synth4_freq_m
++	{X , 0x068D , 0x01},             // synth4_freq_m
++	{X , 0x068E , 0x00},             // synth4_freq_n
++	{X , 0x068F , 0x01},             // synth4_freq_n
++	{X , 0x0690 , 0x00},             // synth4_phase_compensation
++	{X , 0x0691 , 0x00},             // synth4_phase_compensation
++	{X , 0x0692 , 0x00},             // synth4_align_compensation
++	{X , 0x0694 , 0x00},             // synth4_spread_spectrum_cfg
++	{X , 0x0695 , 0x00},             // synth4_spread_spectrum_rate
++	{X , 0x0696 , 0x00},             // synth4_spread_spectrum_rate
++	{X , 0x0697 , 0x00},             // synth4_spread_spectrum_spread
++	{X , 0x0684 , 0x01},             // synth_mb_sem
++	{W , 20000},
++
++	{X , 0x0702 , 0x00},             // output_mb_mask
++	{X , 0x0703 , 0x01},             // output_mb_mask
++	{X , 0x0704 , 0x02},             // output_mb_sem
++	{W , 20000},
++	{X , 0x0705 , 0x20},             // output0_mode
++	{X , 0x0706 , 0x52},             // output0_driver_level
++	{X , 0x0707 , 0x01},             // output0_driver_config
++	{X , 0x0708 , 0x00},             // output0_driver_config
++	{X , 0x070C , 0x00},             // output0_div
++	{X , 0x070D , 0x00},             // output0_div
++	{X , 0x070E , 0x00},             // output0_div
++	{X , 0x070F , 0x04},             // output0_div
++	{X , 0x0710 , 0x00},             // output0_width
++	{X , 0x0711 , 0x00},             // output0_width
++	{X , 0x0712 , 0x00},             // output0_width
++	{X , 0x0713 , 0x04},             // output0_width
++	{X , 0x0714 , 0x00},             // output0_esync_period
++	{X , 0x0715 , 0x00},             // output0_esync_period
++	{X , 0x0716 , 0x00},             // output0_esync_period
++	{X , 0x0717 , 0x02},             // output0_esync_period
++	{X , 0x0718 , 0x00},             // output0_esync_width
++	{X , 0x0719 , 0x00},             // output0_esync_width
++	{X , 0x071A , 0x00},             // output0_esync_width
++	{X , 0x071B , 0x02},             // output0_esync_width
++	{X , 0x0720 , 0x00},             // output0_phase_compensation
++	{X , 0x0721 , 0x00},             // output0_phase_compensation
++	{X , 0x0722 , 0x00},             // output0_phase_compensation
++	{X , 0x0723 , 0x00},             // output0_phase_compensation
++	{X , 0x0724 , 0x00},             // output0_gpo_en
++	{X , 0x0725 , 0x00},             // output0_gpo_select_out_p
++	{X , 0x0726 , 0x00},             // output0_gpo_select_out_p
++	{X , 0x0727 , 0x01},             // output0_gpo_config_out_p
++	{X , 0x0728 , 0x00},             // output0_gpo_select_out_n
++	{X , 0x0729 , 0x00},             // output0_gpo_select_out_n
++	{X , 0x072A , 0x01},             // output0_gpo_config_out_n
++	{X , 0x0704 , 0x01},             // output_mb_sem
++	{W , 20000},
++
++	{X , 0x0702 , 0x00},             // output_mb_mask
++	{X , 0x0703 , 0x02},             // output_mb_mask
++	{X , 0x0704 , 0x02},             // output_mb_sem
++	{W , 20000},
++	{X , 0x0705 , 0x50},             // output1_mode
++	{X , 0x0706 , 0x5E},             // output1_driver_level
++	{X , 0x0707 , 0x00},             // output1_driver_config
++	{X , 0x0708 , 0x00},             // output1_driver_config
++	{X , 0x070C , 0x00},             // output1_div
++	{X , 0x070D , 0x00},             // output1_div
++	{X , 0x070E , 0x00},             // output1_div
++	{X , 0x070F , 0x3C},             // output1_div
++	{X , 0x0710 , 0x00},             // output1_width
++	{X , 0x0711 , 0x00},             // output1_width
++	{X , 0x0712 , 0x00},             // output1_width
++	{X , 0x0713 , 0x3C},             // output1_width
++	{X , 0x0714 , 0x00},             // output1_esync_period
++	{X , 0x0715 , 0x00},             // output1_esync_period
++	{X , 0x0716 , 0x00},             // output1_esync_period
++	{X , 0x0717 , 0x02},             // output1_esync_period
++	{X , 0x0718 , 0x00},             // output1_esync_width
++	{X , 0x0719 , 0x00},             // output1_esync_width
++	{X , 0x071A , 0x00},             // output1_esync_width
++	{X , 0x071B , 0x02},             // output1_esync_width
++	{X , 0x0720 , 0x00},             // output1_phase_compensation
++	{X , 0x0721 , 0x00},             // output1_phase_compensation
++	{X , 0x0722 , 0x00},             // output1_phase_compensation
++	{X , 0x0723 , 0x00},             // output1_phase_compensation
++	{X , 0x0724 , 0x00},             // output1_gpo_en
++	{X , 0x0725 , 0x00},             // output1_gpo_select_out_p
++	{X , 0x0726 , 0x00},             // output1_gpo_select_out_p
++	{X , 0x0727 , 0x01},             // output1_gpo_config_out_p
++	{X , 0x0728 , 0x00},             // output1_gpo_select_out_n
++	{X , 0x0729 , 0x00},             // output1_gpo_select_out_n
++	{X , 0x072A , 0x01},             // output1_gpo_config_out_n
++	{X , 0x0704 , 0x01},             // output_mb_sem
++	{W , 20000},
++
++	{X , 0x0702 , 0x00},             // output_mb_mask
++	{X , 0x0703 , 0x04},             // output_mb_mask
++	{X , 0x0704 , 0x02},             // output_mb_sem
++	{W , 20000},
++	{X , 0x0705 , 0x20},             // output2_mode
++	{X , 0x0706 , 0x52},             // output2_driver_level
++	{X , 0x0707 , 0x01},             // output2_driver_config
++	{X , 0x0708 , 0x00},             // output2_driver_config
++	{X , 0x070C , 0x00},             // output2_div
++	{X , 0x070D , 0x00},             // output2_div
++	{X , 0x070E , 0x00},             // output2_div
++	{X , 0x070F , 0x06},             // output2_div
++	{X , 0x0710 , 0x00},             // output2_width
++	{X , 0x0711 , 0x00},             // output2_width
++	{X , 0x0712 , 0x00},             // output2_width
++	{X , 0x0713 , 0x06},             // output2_width
++	{X , 0x0714 , 0x00},             // output2_esync_period
++	{X , 0x0715 , 0x00},             // output2_esync_period
++	{X , 0x0716 , 0x00},             // output2_esync_period
++	{X , 0x0717 , 0x02},             // output2_esync_period
++	{X , 0x0718 , 0x00},             // output2_esync_width
++	{X , 0x0719 , 0x00},             // output2_esync_width
++	{X , 0x071A , 0x00},             // output2_esync_width
++	{X , 0x071B , 0x02},             // output2_esync_width
++	{X , 0x0720 , 0x00},             // output2_phase_compensation
++	{X , 0x0721 , 0x00},             // output2_phase_compensation
++	{X , 0x0722 , 0x00},             // output2_phase_compensation
++	{X , 0x0723 , 0x00},             // output2_phase_compensation
++	{X , 0x0724 , 0x00},             // output2_gpo_en
++	{X , 0x0725 , 0x00},             // output2_gpo_select_out_p
++	{X , 0x0726 , 0x00},             // output2_gpo_select_out_p
++	{X , 0x0727 , 0x01},             // output2_gpo_config_out_p
++	{X , 0x0728 , 0x00},             // output2_gpo_select_out_n
++	{X , 0x0729 , 0x00},             // output2_gpo_select_out_n
++	{X , 0x072A , 0x01},             // output2_gpo_config_out_n
++	{X , 0x0704 , 0x01},             // output_mb_sem
++	{W , 20000},
++
++	{X , 0x0702 , 0x00},             // output_mb_mask
++	{X , 0x0703 , 0x08},             // output_mb_mask
++	{X , 0x0704 , 0x02},             // output_mb_sem
++	{W , 20000},
++	{X , 0x0705 , 0x20},             // output3_mode
++	{X , 0x0706 , 0x52},             // output3_driver_level
++	{X , 0x0707 , 0x01},             // output3_driver_config
++	{X , 0x0708 , 0x00},             // output3_driver_config
++	{X , 0x070C , 0x00},             // output3_div
++	{X , 0x070D , 0x00},             // output3_div
++	{X , 0x070E , 0x00},             // output3_div
++	{X , 0x070F , 0x06},             // output3_div
++	{X , 0x0710 , 0x00},             // output3_width
++	{X , 0x0711 , 0x00},             // output3_width
++	{X , 0x0712 , 0x00},             // output3_width
++	{X , 0x0713 , 0x06},             // output3_width
++	{X , 0x0714 , 0x00},             // output3_esync_period
++	{X , 0x0715 , 0x00},             // output3_esync_period
++	{X , 0x0716 , 0x00},             // output3_esync_period
++	{X , 0x0717 , 0x02},             // output3_esync_period
++	{X , 0x0718 , 0x00},             // output3_esync_width
++	{X , 0x0719 , 0x00},             // output3_esync_width
++	{X , 0x071A , 0x00},             // output3_esync_width
++	{X , 0x071B , 0x02},             // output3_esync_width
++	{X , 0x0720 , 0x00},             // output3_phase_compensation
++	{X , 0x0721 , 0x00},             // output3_phase_compensation
++	{X , 0x0722 , 0x00},             // output3_phase_compensation
++	{X , 0x0723 , 0x00},             // output3_phase_compensation
++	{X , 0x0724 , 0x00},             // output3_gpo_en
++	{X , 0x0725 , 0x00},             // output3_gpo_select_out_p
++	{X , 0x0726 , 0x00},             // output3_gpo_select_out_p
++	{X , 0x0727 , 0x01},             // output3_gpo_config_out_p
++	{X , 0x0728 , 0x00},             // output3_gpo_select_out_n
++	{X , 0x0729 , 0x00},             // output3_gpo_select_out_n
++	{X , 0x072A , 0x01},             // output3_gpo_config_out_n
++	{X , 0x0704 , 0x01},             // output_mb_sem
++	{W , 20000},
++
++	{X , 0x0702 , 0x00},             // output_mb_mask
++	{X , 0x0703 , 0x10},             // output_mb_mask
++	{X , 0x0704 , 0x02},             // output_mb_sem
++	{W , 20000},
++	{X , 0x0705 , 0x20},             // output4_mode
++	{X , 0x0706 , 0x52},             // output4_driver_level
++	{X , 0x0707 , 0x01},             // output4_driver_config
++	{X , 0x0708 , 0x00},             // output4_driver_config
++	{X , 0x070C , 0x00},             // output4_div
++	{X , 0x070D , 0x00},             // output4_div
++	{X , 0x070E , 0x00},             // output4_div
++	{X , 0x070F , 0x06},             // output4_div
++	{X , 0x0710 , 0x00},             // output4_width
++	{X , 0x0711 , 0x00},             // output4_width
++	{X , 0x0712 , 0x00},             // output4_width
++	{X , 0x0713 , 0x06},             // output4_width
++	{X , 0x0714 , 0x00},             // output4_esync_period
++	{X , 0x0715 , 0x00},             // output4_esync_period
++	{X , 0x0716 , 0x00},             // output4_esync_period
++	{X , 0x0717 , 0x02},             // output4_esync_period
++	{X , 0x0718 , 0x00},             // output4_esync_width
++	{X , 0x0719 , 0x00},             // output4_esync_width
++	{X , 0x071A , 0x00},             // output4_esync_width
++	{X , 0x071B , 0x02},             // output4_esync_width
++	{X , 0x0720 , 0x00},             // output4_phase_compensation
++	{X , 0x0721 , 0x00},             // output4_phase_compensation
++	{X , 0x0722 , 0x00},             // output4_phase_compensation
++	{X , 0x0723 , 0x00},             // output4_phase_compensation
++	{X , 0x0724 , 0x00},             // output4_gpo_en
++	{X , 0x0725 , 0x00},             // output4_gpo_select_out_p
++	{X , 0x0726 , 0x00},             // output4_gpo_select_out_p
++	{X , 0x0727 , 0x01},             // output4_gpo_config_out_p
++	{X , 0x0728 , 0x00},             // output4_gpo_select_out_n
++	{X , 0x0729 , 0x00},             // output4_gpo_select_out_n
++	{X , 0x072A , 0x01},             // output4_gpo_config_out_n
++	{X , 0x0704 , 0x01},             // output_mb_sem
++	{W , 20000},
++
++	{X , 0x0702 , 0x00},             // output_mb_mask
++	{X , 0x0703 , 0x20},             // output_mb_mask
++	{X , 0x0704 , 0x02},             // output_mb_sem
++	{W , 20000},
++	{X , 0x0705 , 0x20},             // output5_mode
++	{X , 0x0706 , 0x52},             // output5_driver_level
++	{X , 0x0707 , 0x01},             // output5_driver_config
++	{X , 0x0708 , 0x00},             // output5_driver_config
++	{X , 0x070C , 0x00},             // output5_div
++	{X , 0x070D , 0x00},             // output5_div
++	{X , 0x070E , 0x00},             // output5_div
++	{X , 0x070F , 0x18},             // output5_div
++	{X , 0x0710 , 0x00},             // output5_width
++	{X , 0x0711 , 0x00},             // output5_width
++	{X , 0x0712 , 0x00},             // output5_width
++	{X , 0x0713 , 0x18},             // output5_width
++	{X , 0x0714 , 0x00},             // output5_esync_period
++	{X , 0x0715 , 0x00},             // output5_esync_period
++	{X , 0x0716 , 0x00},             // output5_esync_period
++	{X , 0x0717 , 0x02},             // output5_esync_period
++	{X , 0x0718 , 0x00},             // output5_esync_width
++	{X , 0x0719 , 0x00},             // output5_esync_width
++	{X , 0x071A , 0x00},             // output5_esync_width
++	{X , 0x071B , 0x02},             // output5_esync_width
++	{X , 0x0720 , 0x00},             // output5_phase_compensation
++	{X , 0x0721 , 0x00},             // output5_phase_compensation
++	{X , 0x0722 , 0x00},             // output5_phase_compensation
++	{X , 0x0723 , 0x00},             // output5_phase_compensation
++	{X , 0x0724 , 0x00},             // output5_gpo_en
++	{X , 0x0725 , 0x00},             // output5_gpo_select_out_p
++	{X , 0x0726 , 0x00},             // output5_gpo_select_out_p
++	{X , 0x0727 , 0x01},             // output5_gpo_config_out_p
++	{X , 0x0728 , 0x00},             // output5_gpo_select_out_n
++	{X , 0x0729 , 0x00},             // output5_gpo_select_out_n
++	{X , 0x072A , 0x01},             // output5_gpo_config_out_n
++	{X , 0x0704 , 0x01},             // output_mb_sem
++	{W , 20000},
++
++	{X , 0x0702 , 0x00},             // output_mb_mask
++	{X , 0x0703 , 0x40},             // output_mb_mask
++	{X , 0x0704 , 0x02},             // output_mb_sem
++	{W , 20000},
++	{X , 0x0705 , 0xC0},             // output6_mode
++	{X , 0x0706 , 0x5A},             // output6_driver_level
++	{X , 0x0707 , 0x00},             // output6_driver_config
++	{X , 0x0708 , 0x00},             // output6_driver_config
++	{X , 0x070C , 0x00},             // output6_div
++	{X , 0x070D , 0x00},             // output6_div
++	{X , 0x070E , 0x00},             // output6_div
++	{X , 0x070F , 0x18},             // output6_div
++	{X , 0x0710 , 0x00},             // output6_width
++	{X , 0x0711 , 0x00},             // output6_width
++	{X , 0x0712 , 0x00},             // output6_width
++	{X , 0x0713 , 0x18},             // output6_width
++	{X , 0x0714 , 0x01},             // output6_esync_period
++	{X , 0x0715 , 0x7D},             // output6_esync_period
++	{X , 0x0716 , 0x78},             // output6_esync_period
++	{X , 0x0717 , 0x40},             // output6_esync_period
++	{X , 0x0718 , 0x01},             // output6_esync_width
++	{X , 0x0719 , 0x7D},             // output6_esync_width
++	{X , 0x071A , 0x78},             // output6_esync_width
++	{X , 0x071B , 0x40},             // output6_esync_width
++	{X , 0x0720 , 0x00},             // output6_phase_compensation
++	{X , 0x0721 , 0x00},             // output6_phase_compensation
++	{X , 0x0722 , 0x00},             // output6_phase_compensation
++	{X , 0x0723 , 0x00},             // output6_phase_compensation
++	{X , 0x0724 , 0x00},             // output6_gpo_en
++	{X , 0x0725 , 0x00},             // output6_gpo_select_out_p
++	{X , 0x0726 , 0x00},             // output6_gpo_select_out_p
++	{X , 0x0727 , 0x01},             // output6_gpo_config_out_p
++	{X , 0x0728 , 0x00},             // output6_gpo_select_out_n
++	{X , 0x0729 , 0x00},             // output6_gpo_select_out_n
++	{X , 0x072A , 0x01},             // output6_gpo_config_out_n
++	{X , 0x0704 , 0x01},             // output_mb_sem
++	{W , 20000},
++
++	{X , 0x0702 , 0x00},             // output_mb_mask
++	{X , 0x0703 , 0x80},             // output_mb_mask
++	{X , 0x0704 , 0x02},             // output_mb_sem
++	{W , 20000},
++	{X , 0x0705 , 0x20},             // output7_mode
++	{X , 0x0706 , 0x52},             // output7_driver_level
++	{X , 0x0707 , 0x01},             // output7_driver_config
++	{X , 0x0708 , 0x00},             // output7_driver_config
++	{X , 0x070C , 0x00},             // output7_div
++	{X , 0x070D , 0x00},             // output7_div
++	{X , 0x070E , 0x00},             // output7_div
++	{X , 0x070F , 0x0A},             // output7_div
++	{X , 0x0710 , 0x00},             // output7_width
++	{X , 0x0711 , 0x00},             // output7_width
++	{X , 0x0712 , 0x00},             // output7_width
++	{X , 0x0713 , 0x0A},             // output7_width
++	{X , 0x0714 , 0x00},             // output7_esync_period
++	{X , 0x0715 , 0x00},             // output7_esync_period
++	{X , 0x0716 , 0x00},             // output7_esync_period
++	{X , 0x0717 , 0x02},             // output7_esync_period
++	{X , 0x0718 , 0x00},             // output7_esync_width
++	{X , 0x0719 , 0x00},             // output7_esync_width
++	{X , 0x071A , 0x00},             // output7_esync_width
++	{X , 0x071B , 0x02},             // output7_esync_width
++	{X , 0x0720 , 0x00},             // output7_phase_compensation
++	{X , 0x0721 , 0x00},             // output7_phase_compensation
++	{X , 0x0722 , 0x00},             // output7_phase_compensation
++	{X , 0x0723 , 0x00},             // output7_phase_compensation
++	{X , 0x0724 , 0x00},             // output7_gpo_en
++	{X , 0x0725 , 0x00},             // output7_gpo_select_out_p
++	{X , 0x0726 , 0x00},             // output7_gpo_select_out_p
++	{X , 0x0727 , 0x01},             // output7_gpo_config_out_p
++	{X , 0x0728 , 0x00},             // output7_gpo_select_out_n
++	{X , 0x0729 , 0x00},             // output7_gpo_select_out_n
++	{X , 0x072A , 0x01},             // output7_gpo_config_out_n
++	{X , 0x0704 , 0x01},             // output_mb_sem
++	{W , 20000},
++
++	{X , 0x0702 , 0x01},             // output_mb_mask
++	{X , 0x0703 , 0x00},             // output_mb_mask
++	{X , 0x0704 , 0x02},             // output_mb_sem
++	{W , 20000},
++	{X , 0x0705 , 0x20},             // output8_mode
++	{X , 0x0706 , 0x52},             // output8_driver_level
++	{X , 0x0707 , 0x01},             // output8_driver_config
++	{X , 0x0708 , 0x00},             // output8_driver_config
++	{X , 0x070C , 0x00},             // output8_div
++	{X , 0x070D , 0x00},             // output8_div
++	{X , 0x070E , 0x00},             // output8_div
++	{X , 0x070F , 0x04},             // output8_div
++	{X , 0x0710 , 0x00},             // output8_width
++	{X , 0x0711 , 0x00},             // output8_width
++	{X , 0x0712 , 0x00},             // output8_width
++	{X , 0x0713 , 0x04},             // output8_width
++	{X , 0x0714 , 0x00},             // output8_esync_period
++	{X , 0x0715 , 0x00},             // output8_esync_period
++	{X , 0x0716 , 0x00},             // output8_esync_period
++	{X , 0x0717 , 0x02},             // output8_esync_period
++	{X , 0x0718 , 0x00},             // output8_esync_width
++	{X , 0x0719 , 0x00},             // output8_esync_width
++	{X , 0x071A , 0x00},             // output8_esync_width
++	{X , 0x071B , 0x02},             // output8_esync_width
++	{X , 0x0720 , 0x00},             // output8_phase_compensation
++	{X , 0x0721 , 0x00},             // output8_phase_compensation
++	{X , 0x0722 , 0x00},             // output8_phase_compensation
++	{X , 0x0723 , 0x00},             // output8_phase_compensation
++	{X , 0x0724 , 0x00},             // output8_gpo_en
++	{X , 0x0725 , 0x00},             // output8_gpo_select_out_p
++	{X , 0x0726 , 0x00},             // output8_gpo_select_out_p
++	{X , 0x0727 , 0x01},             // output8_gpo_config_out_p
++	{X , 0x0728 , 0x00},             // output8_gpo_select_out_n
++	{X , 0x0729 , 0x00},             // output8_gpo_select_out_n
++	{X , 0x072A , 0x01},             // output8_gpo_config_out_n
++	{X , 0x0704 , 0x01},             // output_mb_sem
++	{W , 20000},
++
++	{X , 0x0702 , 0x02},             // output_mb_mask
++	{X , 0x0703 , 0x00},             // output_mb_mask
++	{X , 0x0704 , 0x02},             // output_mb_sem
++	{W , 20000},
++	{X , 0x0705 , 0x20},             // output9_mode
++	{X , 0x0706 , 0x52},             // output9_driver_level
++	{X , 0x0707 , 0x01},             // output9_driver_config
++	{X , 0x0708 , 0x00},             // output9_driver_config
++	{X , 0x070C , 0x00},             // output9_div
++	{X , 0x070D , 0x00},             // output9_div
++	{X , 0x070E , 0x00},             // output9_div
++	{X , 0x070F , 0x04},             // output9_div
++	{X , 0x0710 , 0x00},             // output9_width
++	{X , 0x0711 , 0x00},             // output9_width
++	{X , 0x0712 , 0x00},             // output9_width
++	{X , 0x0713 , 0x04},             // output9_width
++	{X , 0x0714 , 0x00},             // output9_esync_period
++	{X , 0x0715 , 0x00},             // output9_esync_period
++	{X , 0x0716 , 0x00},             // output9_esync_period
++	{X , 0x0717 , 0x02},             // output9_esync_period
++	{X , 0x0718 , 0x00},             // output9_esync_width
++	{X , 0x0719 , 0x00},             // output9_esync_width
++	{X , 0x071A , 0x00},             // output9_esync_width
++	{X , 0x071B , 0x02},             // output9_esync_width
++	{X , 0x0720 , 0x00},             // output9_phase_compensation
++	{X , 0x0721 , 0x00},             // output9_phase_compensation
++	{X , 0x0722 , 0x00},             // output9_phase_compensation
++	{X , 0x0723 , 0x00},             // output9_phase_compensation
++	{X , 0x0724 , 0x00},             // output9_gpo_en
++	{X , 0x0725 , 0x00},             // output9_gpo_select_out_p
++	{X , 0x0726 , 0x00},             // output9_gpo_select_out_p
++	{X , 0x0727 , 0x01},             // output9_gpo_config_out_p
++	{X , 0x0728 , 0x00},             // output9_gpo_select_out_n
++	{X , 0x0729 , 0x00},             // output9_gpo_select_out_n
++	{X , 0x072A , 0x01},             // output9_gpo_config_out_n
++	{X , 0x0704 , 0x01},             // output_mb_sem
++	{W , 20000},
++
++	{X , 0x0080 , 0x00},             // gpio_irq_config
++	{X , 0x0082 , 0x00},             // ref_mon_th_mask_0P
++	{X , 0x0083 , 0x00},             // ref_mon_th_mask_0N
++	{X , 0x0084 , 0x00},             // ref_mon_th_mask_1P
++	{X , 0x0085 , 0x00},             // ref_mon_th_mask_1N
++	{X , 0x0086 , 0x00},             // ref_mon_th_mask_2P
++	{X , 0x0087 , 0x00},             // ref_mon_th_mask_2N
++	{X , 0x0088 , 0x00},             // ref_mon_th_mask_3P
++	{X , 0x0089 , 0x00},             // ref_mon_th_mask_3N
++	{X , 0x008A , 0x00},             // ref_mon_th_mask_4P
++	{X , 0x008B , 0x00},             // ref_mon_th_mask_4N
++	{X , 0x0090 , 0x00},             // dpll_mon_th_mask_0
++	{X , 0x0091 , 0x00},             // dpll_mon_th_mask_1
++	{X , 0x0092 , 0x00},             // dpll_mon_th_mask_2
++	{X , 0x0095 , 0x00},             // dpll_mon_th_mask_5
++	{X , 0x0096 , 0x00},             // dpll_mon_th_mask_6
++	{X , 0x0097 , 0x00},             // dpll_mon_th_mask_7
++	{X , 0x00A7 , 0x00},             // dpll_ns_rollover_mask
++	{X , 0x00B2 , 0x00},             // ref_mon_tl_mask_0P
++	{X , 0x00B3 , 0x00},             // ref_mon_tl_mask_0N
++	{X , 0x00B4 , 0x00},             // ref_mon_tl_mask_1P
++	{X , 0x00B5 , 0x00},             // ref_mon_tl_mask_1N
++	{X , 0x00B6 , 0x00},             // ref_mon_tl_mask_2P
++	{X , 0x00B7 , 0x00},             // ref_mon_tl_mask_2N
++	{X , 0x00B8 , 0x00},             // ref_mon_tl_mask_3P
++	{X , 0x00B9 , 0x00},             // ref_mon_tl_mask_3N
++	{X , 0x00BA , 0x00},             // ref_mon_tl_mask_4P
++	{X , 0x00BB , 0x00},             // ref_mon_tl_mask_4N
++	{X , 0x00C0 , 0x00},             // dpll_mon_tl_mask_0
++	{X , 0x00C1 , 0x00},             // dpll_mon_tl_mask_1
++	{X , 0x00C2 , 0x00},             // dpll_mon_tl_mask_2
++	{X , 0x00C5 , 0x00},             // dpll_mon_tl_mask_5
++	{X , 0x00C6 , 0x00},             // dpll_mon_tl_mask_6
++	{X , 0x00C7 , 0x00},             // dpll_mon_tl_mask_7
++	{X , 0x00E0 , 0x00},             // gpio_select_0
++	{X , 0x00E1 , 0x00},             // gpio_select_0
++	{X , 0x00E2 , 0x00},             // gpio_config_0
++	{X , 0x00E3 , 0x00},             // gpio_select_1
++	{X , 0x00E4 , 0x00},             // gpio_select_1
++	{X , 0x00E5 , 0x00},             // gpio_config_1
++	{X , 0x00E6 , 0x00},             // gpio_select_2
++	{X , 0x00E7 , 0x00},             // gpio_select_2
++	{X , 0x00E8 , 0x00},             // gpio_config_2
++	{X , 0x00E9 , 0x00},             // gpio_select_3
++	{X , 0x00EA , 0x00},             // gpio_select_3
++	{X , 0x00EB , 0x00},             // gpio_config_3
++	{X , 0x00EC , 0x00},             // gpio_select_4
++	{X , 0x00ED , 0x00},             // gpio_select_4
++	{X , 0x00EE , 0x00},             // gpio_config_4
++	{X , 0x00EF , 0x00},             // gpio_out_4_0
++	{X , 0x00F0 , 0x00},             // gpo_out_7_0
++	{X , 0x00F1 , 0x00},             // gpo_out_15_8
++	{X , 0x00F2 , 0x00},             // gpo_out_19_16
++	{X , 0x00F3 , 0x00},             // gpio_freeze_4_0
++	{X , 0x00F4 , 0x00},             // gpi_freeze_7_0
++	{X , 0x00F5 , 0x00},             // gpi_freeze_9_8
++
++	{X , 0x0200 , 0x00},             // ref_los_3_0
++	{X , 0x0201 , 0x00},             // ref_los_4
++	{X , 0x020F , 0x00},             // ref_phase_err_read_rqst
++	{X , 0x021C , 0x00},             // ref_freq_meas_ctrl
++	{X , 0x021D , 0x00},             // ref_freq_meas_mask_3_0
++	{X , 0x021E , 0x00},             // ref_freq_meas_mask_4
++	{X , 0x021F , 0x00},             // dpll_meas_ref_freq_ctrl
++
++	{X , 0x0283 , 0x05},             // dpll_enable
++	{X , 0x0284 , 0x02},             // dpll_mode_refsel_0
++	{X , 0x0285 , 0x6C},             // dpll_ctrl_0
++	{X , 0x0286 , 0x00},             // dpll_cmd_0
++	{X , 0x0288 , 0x00},             // dpll_mode_refsel_1
++	{X , 0x0289 , 0x0C},             // dpll_ctrl_1
++	{X , 0x028A , 0x00},             // dpll_cmd_1
++	{X , 0x028C , 0x00},             // dpll_mode_refsel_2
++	{X , 0x028D , 0x0C},             // dpll_ctrl_2
++	{X , 0x028E , 0x00},             // dpll_cmd_2
++	{X , 0x0298 , 0x00},             // dpll_mode_refsel_5
++	{X , 0x0299 , 0x0C},             // dpll_ctrl_5
++	{X , 0x029A , 0x00},             // dpll_cmd_5
++	{X , 0x029C , 0x00},             // dpll_mode_refsel_6
++	{X , 0x029D , 0x00},             // dpll_ctrl_6
++	{X , 0x029E , 0x00},             // dpll_cmd_6
++	{X , 0x02A0 , 0x00},             // dpll_mode_refsel_7
++	{X , 0x02A1 , 0x00},             // dpll_ctrl_7
++	{X , 0x02A2 , 0x00},             // dpll_cmd_7
++	{X , 0x02A4 , 0x00},             // ext_fb_ctrl
++	{X , 0x02A5 , 0x00},             // ext_fb_sel
++	{X , 0x02D0 , 0x00},             // dpll_meas_ctrl
++	{X , 0x02D1 , 0x00},             // dpll_meas_idx
++	{X , 0x02D2 , 0x00},             // dpll_meas_ref_edge_3_0
++	{X , 0x02D3 , 0x00},             // dpll_meas_ref_edge_4
++	{X , 0x02D4 , 0x00},             // dpll_phase_err_read_mask
++
++	{X , 0x0480 , 0x01},             // synth_ctrl_0
++	{X , 0x0481 , 0x01},             // synth_ctrl_1
++	{X , 0x0482 , 0x01},             // synth_ctrl_2
++	{X , 0x0483 , 0x01},             // synth_ctrl_3
++	{X , 0x0484 , 0x01},             // synth_ctrl_4
++	{X , 0x0485 , 0x00},             // synth_df_offset_manual_0
++	{X , 0x0486 , 0x00},             // synth_df_offset_manual_0
++	{X , 0x0487 , 0x00},             // synth_df_offset_manual_0
++	{X , 0x0488 , 0x00},             // synth_df_offset_manual_0
++	{X , 0x0489 , 0x00},             // synth_df_offset_manual_0
++	{X , 0x048A , 0x00},             // synth_df_offset_manual_1
++	{X , 0x048B , 0x00},             // synth_df_offset_manual_1
++	{X , 0x048C , 0x00},             // synth_df_offset_manual_1
++	{X , 0x048D , 0x00},             // synth_df_offset_manual_1
++	{X , 0x048E , 0x00},             // synth_df_offset_manual_1
++	{X , 0x048F , 0x00},             // synth_df_offset_manual_2
++	{X , 0x0490 , 0x00},             // synth_df_offset_manual_2
++	{X , 0x0491 , 0x00},             // synth_df_offset_manual_2
++	{X , 0x0492 , 0x00},             // synth_df_offset_manual_2
++	{X , 0x0493 , 0x00},             // synth_df_offset_manual_2
++	{X , 0x0494 , 0x00},             // synth_df_offset_manual_3
++	{X , 0x0495 , 0x00},             // synth_df_offset_manual_3
++	{X , 0x0496 , 0x00},             // synth_df_offset_manual_3
++	{X , 0x0497 , 0x00},             // synth_df_offset_manual_3
++	{X , 0x0498 , 0x00},             // synth_df_offset_manual_3
++	{X , 0x0499 , 0x00},             // synth_df_offset_manual_4
++	{X , 0x049A , 0x00},             // synth_df_offset_manual_4
++	{X , 0x049B , 0x00},             // synth_df_offset_manual_4
++	{X , 0x049C , 0x00},             // synth_df_offset_manual_4
++	{X , 0x049D , 0x00},             // synth_df_offset_manual_4
++	{X , 0x04A8 , 0x21},             // output_ctrl_0
++	{X , 0x04A9 , 0x31},             // output_ctrl_1
++	{X , 0x04AA , 0x31},             // output_ctrl_2
++	{X , 0x04AB , 0x31},             // output_ctrl_3
++	{X , 0x04AC , 0x31},             // output_ctrl_4
++	{X , 0x04AD , 0x31},             // output_ctrl_5
++	{X , 0x04AE , 0x31},             // output_ctrl_6
++	{X , 0x04AF , 0x01},             // output_ctrl_7
++	{X , 0x04B0 , 0x11},             // output_ctrl_8
++	{X , 0x04B1 , 0x41},             // output_ctrl_9
++	{X , 0x04B6 , 0x00},             // output_step_time_mask
++	{X , 0x04B7 , 0x40},             // output_step_time_mask
++	{X , 0x0281 , 0x00},             // split_xo_mode_ctrl- bit 0 must be disabled before writing 0x280
++	{W , 200000},
++	{X , 0x0280 , 0x99},             // split_xo_ref
++	{X , 0x0281 , 0x01},             // split_xo_mode_ctrl
++	{W , 200000},
++};
++
++/*
++ * =============================================================================
++ * Register Configuration End
++ * Register Write Count = 1507
++ * =============================================================================
++ */
++#endif
+diff -Naur --no-dereference '--exclude=.git' A/cmd/cmd_iG_memtest.c B/cmd/cmd_iG_memtest.c
+--- A/cmd/cmd_iG_memtest.c	1970-01-01 05:30:00.000000000 +0530
++++ B/cmd/cmd_iG_memtest.c	2025-12-09 16:47:51.967683268 +0530
+@@ -0,0 +1,598 @@
++/* This file contains the iWave Global IG58M board FPGA/HPS DDR memory test as a part of POST
++ *
++ * The Memory tests will be done for 
++ * 1. HPS DDR : Data Line Integrity Test, Address Line Integrity Test, 
++ *              Pattern Test[Fixed Range], ECC Single bit and Double Bit Fail Test.
++ * 2. FPGA DDR : Data Line Integrity Test, Address Line Integrity Test, 
++ *               Pattern Test [Fixed Range]
++ */
++
++#include <command.h>
++#include <console.h>
++#include <linux/bitops.h>
++#include <linux/delay.h>
++
++#include <linux/string.h>
++#include <linux/types.h>
++#include <asm/io.h>
++#include <stdio.h>
++
++#include <command.h>
++#include <linux/string.h>
++#include <linux/types.h>
++#include <asm/io.h>
++#include <stdio.h>
++#include <console.h> /* For ctrlc */
++#include <vsprintf.h> /* For simple_strtoul */
++#include <bootretry.h>
++#include <cli.h>
++#ifdef CONFIG_HAS_DATAFLASH
++#include <dataflash.h>
++#endif
++#include <hash.h>
++#include <watchdog.h>
++#include <linux/compiler.h>
++#include <mapmem.h>
++
++#define DBG 0
++
++#define HPS_START_ADDR        0x81000000
++#define HPS_END_ADDR          0xF0000000
++#define FPGA_START_ADDR_1     0x40000000
++#define FPGA_END_ADDR_1       0x7FFFFFFF
++#define FPGA_START_ADDR_2     0x0440000000
++#define FPGA_END_ADDR_2       0x047fffffff
++#define FPGA_START_ADDR_3     0x0480000000
++#define FPGA_END_ADDR_3       0x04ffffffff
++#define TEST_DATA_1           0x55555555
++#define TEST_DATA_2           0xAAAAAAAA
++#define SYS_MEMTEST_SCRATCH   0x81800000
++#define VULONG                unsigned long long
++#define ULONG                 unsigned long
++
++int do_dl_test(struct cmd_tbl *cmdtp, int flag, int argc, char * const argv[])
++{
++    VULONG addr;
++    ULONG read_data, write_data;
++    ULONG dl_hps_err = 0, dl_fpga_err = 0;
++
++    if (strcmp(argv[0], "dl_test\0") == 0)
++        addr = (long long unsigned int) map_sysmem(HPS_START_ADDR, 0);
++    else if (strcmp(argv[0], "fpga_dl_test\0") == 0)
++        addr = (long long unsigned int) map_sysmem(FPGA_START_ADDR_1, 0);
++
++    /* Perform the walk in 1 test for data bus to identify if any of the data bits are struck at LOW */
++    printf("\r Walk in 1 test for data bus\n");
++    write_data = 0x0000000000000001;
++    while (write_data)
++    {
++#if DBG 
++        printf("\n Writing value %08lx to address 0x%.8llx\n", write_data, addr);
++#endif
++        *(VULONG *) addr = write_data;
++        read_data = *(VULONG *) addr;
++#if DBG
++        printf("\n Read data %08lx\n", read_data);
++#endif
++        if (read_data != write_data)
++        {
++            if (strcmp(argv[0], "dl_test\0") == 0)
++                dl_hps_err++;
++            else if (strcmp(argv[0], "fpga_dl_test\0") == 0)
++                dl_fpga_err++;
++        }
++        addr += 8;
++        write_data <<= 1;
++    }
++
++    if (strcmp(argv[0], "dl_test\0") == 0)
++        addr = (long long unsigned int) map_sysmem(HPS_START_ADDR, 0);
++    else if (strcmp(argv[0], "fpga_dl_test\0") == 0)
++        addr = (long long unsigned int) map_sysmem(FPGA_START_ADDR_1, 0);
++
++    /* Perform the walk in 0 test for data bus to identify if any of the data bits are struck at HIGH */
++    printf("\r Walk in 0 test for data bus\n");
++    write_data = 0xFFFFFFFFFFFFFFFE;
++    while (write_data < 0xFFFFFFFFFFFFFFFF)
++    {
++#if DBG 
++        printf("\n Writing value %08lx to address 0x%.8llx\n", write_data, addr);
++#endif
++        *(VULONG *) addr = write_data;
++        read_data = *(VULONG *) addr;
++#if DBG
++        printf("\n Read data %08lx\n", read_data);
++#endif
++        if (read_data != write_data)
++        {
++            if (strcmp(argv[0], "dl_test\0") == 0)
++                dl_hps_err++;
++            else if (strcmp(argv[0], "fpga_dl_test\0") == 0)
++                dl_fpga_err++;
++        }
++        addr += 8;
++        write_data = ((write_data << 1) + 1);
++    }
++
++    if (strcmp(argv[0], "dl_test\0") == 0) {
++        printf("HPS DDR Data line test is done with %ld errors\r\n", dl_hps_err);    
++    }
++    else if (strcmp(argv[0], "fpga_dl_test\0") == 0) {
++        printf("FPGA DDR Data line test is done with %ld errors\r\n", dl_fpga_err);    
++    }
++
++    return 0;
++}
++
++int do_al_test(struct cmd_tbl *cmdtp, int flag, int argc, char * const argv[])
++{
++    vu_long pattern, anti_pattern;
++    vu_long *addr;
++    vu_long test_offset;
++    vu_long offset;
++    vu_long temp;
++    ulong al_hps_err = 0, al_fpga_err = 0;
++
++    if (strcmp(argv[0], "al_test\0") == 0)
++        addr = map_sysmem(HPS_START_ADDR, 0);
++    else if (strcmp(argv[0], "fpga_al_test\0") == 0)
++        addr = map_sysmem(FPGA_START_ADDR_1, 0);
++    
++    pattern = (vu_long) 0xaaaaaaaa;
++    anti_pattern = (vu_long) 0x55555555;
++
++    /* Write the pattern to the power-of-two offset locations */
++    for (offset = 1; offset < 4; offset <<= 1)
++        addr[offset] = pattern;
++
++    test_offset = 0;
++
++    /* Write anti-pattern to the below location */
++    addr[test_offset] = anti_pattern;
++
++    /* All the address lines are set to 0 as we written pattern to offset 
++     * Read the data ie.pattern from the power-of-two offset locations which has one address bit set to high
++     * If the pattern is re-written to anti-pattern to any one of the power-of-two offset locations
++     * stuck-at high fault is detected at that address bit */
++    printf("\r Walk in 1 test for data bus\n");
++    for (offset = 1; offset < 4; offset <<= 1) {
++        temp = addr[offset];    
++        if (temp != pattern) {
++            printf("\nFAILURE: Address bit stuck high"
++                   "@ 0x%.8lx: expected 0x%.8lx,"
++                   " actual 0x%.8lx\n",
++                   (ulong)addr + offset * sizeof(vu_long),
++                   pattern, temp);
++            if (strcmp(argv[0], "al_test\0") == 0)
++                al_hps_err++;
++            else if (strcmp(argv[0], "fpga_al_test\0") == 0)
++                al_fpga_err++;
++        }
++    }
++
++    addr[test_offset] = pattern;
++
++    /*
++     * Check for addr bits stuck low or shorted.
++     */
++    printf("\r Walk in 0 test for data bus\n");
++    for (test_offset = 1; test_offset < 4; test_offset <<= 1) {
++        addr[test_offset] = anti_pattern;
++
++        for (offset = 1; offset < 4; offset <<= 1) {
++            temp = addr[offset];
++            if ((temp != pattern) && (offset != test_offset)) {
++                printf("\nFAILURE: Address bit stuck low or"
++                       " shorted @ 0x%.8lx: expected 0x%.8lx,"
++                       " actual 0x%.8lx\n",
++                       (ulong)addr + offset * sizeof(vu_long),
++                       pattern, temp);
++                if (strcmp(argv[0], "al_test\0") == 0)
++                    al_hps_err++;
++                else if (strcmp(argv[0], "fpga_al_test\0") == 0)
++                    al_fpga_err++;
++            }
++        }
++        addr[test_offset] = pattern;
++    }
++
++    if (strcmp(argv[0], "al_test\0") == 0) {
++        printf("HPS DDR Address line test is done with %ld errors\r\n", al_hps_err);
++    }
++    else if (strcmp(argv[0], "fpga_al_test\0") == 0) {
++        printf("FPGA DDR Address line test is done with %ld errors\r\n", al_fpga_err);
++    }
++
++    return 0;
++}
++
++static ulong mem_test_alt(vu_long *buf, ulong start_addr, ulong end_addr,
++                          vu_long *dummy)
++{
++    vu_long *addr;
++    ulong errs = 0;
++    ulong val, readback;
++    int j;
++    vu_long offset;
++    vu_long test_offset;
++    vu_long pattern;
++    vu_long temp;
++    vu_long anti_pattern;
++    vu_long num_words;
++    static const ulong bitpattern[] = {
++        0x00000001, /* single bit */
++        0x00000003, /* two adjacent bits */
++        0x00000007, /* three adjacent bits */
++        0x0000000F, /* four adjacent bits */
++        0x00000005, /* two non-adjacent bits */
++        0x00000015, /* three non-adjacent bits */
++        0x00000055, /* four non-adjacent bits */
++        0xaaaaaaaa, /* alternating 1/0 */
++    };
++
++    num_words = (end_addr - start_addr) / sizeof(vu_long);
++
++    /*
++     * Data line test: write a pattern to the first
++     * location, write the 1's complement to a 'parking'
++     * address (changes the state of the data bus so a
++     * floating bus doesn't give a false OK), and then
++     * read the value back. Note that we read it back
++     * into a variable because the next time we read it,
++     * it might be right (been there, tough to explain to
++     * the quality guys why it prints a failure when the
++     * "is" and "should be" are obviously the same in the
++     * error message).
++     *
++     * Rather than exhaustively testing, we test some
++     * patterns by shifting '1' bits through a field of
++     * '0's and '0' bits through a field of '1's (i.e.
++     * pattern and ~pattern).
++     */
++    addr = buf;
++    for (j = 0; j < sizeof(bitpattern) / sizeof(bitpattern[0]); j++) {
++        val = bitpattern[j];
++        for (; val != 0; val <<= 1) {
++            *addr = val;
++            *dummy = ~val; /* clear the test data off the bus */
++            readback = *addr;
++            if (readback != val) {
++                printf("FAILURE (data line): "
++                       "expected %08lx, actual %08lx\n",
++                       val, readback);
++                errs++;
++                if (ctrlc())
++                    return -1;
++            }
++            *addr = ~val;
++            *dummy = val;
++            readback = *addr;
++            if (readback != ~val) {
++                printf("FAILURE (data line): "
++                       "Is %08lx, should be %08lx\n",
++                       readback, ~val);
++                errs++;
++                if (ctrlc())
++                    return -1;
++            }
++        }
++    }
++
++    /*
++     * Based on code whose Original Author and Copyright
++     * information follows: Copyright (c) 1998 by Michael
++     * Barr. This software is placed into the public
++     * domain and may be used for any purpose. However,
++     * this notice must not be changed or removed and no
++     * warranty is either expressed or implied by its
++     * publication or distribution.
++     */
++
++    /*
++     * Address line test
++     *
++     * Description: Test the address bus wiring in a
++     *              memory region by performing a walking
++     *              1's test on the relevant bits of the
++     *              address and checking for aliasing.
++     *              This test will find single-bit
++     *              address failures such as stuck-high,
++     *              stuck-low, and shorted pins. The base
++     *              address and size of the region are
++     *              selected by the caller.
++     *
++     * Notes: For best results, the selected base
++     *              address should have enough LSB 0's to
++     *              guarantee single address bit changes.
++     *              For example, to test a 64-Kbyte
++     *              region, select a base address on a
++     *              64-Kbyte boundary. Also, select the
++     *              region size as a power-of-two if at
++     *              all possible.
++     *
++     * Returns:     0 if the test succeeds, 1 if the test fails.
++     */
++    pattern = (vu_long) 0xaaaaaaaa;
++    anti_pattern = (vu_long) 0x55555555;
++
++    pr_debug("%s:%d: length = 0x%.8lx\n", __func__, __LINE__, num_words);
++    /*
++     * Write the default pattern at each of the
++     * power-of-two offsets.
++     */
++    for (offset = 1; offset < num_words; offset <<= 1)
++        addr[offset] = pattern;
++
++    /*
++     * Check for address bits stuck high.
++     */
++    test_offset = 0;
++    addr[test_offset] = anti_pattern;
++
++    for (offset = 1; offset < num_words; offset <<= 1) {
++        temp = addr[offset];
++        if (temp != pattern) {
++            printf("\nFAILURE: Address bit stuck high @ 0x%.8lx:"
++                   " expected 0x%.8lx, actual 0x%.8lx\n",
++                   start_addr + offset * sizeof(vu_long),
++                   pattern, temp);
++            errs++;
++            if (ctrlc())
++                return -1;
++        }
++    }
++    addr[test_offset] = pattern;
++    schedule();
++
++    /*
++     * Check for addr bits stuck low or shorted.
++     */
++    for (test_offset = 1; test_offset < num_words; test_offset <<= 1) {
++        addr[test_offset] = anti_pattern;
++
++        for (offset = 1; offset < num_words; offset <<= 1) {
++            temp = addr[offset];
++            if ((temp != pattern) && (offset != test_offset)) {
++                printf("\nFAILURE: Address bit stuck low or"
++                       " shorted @ 0x%.8lx: expected 0x%.8lx,"
++                       " actual 0x%.8lx\n",
++                       start_addr + offset * sizeof(vu_long),
++                       pattern, temp);
++                errs++;
++                if (ctrlc())
++                    return -1;
++            }
++        }
++        addr[test_offset] = pattern;
++    }
++
++    /*
++     * Description: Test the integrity of a physical
++     *              memory device by performing an
++     *              increment/decrement test over the
++     *              entire region. In the process every
++     *              storage bit in the device is tested
++     *              as a zero and a one. The base address
++     *              and the size of the region are
++     *              selected by the caller.
++     *
++     * Returns:     0 if the test succeeds, 1 if the test fails.
++     */
++    num_words++;
++
++    /*
++     * Fill memory with a known pattern.
++     */
++    for (pattern = 1, offset = 0; offset < num_words; pattern++, offset++) {
++        schedule();
++        addr[offset] = pattern;
++    }
++
++    /*
++     * Check each location and invert it for the second pass.
++     */
++    for (pattern = 1, offset = 0; offset < num_words; pattern++, offset++) {
++        schedule();
++        temp = addr[offset];
++        if (temp != pattern) {
++            printf("\nFAILURE (read/write) @ 0x%.8lx:"
++                   " expected 0x%.8lx, actual 0x%.8lx)\n",
++                   start_addr + offset * sizeof(vu_long),
++                   pattern, temp);
++            errs++;
++            if (ctrlc())
++                return -1;
++        }
++
++        anti_pattern = ~pattern;
++        addr[offset] = anti_pattern;
++    }
++
++    /*
++     * Check each location for the inverted pattern and zero it.
++     */
++    for (pattern = 1, offset = 0; offset < num_words; pattern++, offset++) {
++        schedule();
++        anti_pattern = ~pattern;
++        temp = addr[offset];
++        if (temp != anti_pattern) {
++            printf("\nFAILURE (read/write): @ 0x%.8lx:"
++                   " expected 0x%.8lx, actual 0x%.8lx)\n",
++                   start_addr + offset * sizeof(vu_long),
++                   anti_pattern, temp);
++            errs++;
++            if (ctrlc())
++                return -1;
++        }
++        addr[offset] = 0;
++    }
++
++    return 0;
++}
++
++static ulong mem_test_quick(vu_long *buf, ulong start_addr, ulong end_addr,
++                            vu_long pattern, int iteration)
++{
++    vu_long *end;
++    vu_long *addr;
++    ulong errs = 0;
++    ulong incr, length;
++    ulong val, readback;
++
++    /* Alternate the pattern */
++    incr = 1;
++    if (iteration & 1) {
++        incr = -incr;
++        /*
++         * Flip the pattern each time to make lots of zeros and
++         * then, the next time, lots of ones. We decrement
++         * the "negative" patterns and increment the "positive"
++         * patterns to preserve this feature.
++         */
++        if (pattern & 0x80000000)
++            pattern = -pattern; /* complement & increment */
++        else
++            pattern = ~pattern;
++    }
++    length = (end_addr - start_addr) / sizeof(ulong);
++    end = buf + length;
++    printf("\rPattern %08lX  Writing..."
++           "%12s"
++           "\b\b\b\b\b\b\b\b\b\b",
++           pattern, "");
++    for (addr = buf, val = pattern; addr < end; addr++) {
++        schedule();
++        *addr = val;
++        val += incr;
++    }
++
++    puts("Reading...");
++
++    for (addr = buf, val = pattern; addr < end; addr++) {
++        schedule();
++        readback = *addr;
++        if (readback != val) {
++            ulong offset = addr - buf;
++
++            printf("\nMem error @ 0x%08X: "
++                   "found %08lX, expected %08lX\n",
++                   (uint)(uintptr_t)(start_addr + offset * sizeof(vu_long)),
++                   readback, val);
++            errs++;
++            if (ctrlc())
++                return -1;
++        }
++        val += incr;
++    }
++
++    return 0;
++}
++
++/*
++ * Perform a memory test. A more complete alternative test can be
++ * configured using CONFIG_SYS_ALT_MEMTEST. The complete test loops until
++ * interrupted by ctrl-c or by a failure of one of the sub-tests.
++ */
++static int do_ptrn_test(struct cmd_tbl *cmdtp, int flag, int argc,
++                        char * const argv[])
++{
++    ulong start, end;
++    vu_long *buf, *dummy;
++    int iteration_limit;
++    int ret, iteration;
++    ulong errs = 0; /* number of errors, or -1 if interrupted */
++    ulong pattern;
++
++#if defined(CONFIG_SYS_ALT_MEMTEST)
++    const int alt_test = 1;
++#else
++    const int alt_test = 0;
++#endif
++    if (argc <= 3) {
++        printf("--help\r\nptrn_test start end pattern\r\nEx: ptrn_test 0x81000000 0xF0000000  0xAAAABBBB\r\n");
++        return 1;
++    }
++
++    start = simple_strtoul(argv[1], NULL, 16);
++    end = simple_strtoul(argv[2], NULL, 16);
++    pattern = (ulong)simple_strtoul(argv[3], NULL, 16);
++    iteration_limit = 1;
++
++    if (start >= HPS_START_ADDR && end <= HPS_END_ADDR)
++        printf("Pattern test for HPS DDR memory..");
++    else if (start >= FPGA_START_ADDR_1 && end <= FPGA_END_ADDR_1)
++        printf("Pattern test for FPGA DDR memory..");
++    else if (start >= FPGA_START_ADDR_2 && end <= FPGA_END_ADDR_2)
++        printf("Pattern test for FPGA DDR memory..");
++    else if (start >= FPGA_START_ADDR_3 && end <= FPGA_END_ADDR_3)
++        printf("Pattern test for FPGA DDR memory..");
++    else {
++        errs = -1UL;
++        return -1;
++    }    
++    
++    printf("\nTesting %08lx ... %08lx:\n", (ulong)start, (ulong)end);
++    pr_debug("%s:%d: start %#08lx end %#08lx\n", __func__, __LINE__,
++             start, end);
++
++    buf = map_sysmem(start, end - start);
++    dummy = map_sysmem(SYS_MEMTEST_SCRATCH, sizeof(vu_long));
++    for (iteration = 0;
++         !iteration_limit || iteration < iteration_limit;
++         iteration++) {
++        if (ctrlc()) {
++            errs = -1UL;
++            break;
++        }
++#if DBG
++        printf("Iteration: %6d\r", iteration + 1);
++        pr_debug("\n");
++#endif
++        if (alt_test) {
++            errs = mem_test_alt(buf, start, end, dummy);
++        } else {
++            errs = mem_test_quick(buf, start, end, pattern,
++                                  iteration);
++        }
++        if (errs == -1UL)
++            break;
++    }
++
++    /*
++     * Work-around for eldk-4.2 which gives this warning if we try to
++     * case in the unmap_sysmem() call:
++     * warning: initialization discards qualifiers from pointer target type
++     */
++    {
++        void *vbuf = (void *)buf;
++        void *vdummy = (void *)dummy;
++
++        unmap_sysmem(vbuf);
++        unmap_sysmem(vdummy);
++    }
++
++    if (errs == -1UL) {
++        /* Memory test was aborted - write a newline to finish off */
++        putc('\n');
++        ret = 1;
++    } else {
++        if (errs > 0)
++            printf("Tested %d iteration(s) with %lu errors.\n",
++                   iteration, errs);
++        else
++            printf("Test is done with %lu errors.\n", errs);
++        ret = errs != 0;
++    }
++
++    return ret; /* not reached */
++}
++
++U_BOOT_CMD(dl_test, 1, 1, do_dl_test, "data line integrity test for HPS DDR", "");
++
++U_BOOT_CMD(fpga_dl_test, 1, 1, do_dl_test, "data line integrity test for FPGA DDR", "");
++
++U_BOOT_CMD(al_test, 1, 1, do_al_test, "Address line integrity test for HPS DDR", "");
++
++U_BOOT_CMD(fpga_al_test, 1, 1, do_al_test, "Address line integrity test for FPGA DDR", "");
++
++U_BOOT_CMD(ptrn_test, 4, 1, do_ptrn_test, "simple RAM pattern test", "start end pattern");
+diff -Naur --no-dereference '--exclude=.git' A/cmd/Kconfig B/cmd/Kconfig
+--- A/cmd/Kconfig	2025-12-09 11:50:06.504598977 +0530
++++ B/cmd/Kconfig	2025-12-09 16:47:51.964683226 +0530
+@@ -989,6 +989,12 @@
+ 	  test. If no arguments are given to mtest, default address is used
+ 	  as end address.
+ 
++config CMD_IG_MEMTEST
++        bool "Add support for DDR Memory Test"
++        help
++          This is used for FPGA and HPS, DDR memory tests such as data line integrity
++          test, address line integrity test and pattern test.
++
+ endif
+ 
+ config CMD_SHA1SUM
+diff -Naur --no-dereference '--exclude=.git' A/cmd/Makefile B/cmd/Makefile
+--- A/cmd/Makefile	2025-12-09 11:50:06.504598977 +0530
++++ B/cmd/Makefile	2025-12-09 16:47:51.965683240 +0530
+@@ -33,6 +33,7 @@
+ obj-$(CONFIG_CMD_BLOCK_CACHE) += blkcache.o
+ obj-$(CONFIG_CMD_BMP) += bmp.o
+ obj-$(CONFIG_CMD_BOOTCOUNT) += bootcount.o
++obj-$(CONFIG_CMD_IG_MEMTEST) += cmd_iG_memtest.o
+ obj-$(CONFIG_CMD_BOOTEFI) += bootefi.o
+ obj-$(CONFIG_CMD_BOOTMENU) += bootmenu.o
+ obj-$(CONFIG_CMD_BOOTSTAGE) += bootstage.o
+diff -Naur --no-dereference '--exclude=.git' A/configs/socfpga_agilex5_iG58m_defconfig B/configs/socfpga_agilex5_iG58m_defconfig
+--- A/configs/socfpga_agilex5_iG58m_defconfig	1970-01-01 05:30:00.000000000 +0530
++++ B/configs/socfpga_agilex5_iG58m_defconfig	2025-12-09 16:47:52.052684442 +0530
+@@ -0,0 +1,278 @@
++CONFIG_ARM=y
++CONFIG_ARCH_SOCFPGA=y
++CONFIG_SYS_ARCH="arm"
++CONFIG_SYS_CPU="armv8"
++CONFIG_SYS_SOC="socfpga"
++CONFIG_SYS_VENDOR="intel"
++CONFIG_SYS_BOARD="agilex5-iG58m"
++CONFIG_SYS_CONFIG_NAME="socfpga_agilex5_iG58m"
++CONFIG_ARM64=y
++CONFIG_BOOTFILE="kernel.itb"
++CONFIG_TEXT_BASE=0x80200000
++CONFIG_ENV_OFFSET=0x04100000
++CONFIG_ENV_SECT_SIZE=0x512
++CONFIG_ENV_SIZE=0x2000
++CONFIG_ENV_ADDR=0x0
++CONFIG_SYS_STDIO_DEREGISTER=y
++CONFIG_CONSOLE_MUX=y
++CONFIG_SYS_CONSOLE_IS_IN_ENV=y
++CONFIG_BOARD_LATE_INIT=y
++CONFIG_NR_DRAM_BANKS=3
++CONFIG_SPL_LDSCRIPT="arch/arm/mach-socfpga/u-boot-spl-soc64.lds"
++CONFIG_SYS_SPI_U_BOOT_OFFS=0x04000000
++CONFIG_HAS_CUSTOM_SYS_INIT_SP_ADDR=y
++CONFIG_CUSTOM_SYS_INIT_SP_ADDR=0x80300000
++CONFIG_SF_DEFAULT_MODE=0x2003
++CONFIG_SF_DEFAULT_SPEED=1000000
++CONFIG_SPL_DM_GPIO=y
++CONFIG_DM_GPIO=y
++CONFIG_SPL_GPIO=y
++CONFIG_SPL_GPIO_HOG=y
++CONFIG_GPIO_HOG=y
++CONFIG_PHY_ATHEROS=y
++CONFIG_SPL_PHY_ATHEROS=y
++CONFIG_DM_MDIO=y
++CONFIG_I2C_MUX=y
++CONFIG_I2C_MUX_PCA954x=y
++CONFIG_CMD_PCA953X=y
++CONFIG_DM_PCA953X=y
++CONFIG_DEFAULT_DEVICE_TREE="socfpga_agilex5_iG58m"
++CONFIG_SPL_MMC=y
++CONFIG_SPL_DM_MMC=y
++CONFIG_SPL_SERIAL=y
++CONFIG_SPL_DRIVERS_MISC=y
++CONFIG_TARGET_SOCFPGA_AGILEX5_IG58M=y
++CONFIG_TARGET_SOCFPGA_SOC64=y
++CONFIG_TARGET_SOCFPGA_AGILEX5_SIMICS=y
++CONFIG_SPL_ENV_SUPPORT=y
++CONFIG_ENV_IS_IN_FAT=y
++CONFIG_ENV_IS_IN_MMC=y
++CONFIG_ENV_IS_IN_SPI_FLASH=y
++CONFIG_SPL_ENV_IS_IN_FAT=y
++CONFIG_SPL_ENV_IS_IN_MMC=y
++CONFIG_SPL_ENV_IS_IN_SPI_FLASH=y
++CONFIG_ENV_FAT_DEVICE_AND_PART="0:1"
++CONFIG_ENV_SPI_BUS=0
++CONFIG_ENV_SPI_CS=0
++CONFIG_ENV_SPI_MAX_HZ=1000000
++CONFIG_ENV_SPI_MODE=0x2003
++CONFIG_DM_RESET=y
++CONFIG_SPL_STACK=0x71000
++# CONFIG_EFI_LOADER is not set
++# CONFIG_SPL_RAW_IMAGE_SUPPORT is not set
++# CONFIG_SPL_SHARES_INIT_SP_ADDR is not set
++# CONFIG_ISO_PARTITION is not set
++# CONFIG_EFI_PARTITION is not set
++# CONFIG_SPL_EFI_PARTITION is not set
++# CONFIG_SPL_PARTITION_UUIDS is not set
++# CONFIG_SPL_USE_TINY_PRINTF is not set
++# CONFIG_MMC_VERBOSE is not set
++# CONFIG_SPI_FLASH_USE_4K_SECTORS is not set
++CONFIG_CMD_I3C=y
++CONFIG_I3C=y
++CONFIG_DW_I3C_MASTER=y
++CONFIG_USE_BOOTFILE=y
++CONFIG_SPL_SYS_MALLOC=y
++CONFIG_SPL_HAS_CUSTOM_MALLOC_START=y
++CONFIG_SPL_CUSTOM_SYS_MALLOC_ADDR=0xbfa00000
++CONFIG_SPL_SYS_MALLOC_SIZE=0x500000
++CONFIG_SPL_HAS_BSS_LINKER_SECTION=y
++CONFIG_SPL_BSS_START_ADDR=0xbff00000
++CONFIG_SPL_BSS_MAX_SIZE=0x100000
++CONFIG_SYS_LOAD_ADDR=0x82000000
++CONFIG_IDENT_STRING="socfpga_agilex5"
++CONFIG_SPL_FS_FAT=y
++CONFIG_SPL_LIBDISK_SUPPORT=y
++CONFIG_SPL_SPI_FLASH_SUPPORT=y
++CONFIG_SPL_SPI=y
++CONFIG_FIT=y
++CONFIG_SPL_FIT_SIGNATURE=y
++CONFIG_SPL_LOAD_FIT=y
++CONFIG_SPL_LOAD_FIT_ADDRESS=0x82000000
++CONFIG_LEGACY_IMAGE_FORMAT=y
++CONFIG_DISTRO_DEFAULTS=y
++CONFIG_QSPI_BOOT=y
++CONFIG_BOOTDELAY=5
++CONFIG_USE_BOOTARGS=y
++CONFIG_BOOTARGS="console=ttyS1,115200 earlycon panic=-1"
++CONFIG_BOOTCOMMAND="run distro_bootcmd"
++CONFIG_SPL_MAX_SIZE=0x40000
++CONFIG_SPL_SYS_MALLOC_F=y
++CONFIG_SPL_SYS_MALLOC_F_LEN=0x2000
++CONFIG_SPL_CACHE=y
++CONFIG_SPL_SPI_FLASH_MTD=y
++CONFIG_SPL_SPI_LOAD=y
++CONFIG_SPL_DM_SPI=y
++CONFIG_SPL_DM_SPI_FLASH=y
++CONFIG_SPL_ATF=y
++CONFIG_SPL_ATF_NO_PLATFORM_PARAM=y
++CONFIG_SYS_PROMPT="IG58M # "
++CONFIG_CMD_GREPENV=y
++CONFIG_CMD_ERASEENV=y
++CONFIG_CMD_NVEDIT_INFO=y
++CONFIG_SYS_MAXARGS=32
++CONFIG_CMD_NVEDIT_SELECT=y
++CONFIG_CMD_MEMTEST=y
++CONFIG_CMD_IG_MEMTEST=y
++CONFIG_CMD_GPIO=y
++CONFIG_CMD_I2C=y
++CONFIG_DM_I2C=y
++CONFIG_SYS_I2C_DW=y
++CONFIG_CMD_MMC=y
++CONFIG_CMD_PART=y
++CONFIG_PHY=y
++CONFIG_SPL_PHY=y
++CONFIG_I2C_EEPROM=y
++CONFIG_FRU_EEPROM=y
++CONFIG_SYS_I2C_EEPROM_ADDR=0x3
++CONFIG_SYS_I2C_EEPROM_ADDR_OVERFLOW=0x50
++CONFIG_NOP_PHY=y
++CONFIG_SPL_NOP_PHY=y
++CONFIG_PHY_CADENCE_COMBOPHY=y
++CONFIG_SPL_PHY_CADENCE_COMBOPHY=y
++CONFIG_MMC=y
++CONFIG_MMC_WRITE=y
++CONFIG_DM_MMC=y
++CONFIG_MMC_SDHCI_ADMA_HELPERS=y
++CONFIG_MMC_QUIRKS=y
++CONFIG_SYS_MMC_MAX_BLK_COUNT=65535
++CONFIG_MMC_HW_PARTITIONING=y
++CONFIG_MMC_DW=y
++CONFIG_MMC_DW_SOCFPGA=y
++CONFIG_MMC_SDHCI=y
++CONFIG_MMC_SDHCI_ADMA=y
++CONFIG_SPL_MMC_SDHCI_ADMA=y
++CONFIG_MMC_SDHCI_CADENCE=y
++CONFIG_CMD_FAT=y
++CONFIG_CMD_MTD=y
++CONFIG_CMD_SPI=y
++CONFIG_CMD_USB=y
++CONFIG_CMD_CACHE=y
++CONFIG_CMD_TIMER=y
++CONFIG_MTDIDS_DEFAULT="nand0=10b80000.nand.0"
++CONFIG_MTDPARTS_DEFAULT="mtdparts=10b80000.nand.0:2m(u-boot),-(root)"
++CONFIG_ENV_OVERWRITE=y
++CONFIG_SYS_RELOC_GD_ENV_ADDR=y
++CONFIG_NET_RANDOM_ETHADDR=y
++CONFIG_SPL_DM_SEQ_ALIAS=y
++CONFIG_SPL_ALTERA_SDRAM=y
++CONFIG_DWAPB_GPIO=y
++CONFIG_MISC=y
++CONFIG_MISC_INIT_R=y
++CONFIG_SPI_FLASH_SPANSION=y
++CONFIG_SPI_FLASH_STMICRO=y
++CONFIG_SPI_FLASH_MTD=y
++CONFIG_SPL_MTD=y
++CONFIG_PHY_MARVELL=y
++CONFIG_PHY_GIGE=y
++CONFIG_DWC_ETH_XGMAC=y
++CONFIG_DWC_ETH_XGMAC_SOCFPGA=y
++CONFIG_ETH_DESIGNWARE=y
++CONFIG_ETH_DESIGNWARE_SOCFPGA=y
++CONFIG_RGMII=y
++CONFIG_SYS_NS16550=y
++CONFIG_SYS_NS16550_MEM32=y
++CONFIG_SPI=y
++CONFIG_CADENCE_QSPI=y
++CONFIG_DESIGNWARE_SPI=y
++CONFIG_DM_SPI=y
++CONFIG_SPI_MEM=y
++CONFIG_TIMER=y
++CONFIG_DESIGNWARE_APB_TIMER=y
++CONFIG_USB=y
++CONFIG_DM_USB=y
++CONFIG_SPL_DM_USB=y
++CONFIG_USB_XHCI_HCD=y
++CONFIG_USB_XHCI_DWC3=y
++CONFIG_USB_DWC2=y
++CONFIG_USB_DWC3=y
++CONFIG_USB_HUB_DEBOUNCE_TIMEOUT=3000
++CONFIG_USB_STORAGE=y
++CONFIG_PANIC_HANG=y
++CONFIG_SPL_CRC32=y
++CONFIG_SPL_CRYPTO=y
++CONFIG_RSA=y
++CONFIG_SPL_RSA=y
++CONFIG_SPL_RSA_VERIFY=y
++CONFIG_RSA_VERIFY=y
++CONFIG_SHA1=y
++CONFIG_SHA256=y
++CONFIG_MD5=y
++CONFIG_LZ4=y
++CONFIG_LZMA=y
++CONFIG_GZIP=y
++CONFIG_ZLIB=y
++CONFIG_OF_CONTROL=y
++CONFIG_SPL_OF_CONTROL=y
++CONFIG_OF_REAL=y
++CONFIG_SPL_OF_REAL=y
++CONFIG_SPL_SYS_DCACHE_OFF=y
++CONFIG_SPL_BSS_LIMIT=y
++CONFIG_SPL_BINMAN_SYMBOLS=y
++CONFIG_SPL_BINMAN_UBOOT_SYMBOLS=y
++CONFIG_SPL_SEPARATE_BSS=y
++CONFIG_SPL_SYS_MMCSD_RAW_MODE=y
++CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR=0x200
++CONFIG_SPL_SPI_FLASH_TINY=y
++CONFIG_SPL_SOCFPGA_SEC_REG=y
++CONFIG_SPL_SOCFPGA_DT_REG=y
++CONFIG_SYS_MALLOC_F=y
++CONFIG_SYS_MALLOC_F_LEN=0x2000
++CONFIG_BOOTM_LINUX=y
++CONFIG_BOOTM_NETBSD=y
++CONFIG_BOOTM_PLAN9=y
++CONFIG_BOOTM_RTEMS=y
++CONFIG_BOOTM_VXWORKS=y
++CONFIG_CMD_BOOTM=y
++CONFIG_CMD_BOOTI=y
++CONFIG_CMD_FDT=y
++CONFIG_CMD_ELF=y
++CONFIG_CMD_XIMG=y
++CONFIG_CMD_EXPORTENV=y
++CONFIG_CMD_IMPORTENV=y
++CONFIG_CMD_EDITENV=y
++CONFIG_CMD_DM=y
++CONFIG_CMD_FPGA=y
++CONFIG_FPGA=y
++CONFIG_FPGA_ALTERA=y
++CONFIG_FPGA_INTEL_SDM_MAILBOX=y
++CONFIG_NET=y
++CONFIG_DM_ETH=y
++CONFIG_BOOTDEV_ETH=y
++CONFIG_CMD_DHCP=y
++CONFIG_CMD_MII=y
++CONFIG_CMD_MDIO=y
++CONFIG_CMD_PING=y
++CONFIG_CMD_TFTPBOOT=y
++CONFIG_CMD_PXE=y
++CONFIG_BOOTP_PXE=y
++CONFIG_SYS_RX_ETH_BUFFER=4
++CONFIG_MTD_PARTITIONS=y
++CONFIG_MTD=y
++CONFIG_DM_SPI_FLASH=y
++CONFIG_SPI_FLASH=y
++CONFIG_SPI_FLASH_LOCK=y
++CONFIG_SPI_FLASH_UNLOCK_ALL=y
++CONFIG_SYSRESET=y
++CONFIG_SPL_SYSRESET=y
++CONFIG_SYSRESET_SOCFPGA_AGILEX5=y
++CONFIG_SYSRESET_CMD_RESET=y
++CONFIG_BOOTMETH_EXTLINUX=y
++CONFIG_BOOTMETH_EXTLINUX_PXE=y
++CONFIG_BOOTMETH_VBE=y
++CONFIG_BOOTMETH_VBE_REQUEST=y
++CONFIG_BOOTMETH_VBE_SIMPLE=y
++CONFIG_BOOTMETH_VBE_SIMPLE_OS=y
++CONFIG_PSCI_RESET=y
++CONFIG_LMB=y
++CONFIG_LIB_UUID=y
++CONFIG_LIB_ELF=y
++CONFIG_DTOC=y
++CONFIG_BINMAN=y
++CONFIG_BINMAN_FDT=y
++CONFIG_SPL_IMAGE="spl/u-boot-spl.bin"
++CONFIG_SPL_PAYLOAD="u-boot.bin"
++CONFIG_ARMV8_PSCI_NR_CPUS=4
++CONFIG_SOCFPGA_RSU_MULTIBOOT=y
++CONFIG_IMAGE_SIGN_INFO=y
++CONFIG_SPL_IMAGE_SIGN_INFO=y
+diff -Naur --no-dereference '--exclude=.git' A/drivers/i2c/i2c-uclass.c B/drivers/i2c/i2c-uclass.c
+--- A/drivers/i2c/i2c-uclass.c	2025-12-09 11:50:06.602600407 +0530
++++ B/drivers/i2c/i2c-uclass.c	2025-12-09 16:47:52.211686638 +0530
+@@ -750,7 +750,7 @@
+ 	struct dm_i2c_bus *i2c = dev_get_uclass_priv(dev);
+ 
+ 	i2c->speed_hz = dev_read_u32_default(dev, "clock-frequency",
+-					     I2C_SPEED_STANDARD_RATE);
++					     I2C_SPEED_FAST_RATE);
+ 
+ 	return dm_i2c_set_bus_speed(dev, i2c->speed_hz);
+ #else
+diff -Naur --no-dereference '--exclude=.git' A/drivers/misc/fru_eeprom.c B/drivers/misc/fru_eeprom.c
+--- A/drivers/misc/fru_eeprom.c	1970-01-01 05:30:00.000000000 +0530
++++ B/drivers/misc/fru_eeprom.c	2025-12-09 16:47:52.213686666 +0530
+@@ -0,0 +1,938 @@
++#include <errno.h>
++#include <command.h>
++#include <i2c.h>
++#include <iG_fru.h>
++#include <stdlib.h>
++#include <ctype.h> 
++#include <vsprintf.h>
++
++#define DUMP_BOARD     (0x01)
++#define DUMP_SUPPLY    (0x02)
++#define DUMP_CONNECTOR (0x04)
++#define DUMP_I2C       (0x08)
++
++unsigned char fmc_eeprom_buf[1024];
++static uchar i2c_fmc_last_bus = 1;
++static uint i2c_fmc_last_chip = 0x50;
++
++struct fmc_voltage {
++	int nominal_volt;
++	int minimum_volt;
++	int maximum_volt;
++};
++
++void * x_calloc (size_t nmemb, size_t size)
++{
++        unsigned int *ptr;
++
++        ptr = calloc(nmemb, size);
++        if (ptr == NULL)
++                printf_err("memory error - calloc returned zero\n");
++
++        return (void *)ptr;
++}
++
++/*
++ * FRU information uses a zero checksum everywhere.
++ * The modulo 256 sum of the preceding bytes (starting with the first byte
++ * of the header) plus the checksum byte equals zero.
++ * Platform Management FRU Information Storage Definition : section 16.2.[56]
++ */
++unsigned char calc_zero_checksum (unsigned char *data, size_t len)
++{
++        size_t i;
++        unsigned char tmp = 0;
++
++        for (i = 0; i <= len; i++)
++                tmp += data[i];
++
++        return tmp;
++}
++
++#ifdef DEBUG
++/*
++ * Used for debugging
++ */
++static void dump_str(unsigned char * p, unsigned int size, unsigned int space)
++{
++        size_t i, j = 0, k, m, shift;
++        unsigned char *t, this = 0, last = 0;
++
++        t = p;
++        k = 8 - space;
++        for (i = 0; i < size; i++) {
++                m = 0;
++                printf("%02zi: %02x : ", i, *t);
++                last = this;
++                this = *t;
++                for (shift = 0x80; shift > 0; shift >>= 1) {
++                        printf("%s", ((*t & shift) == shift) ? "1" : "0");
++                        j++, m++;
++                        if(k == m) {
++                                printf(" ");
++                                k = 8 - space + m;
++                                if (k >= 8)
++                                        k -= space;
++                                m = space + 100;
++                        }
++                }
++                if (space == 8) {
++                        if (*t)
++                                printf(" (%c) %02x", *t, *t - 0x20);
++                        else
++                                printf(" (term) NULL");
++                }
++                if (space == 6) {
++                        unsigned char x = 0, y = 0;
++
++                        if (k == 2) {
++                                y = (this >> 2) & 0x3F;
++                                x = (last >> 4) | ((this & 0x3) << 4);
++                        } else if (k == 4) {
++                                x = this & 0x3F;
++                        } else if (k == 6) {
++                                x = (last >> 6) | ((this & 0xF) << 2);
++                        }
++
++                        if (k == 4 || k == 6)
++                                printf(" (%02x) %02x '%c'", x , x + 0x20, x + 0x20);
++                        if (k == 2)
++                                printf(" (%02x) %02x '%c' | (%02x) %02x '%c'", x , x + 0x20, x + 0x20, y , y + 0x20, y + 0x20);
++                }
++                ++t;
++                printf("\n");
++        }
++}
++#else
++static void dump_str(unsigned char * UNUSED(p), unsigned int UNUSED(size), unsigned int UNUSED(space))
++{
++        return;
++}
++#endif
++
++/*
++ * 6-bit ASCII Packing
++ * Platform Management FRU Information Storage Definition:  Section 13.[23]
++ */
++int ascii2six(unsigned char **dest, unsigned char *src, size_t size)
++{
++        size_t i = 0;
++        ssize_t j;
++        unsigned int k, m = 0;
++        unsigned char *p, *d, *e;
++
++        if (!src || !size)
++                return 0;
++
++        e = d = x_calloc(1, size);
++
++        p = src;
++        /*
++         * 6-bit requires uppercase chars, between 0 and 0x3f
++         */
++        while (*p != '\0' && i <= size) {
++                j = toupper(*p) - 0x20;
++                if (j < 0 || j >= 0x40) {
++                        printf_warn("%s : trying to convert a string '%s'\n"
++                                        "\t\twhich includes char '%c (0x%x)', which can't be converted\n",
++                                        __func__, src, *p, *p);
++                        free(e);
++                        return -1;
++                }
++                *d = j;
++                ++p, ++d, i++;
++        }
++        /* dump_str(d, size, 4); */
++
++        /* the length of dest, should be 3/4 of size, it's zero padded at the end */
++        *dest = x_calloc(1, size + 1);
++        p = *dest;
++
++        for (i = 0; i <= size ; i+= 4) {
++                k = e[i];
++                m++;
++                if ((i + 1) < size) {
++                        k |= e[i + 1] << 6;
++                        m++;
++                }
++                if ((i + 2) < size) {
++                        k |= e[i + 2] << 12;
++                       m++;
++                }
++                if ((i + 3) < size) {
++                        k |= e[i + 3] << 18;
++                }
++#ifndef __MINGW32__
++#if __BYTE_ORDER == __BIG_ENDIAN
++                k = __bswap_32(k);
++#endif
++#endif
++                memcpy(p, &k, 3);
++                p += 3;
++        }
++
++        /* dump_str(*dest, m, 6); */
++        free (e);
++
++        return  m;
++}
++
++/*
++ *  * 6-bit ASCII Unpacking
++ *   * Platform Management FRU Information Storage Definition:  Section 13.[23]
++ */
++unsigned char * six2ascii(unsigned char *buf, size_t size)
++{
++        unsigned char *p, *dest;
++        size_t i;
++
++        if (!size)
++                return NULL;
++
++        dump_str(buf, size, 6);
++        /* the length of dest, should be 4/3 of size + 1 for null termination char*/
++        dest = x_calloc(1, ((size * 4) / 3) + 2);
++        p = dest;
++
++        for (i = 0; i < size; i += 3) {
++                *dest = (buf[i] & 0x3F) + 0x20;
++                dest++;
++                if ((i + 1) < size) {
++                        *dest = ((buf[i] & 0xC0) >> 6 | (buf[i+1] & 0x0F) << 2) + 0x20;
++                        dest++;
++                }
++                if ((i + 2) < size) {
++                        *dest = ((buf[i+1] & 0xF0) >> 4 | (buf[i+2] & 0x03) << 4) + 0x20;
++                        dest++;
++                }
++                if ((i + 3) < size) {
++                        *dest = ((buf[i+2] & 0xFC) >> 2) + 0x20;
++                        dest++;
++                }
++        }
++        /* make sure strings are null terminated */
++        *dest = 0;
++
++        /* Drop trailing spaces & null chars */
++        dest--;
++        while ((*dest == 0 || *dest == ' ') && size) {
++                *dest = 0;
++                dest--;
++                size--;
++        }
++
++        return p;
++}
++
++
++/*
++ * Extract strings from fields
++ * Section 13 TYPE/LENGTH BYTE FORMAT
++ * Platform Management FRU Information Storage Definition
++ */
++unsigned int parse_string(unsigned char *p, unsigned char **str, const char * field)
++{
++        size_t len, i, j;
++
++        len = p[0] & 0x3F;
++
++        if (!len) {
++                *str = x_calloc(1, 3);
++                *str[0] = (FRU_STRING_ASCII << 6);
++                return 1;
++        }
++
++        switch((p[0] >> 6) & 0x3 ) {
++                case FRU_STRING_BINARY:
++                        /* binary or unspecified */
++                        *str = x_calloc(1, len + 2);
++                        memcpy(*str, p, len + 1);
++                        break;
++                case FRU_STRING_BCD:
++                        /* BCD plus */
++                        printf_err("BCD - sorry\n");
++                        break;
++                case FRU_STRING_SIXBIT:
++                        /* 6-bit ASCII, packed */
++                        {
++                                unsigned char *tmp1, *tmp2;
++                                size_t tlen;
++
++                                tmp1 = six2ascii(&p[1], p[0]& 0x3F);
++                                tlen = strlen((char *)tmp1);
++                                *str = x_calloc(1, tlen + 2);
++
++                                tmp2 = *str;
++                                tmp2++;
++                                memcpy(tmp2, tmp1, tlen + 1);
++                                if (tlen > 0x3F)
++                                        tlen = 0x3F;
++
++                                *str[0] = (FRU_STRING_ASCII << 6) | tlen;
++                                free(tmp1);
++                        }
++                        break;
++                case FRU_STRING_ASCII:
++                        /* 8-bit ASCII */
++                        *str = x_calloc(1, len + 2);
++                        memcpy(*str, p, len + 1);
++                        for (i = 1; i < len; i++) {
++                                if (p[i] < 0x20 || p[i] == 0x7F) {
++                                        printf_warn("Field '%s' marked as ASCII, but contains non-printable "
++                                                        "characters:\n", field);
++                                        printf_warn("  Length/Type : 0x%x (length:%i; type:ASCII(%i)\n",
++                                                        p[0], p[0] & 0x3F, FRU_STRING_ASCII);
++                                        printf_warn("  Contents : ");
++                                        for (j = 1; j < len + 1; j++)
++                                                printf_warn("0x%02x ", p[j]);
++                                        printf_warn(" |");
++                                        for (j = 0; j < len + 1; j++)
++                                                printf_warn("%c", ((p[j] < 32) || (p[j] >= 127)) ? '.': p[j]);
++                                        printf_warn("|\n");
++                                }
++                        }
++                        break;
++        }
++        return len + 1;
++}
++
++
++
++void printf_err (const char * fmt, ...)
++{
++        va_list ap;
++        va_start(ap,fmt);
++        vprintf(fmt,ap);
++        va_end(ap);
++}
++
++void printf_warn (const char * fmt, ...)
++{
++        va_list ap;
++
++        va_start(ap,fmt);
++        vprintf(fmt,ap);
++        va_end(ap);
++}
++
++void printf_info (const char * fmt, ...)
++{
++        va_list ap;
++
++        va_start(ap,fmt);
++        vprintf(fmt,ap);
++        va_end(ap);
++}
++
++
++
++static void dump_fru_field(const char * description, size_t offset, unsigned char * field)
++{
++        /* does field exist, and have length? */
++        if (field) {
++                printf("%s\t: ", description);
++                if (FIELD_LEN(field)) {
++                        if (TYPE_CODE(field) == FRU_STRING_ASCII || offset) {
++                                printf("%s\n", &field[offset + 1]);
++                        } else {
++                                printf("Non-ASCII\n");
++                        }
++                } else
++                        printf("Empty Field\n");
++        }
++}
++
++void dump_BOARD(struct BOARD_INFO *fru)
++{
++        unsigned int i, j;
++
++        dump_fru_field("Manufacturer", 0, fru->manufacturer);
++        dump_fru_field("Product Name", 0, fru->product_name);
++        dump_fru_field("Serial Number", 0, fru->serial_number);
++        dump_fru_field("Part Number", 0, fru->part_number);
++        dump_fru_field("FRU File ID", 0, fru->FRU_file_ID);
++
++        if (!strncasecmp((const char *)&fru->manufacturer[1], "Analog Devices", strlen("Analog Devices"))) {
++                for (i = 0; i < CUSTOM_FIELDS; i++) {
++                        /* These are ADI custom fields */
++                        if (fru->custom[i] && fru->custom[i][0] & 0x3F) {
++                                switch (fru->custom[i][1]) {
++                                        case 0:
++                                                dump_fru_field("PCB Rev ", 1, fru->custom[i]);
++                                                break;
++                                        case 1:
++                                                dump_fru_field("PCB ID  ", 1, fru->custom[i]);
++                                                break;
++                                        case 2:
++                                                dump_fru_field("BOM Rev ", 1, fru->custom[i]);
++                                                break;
++                                        case 3:
++                                                dump_fru_field("Uses LVDS", 1, fru->custom[i]);
++                                                break;
++                                        case 4:
++                                                dump_fru_field("Tuning  ", 1, fru->custom[i]);
++                                                break;
++                                        default:
++                                                dump_fru_field("Unknown ", 1, fru->custom[i]);
++                                                break;
++                                }
++                        }
++                }
++        } else {
++                printf("Custom Fields:\n");
++                for (i = 0; i < CUSTOM_FIELDS; i++) {
++                        if (fru->custom[i] && fru->custom[i][0] & 0x3F) {
++                                printf("  Field %i (len=%i):", i, fru->custom[i][0] & 0x3F);
++                                for (j = 1 ; j <= (fru->custom[i][0] & 0x3F); j++)
++                                        printf(" %02x", fru->custom[i][j] & 0xFF);
++                                printf("  |");
++                                for (j = 1 ; j <= (fru->custom[i][0] & 0x3F); j++)
++                                        printf("%c", ((fru->custom[i][j] < 32) || (fru->custom[i][j] >= 127)) ? '.': fru->custom[i][j]);
++                                printf("|\n");
++                        }
++                }
++        }
++}
++
++/*
++ * DC Load and DC Output Multi-record Definitions
++ * Table 8 from the VITA/ANSI 57.1 Spec
++ */
++const char * DC_Loads[] = {
++        "P1 VADJ",                      /* Load   :  0 */
++        "P1 3P3V",                      /* Load   :  1 */
++        "P1 12P0V",                     /* Load   :  2 */
++        "P1 VIO_B_M2C",                 /* Output :  3 */
++        "P1 VREF_A_M2C",                /* Output :  4 */
++        "P1 VREF_B_M2C",                /* Output :  5 */
++        "P2 VADJ",                      /* Load   :  6 */
++        "P2 3P3V",                      /* Load   :  7 */
++        "P2 12P0V",                     /* Load   :  8 */
++        "P2 VIO_B_M2C",                 /* Load   :  9 */
++        "P2 VREF_A_M2C",                /* Load   : 10 */
++        "P2 VREF_B_M2C",                /* Load   : 11 */
++};
++
++void dump_MULTIRECORD (struct MULTIRECORD_INFO *fru)
++{
++        unsigned char *p, *n, *z;
++        int i;
++
++        z = x_calloc(1, 12);
++
++        for (i= 0; i <= NUM_SUPPLIES - 1; i++) {
++                if (!fru->supplies[i])
++                        continue;
++                p = fru->supplies[i];
++                n = p + 5;
++                switch(p[0]) {
++                        case 1:
++                                printf("DC Output\n");
++                                printf("  Output Number: %d (%s)\n", n[0] & 0xF, DC_Loads[n[0] & 0xF]);
++                                if (memcmp(&n[1], z, 11)) {
++                                        printf("  Nominal volts:              %d (mV)\n", (n[ 1] | (n[ 2] << 8)) * 10);
++                                        printf("  Maximum negative deviation: %d (mV)\n", (n[ 3] | (n[ 4] << 8)) * 10);
++                                        printf("  Maximum positive deviation: %d (mV)\n", (n[ 5] | (n[ 6] << 8)) * 10);
++                                        printf("  Ripple and Noise pk-pk:     %d (mV)\n",  n[ 7] | (n[ 8] << 8));
++                                        printf("  Minimum current draw:       %d (mA)\n",  n[ 9] | (n[10] << 8));
++                                        printf("  Maximum current draw:       %d (mA)\n",  n[11] | (n[12] << 8));
++                                } else
++                                        printf("  All Zeros\n");
++                                break;
++                        case 2:
++                                printf("DC Load\n");
++                                printf("  Output number: %d (%s)\n", n[0] & 0xF, DC_Loads[n[0] & 0xF]);
++                                printf("  Nominal Volts:         %04d (mV)\n", (n[ 1] | (n[ 2] << 8)) * 10);
++                                printf("  minimum voltage:       %04d (mV)\n", (n[ 3] | (n[ 4] << 8)) * 10);
++                                printf("  maximum voltage:       %04d (mV)\n", (n[ 5] | (n[ 6] << 8)) * 10);
++                                printf("  Ripple and Noise pk-pk %04d (mV)\n",  n[ 7] | (n[ 8] << 8));
++                                printf("  Minimum current load   %04d (mA)\n",  n[ 9] | (n[10] << 8));
++                                printf("  Maximum current load   %04d (mA)\n",  n[11] | (n[12] << 8));
++                                break;
++                }
++        }
++        free (z);
++
++}
++
++void dump_FMConnector (struct MULTIRECORD_INFO *fru)
++{
++
++        unsigned char *p, *n;
++
++        if (!fru->connector) {
++                printf("No Connector information\n");
++                return;
++        }
++
++        p = fru->connector;
++        n = p + 5;
++
++        n += 3;
++        switch (n[1]>>6) {
++                case 0:
++                        printf("Single Width Card\n");
++                        break;
++                case 1:
++                        printf("Double Width Card\n");
++                        break;
++                default:
++                        printf("error - not the right size\n");
++                        break;
++        }
++        switch ((n[1] >> 4) & 0x3) {
++                case 0:
++                        printf("P1 is LPC\n");
++                        break;
++                case 1:
++                        printf("P1 is HPC\n");
++                        break;
++                default:
++                        printf("P1 not legal size\n");
++                        break;
++        }
++        switch ((n[1] >> 2) & 0x3) {
++                case 0:
++                        printf("P2 is LPC\n");
++                        break;
++                case 1:
++                        printf("P2 is HPC\n");
++                        break;
++                case 3:
++                        if (n[1]>>6 != 0)
++                                printf("P2 is not populated\n");
++                        break;
++                default:
++                        printf("P2 not legal size\n");
++                        break;
++        }
++        printf("P1 Bank A Signals needed %d\n", n[2]);
++        printf("P1 Bank B Signals needed %d\n", n[3]);
++        printf("P1 GBT Transceivers needed %d\n", n[6] >> 4);
++        if (((n[1] >> 2) & 0x3) != 3) {
++                printf("P2 Bank A Signals needed %d\n", n[4]);
++                printf("P2 Bank B Signals needed %d\n", n[5]);
++                printf("P2 GBT Transceivers needed %d\n", n[6] & 0xF);
++        }
++        printf("Max JTAG Clock %d\n", n[7]);
++
++}
++
++/*
++ * Read in the file of the disk, or from the EEPROM
++ */
++int read_fmc_eeprom(int i2c_bus, int chip_addr)
++{
++        size_t tmp;
++        int i = 0, ret;
++	struct udevice *dev;
++
++
++        ret = i2c_get_chip_for_busnum(i2c_bus, chip_addr, 1, &dev);
++        if(ret) {
++                return -1;
++        }
++
++	tmp = dm_i2c_read (dev, 0, fmc_eeprom_buf, 1024); 
++
++        /*
++         * If an error  occurs,  or the  end-of-file is reached,
++         * the return value is a short item count (or zero).
++         */
++        if (tmp == 0)
++                for (i = 1023; fmc_eeprom_buf[i] == 0; i--);
++        return i+1;
++}
++
++struct BOARD_INFO * parse_board_area(unsigned char *data)
++{
++
++	 struct BOARD_INFO *fru;
++        unsigned char *p;
++        unsigned int len, i, j;
++
++	fru = x_calloc(1, sizeof(struct BOARD_INFO));
++
++        if (data[0] != 0x01) {
++                printf_err("Board Area Format Version mismatch: 0x%02x should be 0x01\n", data [0]);
++                goto err;
++        }
++
++        len = (data[1] * 8) - 1;
++        if (calc_zero_checksum(data, len)) {
++                printf_err("Board Area Checksum failed\n");
++                goto err;
++        }
++
++        if (data[2] != 0 && data[2] != 25) {
++                printf_err("Board Area is non-English - sorry: Lang code = %i\n", data[2]);
++                goto err;
++        }
++
++        len--;
++        while ((data[len] == 0x00) && (len != 0))
++                len--;
++        if (len == 0 || data[len] != 0xC1) {
++                printf_err("BOARD INFO not terminated properly, walking backwards len: "
++                                "%i:0x%02x should be 0xC1\n", len, data[len]);
++                goto err;
++        }
++
++        fru->mfg_date = data[3] | (data[4] << 8) | (data[5] << 16);
++
++        p = &data[6];
++        len -= 6;
++
++        i = parse_string(p, &fru->manufacturer, "Manufacturer");
++        p += i, len -= i;
++
++        i = parse_string(p, &fru->product_name, "Product Name");
++        p += i, len -= i;
++
++        i = parse_string(p, &fru->serial_number, "Serial Number");
++        p += i, len -= i;
++
++        i = parse_string(p, &fru->part_number, "Part Number");
++        p += i, len -= i;
++
++        i = parse_string(p, &fru->FRU_file_ID, "FRU File ID");
++        p += i, len -= i;
++
++        j = 0;
++        while (len != 0 && j < CUSTOM_FIELDS) {
++                i = parse_string(p, &fru->custom[j], "Custom Field");
++                p += i, len -= i, j++;
++        }
++
++        if (*p != 0xC1) {
++                printf_err("BOARD INFO not terminated properly, "
++                                "offset %02i(0x%02x) : %02i(0x%02x) should be 0xC1\n",
++                                p - data, p - data, *p, *p);
++                goto err;
++        }
++
++        return fru;
++
++err:
++        free(fru->manufacturer);
++        free(fru->product_name);
++        free(fru->serial_number);
++        free(fru->part_number);
++        free(fru->FRU_file_ID);
++        for( j = 0; j < CUSTOM_FIELDS; j++)
++                free(fru->custom[j]);
++        free(fru);
++        return NULL;
++}
++
++/*
++ * Each record in this area begins with a pre-defined header as specified in the
++ * section 16 in the Platform Management FRU Information Storage Definition.
++ * This header contains a Type field that identifies what information is
++ * contained in the record.  * There are some FMC specific headers, defined
++ * in section 5.5.1 of the FMC specification "IPMI Support". These FMC specific
++ * sections have a 1 byte sub-type, and a 3 byte Unique Organization Identifier
++ */
++struct MULTIRECORD_INFO * parse_multiboard_area(unsigned char *data)
++{
++        int i = 0, tmp, type;
++        unsigned char *p;
++	struct MULTIRECORD_INFO *multi;
++
++        multi = x_calloc(1, sizeof(struct MULTIRECORD_INFO));
++
++        p = data;
++
++        do {
++                if (i != 0){
++                        p += 5 + p[2];
++                }
++                if (p[0] >= 0x06 && p[0] <= 0xBF) {
++                        printf_err("MultiRecord Area %i: Invalid Record Header\n", i);
++                        return NULL;
++                }
++                if (calc_zero_checksum(p, 4)) {
++                        printf_err("MultiRecord Area %i (Record Type 0x%x): "
++                                        "Header Checksum failed\n", i, p[0]);
++                        return NULL;
++                }
++
++                if (!p[2] || ((calc_zero_checksum(p+5, p[2] - 1) + p[3]) & 0xFF)) {
++                        printf_err("MultiRecord Area %i (Record Type 0x%x): "
++                                        "Record Checksum failed\n", i, p[0]);
++                        return NULL;
++                }
++
++                /*
++                 * Record Type ID
++                 */
++                switch(p[0]) {
++                        case MULTIRECORD_DC_OUTPUT:
++                        case MULTIRECORD_DC_INPUT:
++                                tmp = p[5] & 0xF;
++                                if ((tmp) >= NUM_SUPPLIES)
++                                        printf_err("Too many Supplies defined in Multirecords\n");
++
++                                multi->supplies[tmp] = x_calloc(1, p[2] + 6);
++                                memcpy (multi->supplies[tmp], p, p[2] + 6);
++                                multi->supplies[tmp][1] = multi->supplies[tmp][1] & 0x7F;
++                                break;
++                        case MULTIRECORD_FMC:
++                                /*
++                                 * Use VITA's OUI: 0x0012a2 is specified in the FMC spec - Rule 5.77
++                                 */
++                                if ((p[5] | p[6] << 8 | p[7] << 16) != VITA_OUI) {
++                                        printf_err("OUI Doesn't match : is 0x%06X, "
++                                                "should be 0x%06x\n", p[5] | p[6] << 8 | p[7] << 16, VITA_OUI);
++                                }
++                                /* type field is located: Header + Manufacturer ID = 5 + 3 */
++                                type = p[8] >> 4;
++
++                                switch (type) {
++                                        case MULTIRECORD_CONNECTOR:
++                                                /* see table 7 in FMC spec */
++                                                multi->connector = x_calloc(1, p[2] + 6);
++                                                memcpy (multi->connector, p, p[2] + 6);
++                                                /* This isn't the end 'til we re-assemble things */
++                                                multi->connector[1] = multi->connector[1] & 0x7F;
++                                                break;
++                                        case MULTIRECORD_I2C:
++                                                if (p[2] <= 5) {
++                                                        printf_warn("I2C MultiRecord is too short (len:%i)\n"
++                                                                "       (at least 4 is needed for OUI and subtype)\n",
++                                                                p[2]);
++                                                } else {
++                                                        /* see table 9 in FMC spec */
++                                                        unsigned char *foo2;
++                                                        foo2 = six2ascii(&p[9], p[2] - 4);
++
++                                                        multi->i2c_devices = x_calloc(1, strlen((char *)foo2) + 1);
++                                                        strcpy ((char *)multi->i2c_devices, (char *)foo2);
++                                                        free(foo2);
++                                                        /* This isn't the end 'til we re-assemble things */
++                                                        multi->i2c_devices[1] = multi->i2c_devices[1] & 0x7F;
++                                                }
++                                                break;
++                                        default:
++                                                printf_err("Unknown multirecord type : %i\n", type);
++                                                break;
++                                }
++
++                                if (type == 1) {
++
++                                }
++                                break;
++                        default:
++                                printf_err("Unknown MultiRecord Area\n");
++                }
++
++                i++;
++        } while (!(p[1] & 0x80));
++
++        return multi;
++}
++
++/*
++ * Common Header Format
++ * Section 8 in the Platform Management FRU Information Storage Definition
++ */
++struct FRU_DATA * parse_FRU (unsigned char *data)
++{
++	struct FRU_DATA *fru;
++
++        fru = x_calloc (1, sizeof(struct FRU_DATA));
++
++        /* Check FRU version */
++        if (data[0] != 0x01) {
++                printf_err("FRU Version number mismatch 0x%02x should be 0x01\n", data[0]);
++                goto err;
++        }
++
++        /* Check Padding */
++        if (data[6] != 0x00) {
++                printf_err("FRU byte 6 should be PAD, and be zero -- but it's not\n");
++                goto err;
++        }
++
++        /* Check header checksum */
++        if (calc_zero_checksum(data, 7)) {
++                printf_err("Common Header Checksum failed\n");
++                goto err;
++        }
++
++        /* Parse Internal Use Area */
++        if (data[1]) {
++                printf_err("Internal Use Area not yet implemented - sorry\n");
++                goto err;
++        }
++
++        /* Parse Chassis Info Area */
++        if (data[2]) {
++                printf_err("Chassis Info Area not yet implmented - sorry\n");
++                goto err;
++        }
++
++	/* Parse Board Area */
++	if (data[3]) {
++                fru->Board_Area = parse_board_area(&data[data[3] * 8]);
++                if (!fru->Board_Area)
++                        goto err;
++	}
++        /* Parse Chassis Info Area */
++        if (data[4]) {
++                printf_err("Chassis Info Area parsing not yet implemented - sorry\n");
++                goto err;
++        }
++
++        /* Parse MultiRecord Area */
++        if (data[5]){
++		fru->MultiRecord_Area = parse_multiboard_area(&data[data[5] * 8]);
++        }
++
++        return fru;
++
++err:
++        free(fru);
++        return NULL;
++
++}
++
++void free_FRU(struct FRU_DATA *fru)
++{
++        int j;
++
++        free(fru->Board_Area->manufacturer);
++        free(fru->Board_Area->product_name);
++        free(fru->Board_Area->serial_number);
++        free(fru->Board_Area->part_number);
++        free(fru->Board_Area->FRU_file_ID);
++        for(j = 0; j < CUSTOM_FIELDS; j++)
++                free(fru->Board_Area->custom[j]);
++        free(fru->Board_Area);
++
++        for(j = 0; j < NUM_SUPPLIES; j++)
++                free(fru->MultiRecord_Area->supplies[j]);
++        free(fru->MultiRecord_Area->i2c_devices);
++
++        free(fru->MultiRecord_Area->connector);
++        free(fru->MultiRecord_Area);
++
++        free(fru);
++
++}
++
++void parse_fmc_volt (struct MULTIRECORD_INFO *fru, struct fmc_voltage *fmc_volt)
++{
++	unsigned char *p, *n, *z;
++	int i;
++
++	z = x_calloc(1, 12);
++
++	for (i= 0; i <= NUM_SUPPLIES - 1; i++) {
++		if (!fru->supplies[i])
++			continue;
++		p = fru->supplies[i];
++		n = p + 5;
++		if (p[0] == 2 ){
++			if ((n[0] & 0xF) == 0){
++				fmc_volt->nominal_volt = (n[ 1] | (n[ 2] << 8)) * 10;
++				fmc_volt->minimum_volt = (n[ 3] | (n[ 4] << 8)) * 10;
++				fmc_volt->maximum_volt = (n[ 5] | (n[ 6] << 8)) * 10;
++			}
++		}
++	}
++	free (z);
++
++}
++
++
++int fmc_vadj_support (int i2c_bus, int i2c_address, u32 vadj_volt)
++{
++	struct FRU_DATA *fru = NULL;
++	struct fmc_voltage fmc_volt;
++
++	if (!read_fmc_eeprom(i2c_bus, i2c_address)){
++		printf (" FMC EEPROM Read Failed...\n");
++		return -1;
++	}
++
++	fru = parse_FRU(fmc_eeprom_buf);
++
++	if (fru) {
++		parse_fmc_volt (fru->MultiRecord_Area, &fmc_volt);
++		free_FRU(fru);
++
++		if ((fmc_volt.minimum_volt < vadj_volt) && (fmc_volt.maximum_volt > vadj_volt)){
++			return 1;
++		} 
++	}
++	return 0;
++}
++
++/**
++ * do_fru_dump() - Handle the "frudump" command-line command
++ * @cmdtp:      Command data struct pointer
++ * @flag:       Command flag
++ * @argc:       Command-line argument count
++ * @argv:       Array of command-line arguments
++ *
++ * Returns zero on success, CMD_RET_USAGE in case of misuse and negative
++ * on error.
++ */
++static int do_fru_dump(struct cmd_tbl *cmdtp, int flag, int argc, char * const argv[])
++{
++	struct FRU_DATA *fru = NULL;
++	u_char  bus;
++	uint    chip;
++
++	/* We use the last specified parameters, unless new ones are
++	 * entered.
++	 */
++	bus   = i2c_fmc_last_bus;
++	chip   = i2c_fmc_last_chip;
++
++	if (argc != 3)
++		return CMD_RET_USAGE;
++
++	if ((flag & CMD_FLAG_REPEAT) == 0) {
++		/*
++		 * New command specified.
++		 */
++
++		/*
++		 * I2C Bus Number
++		 */
++		bus = simple_strtoul(argv[1], NULL, 16);
++
++		/*
++		 * I2C Chip address 
++		 */
++		chip = simple_strtoul(argv[2], NULL, 16);
++
++	}
++
++	if (!read_fmc_eeprom(bus, chip)){
++		printf (" FMC EEPROM Read Failed...\n");
++		return -1;
++	}
++
++	fru = parse_FRU(fmc_eeprom_buf);
++
++	if (fru) {
++
++		dump_BOARD(fru->Board_Area);
++
++		dump_MULTIRECORD(fru->MultiRecord_Area);
++
++		dump_FMConnector(fru->MultiRecord_Area);
++
++		free_FRU(fru);
++	}
++
++	i2c_fmc_last_bus  = bus;
++	i2c_fmc_last_chip = chip;
++
++	return 0;
++}
++
++U_BOOT_CMD(frudump, 3, 1, do_fru_dump, "Dump FMC Card Details", "fru-dump <i2c Bus No> <Chip Address>");
+diff -Naur --no-dereference '--exclude=.git' A/drivers/misc/Kconfig B/drivers/misc/Kconfig
+--- A/drivers/misc/Kconfig	2025-12-09 11:50:06.605600451 +0530
++++ B/drivers/misc/Kconfig	2025-12-09 16:47:52.213686666 +0530
+@@ -578,6 +578,12 @@
+ 	help
+ 	  Enable a generic driver for EEPROMs attached via I2C.
+ 
++config FRU_EEPROM
++	bool "Enable driver for generic FMC+-attached EEPROMs"
++	depends on MISC
++	help
++	  Enable a generic driver for FMC+ EEPROMs attached via I2C.
++
+ 
+ config SPL_I2C_EEPROM
+ 	bool "Enable driver for generic I2C-attached EEPROMs for SPL"
+diff -Naur --no-dereference '--exclude=.git' A/drivers/misc/Makefile B/drivers/misc/Makefile
+--- A/drivers/misc/Makefile	2025-12-09 11:50:06.605600451 +0530
++++ B/drivers/misc/Makefile	2025-12-09 16:47:52.213686666 +0530
+@@ -24,6 +24,7 @@
+ obj-$(CONFIG_USB_HUB_USB251XB) += usb251xb.o
+ endif
+ endif
++obj-$(CONFIG_FRU_EEPROM) += fru_eeprom.o
+ ifdef CONFIG_SPL_OF_PLATDATA
+ ifdef CONFIG_XPL_BUILD
+ obj-$(CONFIG_SANDBOX) += spltest_sandbox.o
+diff -Naur --no-dereference '--exclude=.git' A/include/configs/socfpga_agilex5_iG58m.h B/include/configs/socfpga_agilex5_iG58m.h
+--- A/include/configs/socfpga_agilex5_iG58m.h	1970-01-01 05:30:00.000000000 +0530
++++ B/include/configs/socfpga_agilex5_iG58m.h	2025-12-09 16:47:52.090684967 +0530
+@@ -0,0 +1,12 @@
++/* SPDX-License-Identifier: GPL-2.0
++ *
++ * Copyright (C) 2025 iWave Global <support.ip@iwave-global.com>
++ *
++ */
++
++#ifndef __CONFIG_SOCFGPA_AGILEX5_H__
++#define __CONFIG_SOCFGPA_AGILEX5_H__
++
++#include <configs/socfpga_soc64_common.h>
++
++#endif	/* __CONFIG_SOCFGPA_AGILEX5_H__ */
+diff -Naur --no-dereference '--exclude=.git' A/include/configs/socfpga_soc64_common.h B/include/configs/socfpga_soc64_common.h
+--- A/include/configs/socfpga_soc64_common.h	2025-12-09 11:50:07.168608669 +0530
++++ B/include/configs/socfpga_soc64_common.h	2025-12-09 16:47:52.090684967 +0530
+@@ -131,14 +131,35 @@
+ 
+ #define CFG_EXTRA_ENV_SETTINGS \
+ 	"kernel_addr_r=0x82000000\0" \
+-	"fdt_addr_r=0x86000000\0" \
++	"fdt_addr=0x86000000\0" \
++	"rbf_addr=0x87000000\0" \
+ 	"qspiscriptaddr=0x02110000\0" \
+ 	"scriptsize=0x00010000\0" \
+ 	"qspibootimageaddr=0x02120000\0" \
+ 	"bootimagesize=0x03200000\0" \
+ 	"loadaddr=" __stringify(CONFIG_SYS_LOAD_ADDR) "\0" \
+ 	"bootfile=" CONFIG_BOOTFILE "\0" \
++	"fdtimage=" CONFIG_DEFAULT_DEVICE_TREE ".dtb\0" \
++	"rbffile=IG58m_P1.core.rbf\0" \
+ 	"mmcroot=/dev/mmcblk0p2\0" \
++	"usbroot=/dev/sda2\0" \
++	"tftproot=/dev/nfs\0" \
++	"bootcmd=run mmcload;run mmcboot\0" \
++	"mmcload=mmc rescan && mmcinfo; echo Copying Linux from MMC to RAM...;" \
++		"load mmc 0:1 ${loadaddr} ${bootfile};\0" \
++	"mmcboot=setenv bootargs " CONFIG_BOOTARGS \
++		" root=${mmcroot} rw rootwait;" \
++		"bootm ${loadaddr} \0" \
++	"usbload=usb start && usb info; echo Copying Linux from USB to RAM...;" \
++		"load usb 0:1 ${loadaddr} ${bootfile}\0" \
++	"usbboot=setenv bootargs " CONFIG_BOOTARGS \
++ 		" root=${usbroot} rw rootwait;" \
++		"bootm ${loadaddr} \0" \
++	"tftpload=echo Copying Linux from TFTP path to RAM...;" \
++		 "tftpboot ${loadaddr} ${serverip}:${bootfile}\0" \
++	"tftpboot=setenv bootargs " CONFIG_BOOTARGS \
++		 " root=${tftproot} rw ip=${ipaddr} nfsroot=${serverip}:${nfsroot},v3,tcp;" \
++ 		 "bootm ${loadaddr} \0" \
+ 	"mtdids=" CONFIG_MTDIDS_DEFAULT "\0" \
+ 	"mtdparts=" CONFIG_MTDPARTS_DEFAULT "\0" \
+ 	"linux_qspi_enable=if sf probe; then " \
+@@ -398,3 +419,4 @@
+  */
+ 
+ #endif	/* __CONFIG_SOCFPGA_SOC64_COMMON_H__ */
++
+diff -Naur --no-dereference '--exclude=.git' A/include/iG_fru.h B/include/iG_fru.h
+--- A/include/iG_fru.h	1970-01-01 05:30:00.000000000 +0530
++++ B/include/iG_fru.h	2025-12-09 16:47:52.084684884 +0530
+@@ -0,0 +1,128 @@
++/*
++ * fru.h
++ * Copyright (C) 2012-2015 Analog Devices
++ * Author : Robin Getz <robin.getz@analog.com>
++ *
++ * This file is maintained as part of:
++ *    https://github.com/analogdevicesinc/fru_tools
++ * but is released under this license, so you can use it without having 
++ * your software fall under the GPL. If you make improvements to this,
++ * although you are not required, it would be nice if you sent me a patch.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * - Redistributions of source code must retain the above copyright
++ *   notice, this list of conditions and the following disclaimer.
++ * - Redistributions in binary form must reproduce the above copyright
++ *   notice, this list of conditions and the following disclaimer in
++ *   the documentation and/or other materials provided with the
++ *   distribution.
++ * - Neither the name of Analog Devices, Inc. nor the names of its
++ *   contributors may be used to endorse or promote products derived
++ *   from this software without specific prior written permission.
++ * - The use of this software may or may not infringe the patent rights
++ *   of one or more patent holders.  This license does not release you
++ *   from the requirement that you obtain separate licenses from these
++ *   patent holders to use this software.
++ *
++ * THIS SOFTWARE IS PROVIDED BY ANALOG DEVICES "AS IS" AND ANY EXPRESS OR
++ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, NON-INFRINGEMENT,
++ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
++ * IN NO EVENT SHALL ANALOG DEVICES BE LIABLE FOR ANY DIRECT, INDIRECT,
++ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
++ * BUT NOT LIMITED TO, INTELLECTUAL PROPERTY RIGHTS, PROCUREMENT OF
++ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
++ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
++ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
++ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
++ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE
++ */
++
++#ifndef __fru_tools__
++#define __fru_tools__
++
++#include <stdbool.h>
++
++#ifndef UNUSED
++#  ifdef __GNUC__
++#    define UNUSED(x) UNUSED_ ## x __attribute__((__unused__))
++#  else
++#    define UNUSED(x) UNUSED_ ## x
++#  endif
++#endif
++
++/* 
++ * These structures/data are based from:
++ * Platform Management FRU Information
++ * Storage Definition
++ * Document Revision 1.1, September 27, 1999
++ * http://download.intel.com/design/servers/ipmi/FRU1011.pdf
++ * 
++ * ANSI/VITA 57.1
++ * FPGA Mezzanine Card (FMC) Standard
++ * Approved July 2008 (Revised February 2010)
++ * Used with permission
++ */
++
++#define CUSTOM_FIELDS 10
++
++/* Defines from section 13 "TYPE/LENGTH BYTE FORMAT"  of FRU spec) */
++#define FRU_STRING_BINARY  0
++#define FRU_STRING_BCD     1
++#define FRU_STRING_SIXBIT  2
++#define FRU_STRING_ASCII   3
++
++#define TYPE_CODE(x)  ((x[0] >> 6) & 0x3)
++#define FIELD_LEN(x)  (x[0] & 0x3F)
++
++struct BOARD_INFO {
++	unsigned char language_code;
++	unsigned int mfg_date;
++	unsigned char *manufacturer;
++	unsigned char *product_name;
++	unsigned char *serial_number;
++	unsigned char *part_number;
++	unsigned char *FRU_file_ID;
++	unsigned char *custom[CUSTOM_FIELDS];
++};
++
++#define NUM_MULTI     3
++#define NUM_SUPPLIES 12
++
++struct MULTIRECORD_INFO {
++	unsigned char *supplies[NUM_SUPPLIES];
++	unsigned char *connector;
++	unsigned char *i2c_devices;
++};
++
++#define MULTIRECORD_I2C 1
++#define MULTIRECORD_CONNECTOR 0
++
++#define MULTIRECORD_DC_OUTPUT 1
++#define MULTIRECORD_DC_INPUT  2
++/* 0xfa is the FMC-specific MultiRecords, see Rule Rule 5.77 in the FMC spec */
++#define MULTIRECORD_FMC       0xFA
++/* VITAs Organizationally Unique Identifier - see rule 5.77 in the FMC spec */
++#define VITA_OUI 0x0012A2
++
++struct FRU_DATA {
++	char *Internal_Area;
++	char *Chassis_Info;
++	struct BOARD_INFO *Board_Area;
++	char *Product_Info;
++	struct MULTIRECORD_INFO *MultiRecord_Area;
++};
++
++extern void printf_err (const char *, ...);
++extern void printf_warn (const char *, ...);
++extern void printf_info (const char *, ...);
++extern struct FRU_DATA * parse_FRU (unsigned char *);
++extern void free_FRU (struct FRU_DATA * fru);
++extern unsigned char * build_FRU_blob (struct FRU_DATA *, size_t *, bool);
++extern time_t min2date(unsigned int mins);
++extern void * x_calloc (size_t, size_t);
++extern int fmc_vadj_support(int i2c_bus, int i2c_address, u32 vadj_volt);
++
++#endif  /* __fru_tools__ */
++
diff -Naur '--exclude=.git' --no-dereference A/meta-iwave/recipes-bsp/u-boot/files/socfpga_agilex5_ig58m.cfg B/meta-iwave/recipes-bsp/u-boot/files/socfpga_agilex5_ig58m.cfg
--- A/meta-iwave/recipes-bsp/u-boot/files/socfpga_agilex5_ig58m.cfg	1970-01-01 05:30:00.000000000 +0530
+++ B/meta-iwave/recipes-bsp/u-boot/files/socfpga_agilex5_ig58m.cfg	2025-12-09 19:57:47.532918881 +0530
@@ -0,0 +1,278 @@
+CONFIG_ARM=y
+CONFIG_ARCH_SOCFPGA=y
+CONFIG_SYS_ARCH="arm"
+CONFIG_SYS_CPU="armv8"
+CONFIG_SYS_SOC="socfpga"
+CONFIG_SYS_VENDOR="intel"
+CONFIG_SYS_BOARD="agilex5-iG58m"
+CONFIG_SYS_CONFIG_NAME="socfpga_agilex5_iG58m"
+CONFIG_ARM64=y
+CONFIG_BOOTFILE="kernel.itb"
+CONFIG_TEXT_BASE=0x80200000
+CONFIG_ENV_OFFSET=0x04100000
+CONFIG_ENV_SECT_SIZE=0x512
+CONFIG_ENV_SIZE=0x2000
+CONFIG_ENV_ADDR=0x0
+CONFIG_SYS_STDIO_DEREGISTER=y
+CONFIG_CONSOLE_MUX=y
+CONFIG_SYS_CONSOLE_IS_IN_ENV=y
+CONFIG_BOARD_LATE_INIT=y
+CONFIG_NR_DRAM_BANKS=3
+CONFIG_SPL_LDSCRIPT="arch/arm/mach-socfpga/u-boot-spl-soc64.lds"
+CONFIG_SYS_SPI_U_BOOT_OFFS=0x04000000
+CONFIG_HAS_CUSTOM_SYS_INIT_SP_ADDR=y
+CONFIG_CUSTOM_SYS_INIT_SP_ADDR=0x80300000
+CONFIG_SF_DEFAULT_MODE=0x2003
+CONFIG_SF_DEFAULT_SPEED=1000000
+CONFIG_SPL_DM_GPIO=y
+CONFIG_DM_GPIO=y
+CONFIG_SPL_GPIO=y
+CONFIG_SPL_GPIO_HOG=y
+CONFIG_GPIO_HOG=y
+CONFIG_PHY_ATHEROS=y
+CONFIG_SPL_PHY_ATHEROS=y
+CONFIG_DM_MDIO=y
+CONFIG_I2C_MUX=y
+CONFIG_I2C_MUX_PCA954x=y
+CONFIG_CMD_PCA953X=y
+CONFIG_DM_PCA953X=y
+CONFIG_DEFAULT_DEVICE_TREE="socfpga_agilex5_iG58m"
+CONFIG_SPL_MMC=y
+CONFIG_SPL_DM_MMC=y
+CONFIG_SPL_SERIAL=y
+CONFIG_SPL_DRIVERS_MISC=y
+CONFIG_TARGET_SOCFPGA_AGILEX5_IG58M=y
+CONFIG_TARGET_SOCFPGA_SOC64=y
+CONFIG_TARGET_SOCFPGA_AGILEX5_SIMICS=y
+CONFIG_SPL_ENV_SUPPORT=y
+CONFIG_ENV_IS_IN_FAT=y
+CONFIG_ENV_IS_IN_MMC=y
+CONFIG_ENV_IS_IN_SPI_FLASH=y
+CONFIG_SPL_ENV_IS_IN_FAT=y
+CONFIG_SPL_ENV_IS_IN_MMC=y
+CONFIG_SPL_ENV_IS_IN_SPI_FLASH=y
+CONFIG_ENV_FAT_DEVICE_AND_PART="0:1"
+CONFIG_ENV_SPI_BUS=0
+CONFIG_ENV_SPI_CS=0
+CONFIG_ENV_SPI_MAX_HZ=1000000
+CONFIG_ENV_SPI_MODE=0x2003
+CONFIG_DM_RESET=y
+CONFIG_SPL_STACK=0x71000
+# CONFIG_EFI_LOADER is not set
+# CONFIG_SPL_RAW_IMAGE_SUPPORT is not set
+# CONFIG_SPL_SHARES_INIT_SP_ADDR is not set
+# CONFIG_ISO_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+# CONFIG_SPL_EFI_PARTITION is not set
+# CONFIG_SPL_PARTITION_UUIDS is not set
+# CONFIG_SPL_USE_TINY_PRINTF is not set
+# CONFIG_MMC_VERBOSE is not set
+# CONFIG_SPI_FLASH_USE_4K_SECTORS is not set
+CONFIG_CMD_I3C=y
+CONFIG_I3C=y
+CONFIG_DW_I3C_MASTER=y
+CONFIG_USE_BOOTFILE=y
+CONFIG_SPL_SYS_MALLOC=y
+CONFIG_SPL_HAS_CUSTOM_MALLOC_START=y
+CONFIG_SPL_CUSTOM_SYS_MALLOC_ADDR=0xbfa00000
+CONFIG_SPL_SYS_MALLOC_SIZE=0x500000
+CONFIG_SPL_HAS_BSS_LINKER_SECTION=y
+CONFIG_SPL_BSS_START_ADDR=0xbff00000
+CONFIG_SPL_BSS_MAX_SIZE=0x100000
+CONFIG_SYS_LOAD_ADDR=0x82000000
+CONFIG_IDENT_STRING="socfpga_agilex5"
+CONFIG_SPL_FS_FAT=y
+CONFIG_SPL_LIBDISK_SUPPORT=y
+CONFIG_SPL_SPI_FLASH_SUPPORT=y
+CONFIG_SPL_SPI=y
+CONFIG_FIT=y
+CONFIG_SPL_FIT_SIGNATURE=y
+CONFIG_SPL_LOAD_FIT=y
+CONFIG_SPL_LOAD_FIT_ADDRESS=0x82000000
+CONFIG_LEGACY_IMAGE_FORMAT=y
+CONFIG_DISTRO_DEFAULTS=y
+CONFIG_QSPI_BOOT=y
+CONFIG_BOOTDELAY=5
+CONFIG_USE_BOOTARGS=y
+CONFIG_BOOTARGS="console=ttyS1,115200 earlycon panic=-1"
+CONFIG_BOOTCOMMAND="run distro_bootcmd"
+CONFIG_SPL_MAX_SIZE=0x40000
+CONFIG_SPL_SYS_MALLOC_F=y
+CONFIG_SPL_SYS_MALLOC_F_LEN=0x2000
+CONFIG_SPL_CACHE=y
+CONFIG_SPL_SPI_FLASH_MTD=y
+CONFIG_SPL_SPI_LOAD=y
+CONFIG_SPL_DM_SPI=y
+CONFIG_SPL_DM_SPI_FLASH=y
+CONFIG_SPL_ATF=y
+CONFIG_SPL_ATF_NO_PLATFORM_PARAM=y
+CONFIG_SYS_PROMPT="IG58M # "
+CONFIG_CMD_GREPENV=y
+CONFIG_CMD_ERASEENV=y
+CONFIG_CMD_NVEDIT_INFO=y
+CONFIG_SYS_MAXARGS=32
+CONFIG_CMD_NVEDIT_SELECT=y
+CONFIG_CMD_MEMTEST=y
+CONFIG_CMD_IG_MEMTEST=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_DM_I2C=y
+CONFIG_SYS_I2C_DW=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_PART=y
+CONFIG_PHY=y
+CONFIG_SPL_PHY=y
+CONFIG_I2C_EEPROM=y
+CONFIG_FRU_EEPROM=y
+CONFIG_SYS_I2C_EEPROM_ADDR=0x3
+CONFIG_SYS_I2C_EEPROM_ADDR_OVERFLOW=0x50
+CONFIG_NOP_PHY=y
+CONFIG_SPL_NOP_PHY=y
+CONFIG_PHY_CADENCE_COMBOPHY=y
+CONFIG_SPL_PHY_CADENCE_COMBOPHY=y
+CONFIG_MMC=y
+CONFIG_MMC_WRITE=y
+CONFIG_DM_MMC=y
+CONFIG_MMC_SDHCI_ADMA_HELPERS=y
+CONFIG_MMC_QUIRKS=y
+CONFIG_SYS_MMC_MAX_BLK_COUNT=65535
+CONFIG_MMC_HW_PARTITIONING=y
+CONFIG_MMC_DW=y
+CONFIG_MMC_DW_SOCFPGA=y
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_ADMA=y
+CONFIG_SPL_MMC_SDHCI_ADMA=y
+CONFIG_MMC_SDHCI_CADENCE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_MTD=y
+CONFIG_CMD_SPI=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIMER=y
+CONFIG_MTDIDS_DEFAULT="nand0=10b80000.nand.0"
+CONFIG_MTDPARTS_DEFAULT="mtdparts=10b80000.nand.0:2m(u-boot),-(root)"
+CONFIG_ENV_OVERWRITE=y
+CONFIG_SYS_RELOC_GD_ENV_ADDR=y
+CONFIG_NET_RANDOM_ETHADDR=y
+CONFIG_SPL_DM_SEQ_ALIAS=y
+CONFIG_SPL_ALTERA_SDRAM=y
+CONFIG_DWAPB_GPIO=y
+CONFIG_MISC=y
+CONFIG_MISC_INIT_R=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_STMICRO=y
+CONFIG_SPI_FLASH_MTD=y
+CONFIG_SPL_MTD=y
+CONFIG_PHY_MARVELL=y
+CONFIG_PHY_GIGE=y
+CONFIG_DWC_ETH_XGMAC=y
+CONFIG_DWC_ETH_XGMAC_SOCFPGA=y
+CONFIG_ETH_DESIGNWARE=y
+CONFIG_ETH_DESIGNWARE_SOCFPGA=y
+CONFIG_RGMII=y
+CONFIG_SYS_NS16550=y
+CONFIG_SYS_NS16550_MEM32=y
+CONFIG_SPI=y
+CONFIG_CADENCE_QSPI=y
+CONFIG_DESIGNWARE_SPI=y
+CONFIG_DM_SPI=y
+CONFIG_SPI_MEM=y
+CONFIG_TIMER=y
+CONFIG_DESIGNWARE_APB_TIMER=y
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_SPL_DM_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_XHCI_DWC3=y
+CONFIG_USB_DWC2=y
+CONFIG_USB_DWC3=y
+CONFIG_USB_HUB_DEBOUNCE_TIMEOUT=3000
+CONFIG_USB_STORAGE=y
+CONFIG_PANIC_HANG=y
+CONFIG_SPL_CRC32=y
+CONFIG_SPL_CRYPTO=y
+CONFIG_RSA=y
+CONFIG_SPL_RSA=y
+CONFIG_SPL_RSA_VERIFY=y
+CONFIG_RSA_VERIFY=y
+CONFIG_SHA1=y
+CONFIG_SHA256=y
+CONFIG_MD5=y
+CONFIG_LZ4=y
+CONFIG_LZMA=y
+CONFIG_GZIP=y
+CONFIG_ZLIB=y
+CONFIG_OF_CONTROL=y
+CONFIG_SPL_OF_CONTROL=y
+CONFIG_OF_REAL=y
+CONFIG_SPL_OF_REAL=y
+CONFIG_SPL_SYS_DCACHE_OFF=y
+CONFIG_SPL_BSS_LIMIT=y
+CONFIG_SPL_BINMAN_SYMBOLS=y
+CONFIG_SPL_BINMAN_UBOOT_SYMBOLS=y
+CONFIG_SPL_SEPARATE_BSS=y
+CONFIG_SPL_SYS_MMCSD_RAW_MODE=y
+CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR=0x200
+CONFIG_SPL_SPI_FLASH_TINY=y
+CONFIG_SPL_SOCFPGA_SEC_REG=y
+CONFIG_SPL_SOCFPGA_DT_REG=y
+CONFIG_SYS_MALLOC_F=y
+CONFIG_SYS_MALLOC_F_LEN=0x2000
+CONFIG_BOOTM_LINUX=y
+CONFIG_BOOTM_NETBSD=y
+CONFIG_BOOTM_PLAN9=y
+CONFIG_BOOTM_RTEMS=y
+CONFIG_BOOTM_VXWORKS=y
+CONFIG_CMD_BOOTM=y
+CONFIG_CMD_BOOTI=y
+CONFIG_CMD_FDT=y
+CONFIG_CMD_ELF=y
+CONFIG_CMD_XIMG=y
+CONFIG_CMD_EXPORTENV=y
+CONFIG_CMD_IMPORTENV=y
+CONFIG_CMD_EDITENV=y
+CONFIG_CMD_DM=y
+CONFIG_CMD_FPGA=y
+CONFIG_FPGA=y
+CONFIG_FPGA_ALTERA=y
+CONFIG_FPGA_INTEL_SDM_MAILBOX=y
+CONFIG_NET=y
+CONFIG_DM_ETH=y
+CONFIG_BOOTDEV_ETH=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_MDIO=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_TFTPBOOT=y
+CONFIG_CMD_PXE=y
+CONFIG_BOOTP_PXE=y
+CONFIG_SYS_RX_ETH_BUFFER=4
+CONFIG_MTD_PARTITIONS=y
+CONFIG_MTD=y
+CONFIG_DM_SPI_FLASH=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_LOCK=y
+CONFIG_SPI_FLASH_UNLOCK_ALL=y
+CONFIG_SYSRESET=y
+CONFIG_SPL_SYSRESET=y
+CONFIG_SYSRESET_SOCFPGA_AGILEX5=y
+CONFIG_SYSRESET_CMD_RESET=y
+CONFIG_BOOTMETH_EXTLINUX=y
+CONFIG_BOOTMETH_EXTLINUX_PXE=y
+CONFIG_BOOTMETH_VBE=y
+CONFIG_BOOTMETH_VBE_REQUEST=y
+CONFIG_BOOTMETH_VBE_SIMPLE=y
+CONFIG_BOOTMETH_VBE_SIMPLE_OS=y
+CONFIG_PSCI_RESET=y
+CONFIG_LMB=y
+CONFIG_LIB_UUID=y
+CONFIG_LIB_ELF=y
+CONFIG_DTOC=y
+CONFIG_BINMAN=y
+CONFIG_BINMAN_FDT=y
+CONFIG_SPL_IMAGE="spl/u-boot-spl.bin"
+CONFIG_SPL_PAYLOAD="u-boot.bin"
+CONFIG_ARMV8_PSCI_NR_CPUS=4
+CONFIG_SOCFPGA_RSU_MULTIBOOT=y
+CONFIG_IMAGE_SIGN_INFO=y
+CONFIG_SPL_IMAGE_SIGN_INFO=y
diff -Naur '--exclude=.git' --no-dereference A/meta-iwave/recipes-bsp/u-boot/files/uboot_script.its B/meta-iwave/recipes-bsp/u-boot/files/uboot_script.its
--- A/meta-iwave/recipes-bsp/u-boot/files/uboot_script.its	1970-01-01 05:30:00.000000000 +0530
+++ B/meta-iwave/recipes-bsp/u-boot/files/uboot_script.its	2025-12-09 19:57:47.496914520 +0530
@@ -0,0 +1,23 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2019 Intel Corporation
+ *
+ */
+
+/dts-v1/;
+
+/ {
+    description = "FIT image for u-boot script";
+    images {
+         default = "script";
+         script {
+             description = "u-boot script";
+             data = /incbin/("./uboot.txt");
+             type = "script";
+             compression = "none";
+             hash {
+                 algo = "crc32";
+             };
+        };
+    };
+};
diff -Naur '--exclude=.git' --no-dereference A/meta-iwave/recipes-bsp/u-boot/files/uboot.txt B/meta-iwave/recipes-bsp/u-boot/files/uboot.txt
--- A/meta-iwave/recipes-bsp/u-boot/files/uboot.txt	1970-01-01 05:30:00.000000000 +0530
+++ B/meta-iwave/recipes-bsp/u-boot/files/uboot.txt	2025-12-09 19:57:47.495914399 +0530
@@ -0,0 +1,10 @@
+echo "Trying to boot Linux from device ${target}";
+
+if test ${target} = "mmc0"; then
+	if test -e ${devtype} ${devnum}:${distro_bootpart} /${bootfile}; then
+		echo "Found kernel in mmc0";
+		setenv bootcmd "run mmcload;run mmcboot";
+		exit;
+	fi
+fi
+
diff -Naur '--exclude=.git' --no-dereference A/meta-iwave/recipes-bsp/u-boot/u-boot-socfpga-ig58m_v2025.01.bb B/meta-iwave/recipes-bsp/u-boot/u-boot-socfpga-ig58m_v2025.01.bb
--- A/meta-iwave/recipes-bsp/u-boot/u-boot-socfpga-ig58m_v2025.01.bb	1970-01-01 05:30:00.000000000 +0530
+++ B/meta-iwave/recipes-bsp/u-boot/u-boot-socfpga-ig58m_v2025.01.bb	2025-12-09 19:57:47.493914157 +0530
@@ -0,0 +1,30 @@
+require ${WORKSPACE}/meta-intel-fpga/recipes-bsp/u-boot/u-boot-socfpga_v2025.01.bb
+
+S = "${UNPACKDIR}"
+DESCRIPTION = "U-Boot for Agilex5 based iG-RainboW-G58M SoM"
+LICENSE = "GPL-2.0-or-later"
+LIC_FILES_CHKSUM = "file://Licenses/gpl-2.0.txt;md5=b234ee4d69f5fce4486a80fdaf4a4263"
+ERROR_QA:remove = "patch-status"
+WARN_QA:append = " patch-status"
+
+TARGET_CFLAGS += "-Wno-unused-variable"
+
+DEPENDS:append:${MACHINE} = "arm-trusted-firmware bash u-boot-socfpga-ig58-scr"
+
+COMPILE_PREPEND_FILES:${MACHINE} = " bl31.bin "
+DEPLOY_APPEND_FILES:${MACHINE} = ""
+
+S = "${WORKDIR}/git"
+
+FILESEXTRAPATHS:prepend := "${THISDIR}/files:"
+
+#SRC_URI = "git://github.com/altera-fpga/u-boot-socfpga.git;branch=socfpga_v2025.01;protocol=https"
+
+SRC_URI:append = " \
+    file://P01-iG-PRHSZ-SC-01-R2.0-REL0.1-SD2.0-Q25.1-UBoot25.01.patch \
+    file://socfpga_agilex5_ig58m.cfg \
+"
+# Skip patch-status checks for this package
+INSANE_SKIP:${PN} += "patch-status"
+
+
diff -Naur '--exclude=.git' --no-dereference A/meta-iwave/recipes-bsp/u-boot/u-boot-socfpga-ig58-scr.bb B/meta-iwave/recipes-bsp/u-boot/u-boot-socfpga-ig58-scr.bb
--- A/meta-iwave/recipes-bsp/u-boot/u-boot-socfpga-ig58-scr.bb	1970-01-01 05:30:00.000000000 +0530
+++ B/meta-iwave/recipes-bsp/u-boot/u-boot-socfpga-ig58-scr.bb	2025-12-09 19:57:47.534919123 +0530
@@ -0,0 +1,39 @@
+# First Recipe
+SUMMARY = "U-boot boot scripts for Agilex5 based iG-RainboW-G58M SoM"
+LICENSE = "MIT"
+LIC_FILES_CHKSUM = "file://${COMMON_LICENSE_DIR}/MIT;md5=0835ade698e0bcf8506ecda2f7b4f302"
+
+FILESEXTRAPATHS:prepend := "${THISDIR}/files:"
+
+DEPENDS = "u-boot-mkimage-native dtc-native"
+
+inherit deploy nopackages
+PACKAGE_ARCH = "${MACHINE_ARCH}"
+
+HYP_BUILD ??= "0"
+
+INHIBIT_DEFAULT_DEPS = "1"
+
+SRC_URI = "file://uboot.txt file://uboot_script.its"
+
+S = "${UNPACKDIR}"
+
+do_fetch[noexec] = "1"
+do_configure[noexec] = "1"
+do_install[noexec] = "1"
+
+do_compile() {
+    if [[ "${MACHINE}" == "agilex5_ig58m" ]]; then
+        mkimage -f "${S}/uboot_script.its" "${S}/boot.scr.uimg"
+    fi
+}
+
+do_deploy() {
+    install -d ${DEPLOYDIR}
+    if [[ "${MACHINE}" == "agilex5_ig58m" ]]; then
+        install -m 0755 "${S}/uboot.txt" "${DEPLOYDIR}/u-boot.txt"
+        install -m 0644 "${S}/boot.scr.uimg" "${DEPLOYDIR}/boot.scr.uimg"
+    fi
+}
+
+addtask do_deploy after do_compile before do_build
diff -Naur '--exclude=.git' --no-dereference A/meta-iwave/recipes-kernel/linux/linux-socfpga-lts-ig58/fit_kernel_agilex5_ig58m.its B/meta-iwave/recipes-kernel/linux/linux-socfpga-lts-ig58/fit_kernel_agilex5_ig58m.its
--- A/meta-iwave/recipes-kernel/linux/linux-socfpga-lts-ig58/fit_kernel_agilex5_ig58m.its	1970-01-01 05:30:00.000000000 +0530
+++ B/meta-iwave/recipes-kernel/linux/linux-socfpga-lts-ig58/fit_kernel_agilex5_ig58m.its	2025-12-09 19:57:47.585925300 +0530
@@ -0,0 +1,56 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) iWave Global
+ *
+ */
+
+/dts-v1/;
+
+/ {
+	description = "FIT image with kernel, DTB and FPGA core binary";
+	#address-cells = <1>;
+
+	images {
+		kernel {
+			description = "Linux Kernel";
+			data = /incbin/("./Image.lzma");
+			type = "kernel";
+			arch = "arm64";
+			os = "linux";
+			compression = "lzma";
+			load = <0x86000000>;
+			entry = <0x86000000>;
+			hash {
+				algo = "crc32";
+			};
+		};
+
+		fdt-0 {
+			description = "socfpga_agilex5_iG58m";
+			data = /incbin/("./socfpga_agilex5_iG58m.dtb");
+			type = "flat_dt";
+			arch = "arm64";
+			compression = "none";
+			hash {
+				algo = "crc32";
+			};
+		};
+
+	};
+
+	configurations {
+		default = "board-0";
+
+		board-0 {
+			description = "board_0";
+			kernel = "kernel";
+			fdt = "fdt-0";
+			signature {
+				algo = "crc32";
+				key-name-hint = "dev";
+				sign-images = "fdt-0", "kernel";
+			};
+		};
+
+	};
+};
diff -Naur '--exclude=.git' --no-dereference A/meta-iwave/recipes-kernel/linux/linux-socfpga-lts-ig58/P01-iG-PRHSZ-SC-01-R2.0-REL0.1-SD2.0-Q25.1-Linux6.12.11.patch B/meta-iwave/recipes-kernel/linux/linux-socfpga-lts-ig58/P01-iG-PRHSZ-SC-01-R2.0-REL0.1-SD2.0-Q25.1-Linux6.12.11.patch
--- A/meta-iwave/recipes-kernel/linux/linux-socfpga-lts-ig58/P01-iG-PRHSZ-SC-01-R2.0-REL0.1-SD2.0-Q25.1-Linux6.12.11.patch	1970-01-01 05:30:00.000000000 +0530
+++ B/meta-iwave/recipes-kernel/linux/linux-socfpga-lts-ig58/P01-iG-PRHSZ-SC-01-R2.0-REL0.1-SD2.0-Q25.1-Linux6.12.11.patch	2025-12-09 19:57:47.584925178 +0530
@@ -0,0 +1,2725 @@
+diff -Naur --no-dereference '--exclude=.git' A/arch/arm64/boot/dts/intel/Makefile B/arch/arm64/boot/dts/intel/Makefile
+--- A/arch/arm64/boot/dts/intel/Makefile	2025-11-19 15:57:18.240325675 +0530
++++ B/arch/arm64/boot/dts/intel/Makefile	2025-12-08 11:06:15.658495680 +0530
+@@ -5,6 +5,7 @@
+ 				socfpga_agilex_socdk_nand.dtb \
+ 				socfpga_agilex3_socdk.dtb \
+ 				socfpga_agilex5_socdk.dtb \
++				socfpga_agilex5_iG58m.dtb \
+ 				socfpga_agilex_n6010.dtb \
+ 				socfpga_agilex5_socdk.dtb \
+ 				socfpga_agilex5_socdk_b0.dtb \
+diff -Naur --no-dereference '--exclude=.git' A/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi B/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi
+--- A/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi	2025-11-19 15:57:18.241325657 +0530
++++ B/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi	2025-12-08 11:06:15.658495680 +0530
+@@ -1251,5 +1251,38 @@
+ 			clocks = <&qspi_clk>;
+ 			status = "disabled";
+ 		};
++		
++		/* Adding Bridges */
++		fpga_hps2fpgabridge: fpga_bridge@40000000 {
++			compatible = "altr,socfpga-hps2fpga-bridge";
++			reg = <0x40000000 0x40000000>;
++			resets = <&rst SOC2FPGA_RESET>;
++			clocks = <&clkmgr AGILEX5_L4_MAIN_CLK>;
++			status = "okay";
++		};
++
++		fpga_lwhps2fpgabridge: fpga_bridge@20000000{
++			compatible = "altr,socfpga-lwhps2fpga-bridge";
++			reg = <0x20000000 0x20000000>;
++			resets = <&rst LWHPS2FPGA_RESET>;
++			clocks = <&clkmgr AGILEX5_L4_MAIN_CLK>;
++			status = "okay";
++		};
++
++		fpga_fpga2hpsbridge: fpga-bridge@0 {
++			compatible = "altr,socfpga-fpga2hps-bridge";
++			reg = <0x0 0x20000000>;
++			resets = <&rst FPGA2SOC_RESET>;
++			clocks = <&clkmgr AGILEX5_L4_MAIN_CLK>;
++			status = "okay";
++		};
++
++		fpga_fpga2sdram: fpga-bridge@80000000 {
++			compatible = "altr,socfpga-fpga2sdram-bridge";
++			reg = <0x80000000 0x80000000>;
++			resets = <&rst F2SSDRAM0_RESET>;
++			clocks = <&clkmgr AGILEX5_L4_MAIN_CLK>;
++			status = "okay";
++		};
+ 	};
+ };
+diff -Naur --no-dereference '--exclude=.git' A/arch/arm64/boot/dts/intel/socfpga_agilex5_iG58m.dts B/arch/arm64/boot/dts/intel/socfpga_agilex5_iG58m.dts
+--- A/arch/arm64/boot/dts/intel/socfpga_agilex5_iG58m.dts	1970-01-01 05:30:00.000000000 +0530
++++ B/arch/arm64/boot/dts/intel/socfpga_agilex5_iG58m.dts	2025-12-08 11:06:15.658495680 +0530
+@@ -0,0 +1,438 @@
++/*
++ * Copyright (C) 2025 iWave Global
++ * IP Support <support.ip@iwave-global.com>
++ */
++#include "socfpga_agilex5.dtsi"
++
++/ {
++	model = "SoCFPGA Agilex5 based iG58M development platform";
++	#address-cells = <2>;
++	#size-cells = <2>;
++
++	aliases {
++		serial0 = &uart0;
++		ethernet0 = &gmac2;
++		rtc0 = &da9062_rtc;
++	};
++
++	chosen {
++		stdout-path = "serial0:115200n8";
++		bootargs = "console=ttyS0,115200 earlycon panic=-1";
++	};
++
++	iG58m_info {
++		compatible = "iwave,iG58m-info";
++		status = "okay";
++	};
++
++	fpga_ref_clk: ref_clk {
++		compatible = "fixed-clock";
++		#clock-cells = <0>;
++		clock-frequency = <100000000>;
++		clock-output-names = "fpga-ref-clk";
++		};
++
++		gpio_pmod: gpio@20000020 {
++			status = "okay";
++			compatible = "altr,pio-1.0";
++			reg = <0x0 0x20000020 0x0 0x20>;
++			altr,ngpio = <8>;
++			#gpio-cells = <2>;
++			gpio-controller;
++		};
++
++		gpio_fmc_io_1: gpio@20000080 {
++			status = "okay";
++			compatible = "altr,pio-1.0";
++			reg = <0x0 0x20000080 0x0 0x20>;
++			altr,ngpio = <32>;
++			#gpio-cells = <2>;
++			gpio-controller;
++		};
++
++		gpio_fmc_io_2: gpio@200000A0 {
++			status = "okay";
++			compatible = "altr,pio-1.0";
++			reg = <0x0 0x200000A0 0x0 0x20>;
++			altr,ngpio = <32>;
++			#gpio-cells = <2>;
++			gpio-controller;
++		};
++
++		gpio_fmc_io_3: gpio@200000C0 {
++			status = "okay";
++			compatible = "altr,pio-1.0";
++			reg = <0x0 0x200000C0 0x0 0x20>;
++			altr,ngpio = <32>;
++			#gpio-cells = <2>;
++			gpio-controller;
++		};
++
++		gpio_fmc_io_4: gpio@200000E0 {
++			status = "okay";
++			compatible = "altr,pio-1.0";
++			reg = <0x0 0x200000E0 0x0 0x20>;
++			altr,ngpio = <29>;
++			#gpio-cells = <2>;
++			gpio-controller;
++		};
++
++		gpio_header_1: gpio@21000040 {
++			status = "okay";
++			compatible = "altr,pio-1.0";
++			reg = <0x0 0x21000040 0x0 0x20>;
++			altr,ngpio = <18>;
++			#gpio-cells = <2>;
++			gpio-controller;
++		};
++
++		gpio_header_2: gpio@20000060 {
++			status = "okay";
++			compatible = "altr,pio-1.0";
++			reg = <0x0 0x20000060 0x0 0x20>;
++			altr,ngpio = <21>;
++			#gpio-cells = <2>;
++			gpio-controller;
++		};
++	};
++
++&gpio0 {
++	status = "okay";
++};
++
++&gpio1 {
++	status = "okay";
++};
++
++&i2c0 {
++	status = "okay";
++	clock-frequency = <400000>;
++
++	pmic0: da9062@58 {
++		compatible = "dlg,da9062";
++		reg = <0x58>;
++
++		gpio-controller;
++		#gpio-cells = <2>;
++
++		da9062_rtc: rtc {
++			compatible = "dlg,da9062-rtc";
++			wakeup-source;
++		};
++
++		da9062_wdt: watchdog {
++			compatible = "dlg,da9062-watchdog";
++			status = "okay";
++		};
++
++		da9062_gpio: gpio {
++			compatible = "dlg,da9062-gpio";
++			status = "okay";
++		};
++	};
++
++	eeprom: eeprom@52 {
++		compatible = "atmel,24c04";
++		reg = <0x52>;
++		pagesize = <16>;
++		address-width = <8>;
++		size = <512>;
++	};
++
++	Som_eeprom: eeprom@56 {
++		compatible = "atmel,24mac402";
++		reg = <0x56>;
++		pagesize = <16>;
++		address-width = <8>;
++		size = <512>;
++	};
++
++	i2c_mux: msd9546@71 {
++		compatible = "nxp,pca9546";
++		reg = <0x71>;
++		status = "okay";
++		#address-cells = <1>;
++		#size-cells = <0>;
++
++		i2c@0 {
++			#address-cells = <1>;
++			#size-cells = <0>;
++			reg = <0>;
++
++			gpio2: gpio-controller@20 {
++				compatible = "ti,tca6416";
++				reg = <0x20>;
++				#gpio-cells = <2>;
++				gpio-controller;
++				interrupt-controller;
++				#interrupt-cells = <2>;
++				interrupt-parent = <&porta>;
++				interrupts = <10 IRQ_TYPE_EDGE_FALLING>;
++			};
++		};
++
++		i2c@1 {
++			#address-cells = <1>;
++			#size-cells = <0>;
++			reg = <1>;
++
++			gpio3: gpio-controller@21 {
++				compatible = "ti,tca6416";
++				reg = <0x21>;
++				#gpio-cells = <2>;
++				gpio-controller;
++				interrupt-controller;
++				#interrupt-cells = <2>;
++				interrupt-parent = <&gpio2>;
++				interrupts = <6 IRQ_TYPE_EDGE_FALLING>;
++			};
++		};
++
++		i2c@2 {
++			#address-cells = <1>;
++			#size-cells = <0>;
++			reg = <2>;
++
++			eeprom2: eeprom@50 {
++				compatible = "atmel,24c04";
++				reg = <0x50>;
++				pagesize = <32>;
++				address-width = <16>;
++				size = <4096>;
++			};
++		};
++
++		i2c@3 {
++			#address-cells = <1>;
++			#size-cells = <0>;
++			reg = <3>;
++		};
++	};
++};
++
++&gmac2 {
++	status = "okay";
++	phy-mode = "rgmii-id";
++	phy-handle = <&emac2_phy0>;
++	max-frame-size = <9000>;
++	mdio0 {
++		#address-cells = <1>;
++		#size-cells = <0>;
++		compatible = "snps,dwmac-mdio";
++		emac2_phy0: ethernet-phy@4 {
++			reg = <4>;
++		};
++	};
++};
++
++&mmc {
++	status = "okay";
++	bus-width = <8>;
++	no-1-8-v;
++	cap-sd-highspeed;
++	cap-mmc-highspeed;
++	disable-wp;
++	sd-uhs-sdr50;
++	sdhci-caps = <0x00000000 0x0000c800>;
++	sdhci-caps-mask = <0x00002000 0x0000ff00>;
++	no-sdio;
++	cdns,phy-use-ext-lpbk-dqs = <1>;
++	cdns,phy-use-lpbk-dqs = <1>;
++	cdns,phy-use-phony-dqs = <1>;
++	cdns,phy-use-phony-dqs-cmd = <1>;
++	cdns,phy-io-mask-always-on = <0>;
++	cdns,phy-io-mask-end = <5>;
++	cdns,phy-io-mask-start = <0>;
++	cdns,phy-data-select-oe-end = <1>;
++	cdns,phy-sync-method = <1>;
++	cdns,phy-sw-half-cycle-shift = <0>;
++	cdns,phy-rd-del-sel = <52>;
++	cdns,phy-underrun-suppress = <1>;
++	cdns,phy-gate-cfg-always-on = <1>;
++	cdns,phy-param-dll-bypass-mode = <1>;
++	cdns,phy-param-phase-detect-sel = <2>;
++	cdns,phy-param-dll-start-point = <254>;
++	cdns,phy-read-dqs-cmd-delay = <0>;
++	cdns,phy-clk-wrdqs-delay = <0>;
++	cdns,phy-clk-wr-delay = <0>;
++	cdns,phy-read-dqs-delay = <0>;
++	cdns,phy-phony-dqs-timing = <0>;
++	cdns,hrs09-rddata-en = <1>;
++	cdns,hrs09-rdcmd-en = <1>;
++	cdns,hrs09-extended-wr-mode = <1>;
++	cdns,hrs09-extended-rd-mode = <1>;
++	cdns,hrs10-hcsdclkadj = <3>;
++	cdns,hrs16-wrdata1-sdclk-dly = <0>;
++	cdns,hrs16-wrdata0-sdclk-dly = <0>;
++	cdns,hrs16-wrcmd1-sdclk-dly = <0>;
++	cdns,hrs16-wrcmd0-sdclk-dly = <0>;
++	cdns,hrs16-wrdata1-dly = <0>;
++	cdns,hrs16-wrdata0-dly = <0>;
++	cdns,hrs16-wrcmd1-dly = <0>;
++	cdns,hrs16-wrcmd0-dly = <0>;
++	cdns,hrs07-rw-compensate = <10>;
++	cdns,hrs07-idelay-val = <0>;
++};
++
++&osc1 {
++	clock-frequency = <25000000>;
++};
++
++&uart0 {
++	status = "okay";
++};
++
++&usb31 {
++	status = "okay";
++	dr_mode = "host";
++};
++
++&smmu {
++	status = "okay";
++};
++
++&watchdog0 {
++	status = "okay";
++};
++
++&watchdog1 {
++	status = "okay";
++};
++
++&watchdog2 {
++	status = "okay";
++};
++
++&watchdog3 {
++	status = "okay";
++};
++
++&qspi {
++	status = "okay";
++	flash@0 {
++		#address-cells = <1>;
++		#size-cells = <1>;
++		compatible = "micron,mt25qu01g", "jedec,spi-nor";
++		reg = <0>;
++		spi-max-frequency = <100000000>;
++		m25p,fast-read;
++		cdns,page-size = <256>;
++		cdns,block-size = <16>;
++		cdns,read-delay = <2>;
++		cdns,tshsl-ns = <50>;
++		cdns,tsd2d-ns = <50>;
++		cdns,tchsh-ns = <4>;
++		cdns,tslch-ns = <4>;
++
++		partitions {
++			compatible = "fixed-partitions";
++			#address-cells = <1>;
++			#size-cells = <1>;
++
++			rsu-handle = <&qspi_boot>;
++
++			qspi_boot: partition@0 {
++				label = "u-boot";
++				reg = <0x00000000 0x04200000>;
++			};
++
++			partition@4200000 {
++				label = "root";
++				reg = <0x04200000 0x0BE00000>;
++			};
++
++		};
++	};
++};
++
++&temp_volt {
++	voltage {
++		#address-cells = <1>;
++		#size-cells = <0>;
++		input@2 {
++			label = "0.8V VCC";
++			reg = <2>;
++		};
++
++		input@3 {
++			label = "1.8V VCCIO_SDM";
++			reg = <3>;
++		};
++
++		input@4 {
++			label = "1.8V VCCPT";
++			reg = <4>;
++		};
++
++		input@5 {
++			label = "1.2V VCCCRCORE";
++			reg = <5>;
++			};
++
++		input@6 {
++			label = "0.9V VCCH";
++			reg = <6>;
++			};
++
++		input@7 {
++			label = "0.8V VCCL";
++			reg = <7>;
++			};
++		};
++
++	temperature {
++		#address-cells = <1>;
++		#size-cells = <0>;
++
++		input@0 {
++			label = "Main Die SDM";
++			reg = <0x0>;
++		};
++		input@10000 {
++			label = "Main Die corner bottom left max";
++			reg = <0x10000>;
++		};
++		input@10002 {
++			label = "Main Die corner bottom left 2";
++			reg = <0x10002>;
++		};
++		input@10003 {
++			label = "Main Die corner bottom left 3";
++			reg = <0x10003>;
++		};
++		input@10004 {
++			label = "Main Die corner bottom left 4";
++			reg = <0x10004>;
++		};
++
++		input@30000 {
++			label = "Main Die corner bottom right max";
++			reg = <0x30000>;
++		};
++		input@30002 {
++			label = "Main Die corner bottom right 2";
++			reg = <0x30002>;
++		};
++		input@30003 {
++			label = "Main Die corner bottom right 3";
++			reg = <0x30003>;
++		};
++		input@40000 {
++			label = "Main Die corner top right max";
++			reg = <0x40000>;
++		};
++		input@40003 {
++			label = "Main Die corner top right 3";
++			reg = <0x40003>;
++		};
++		input@40004 {
++			label = "Main Die corner top right 4";
++			reg = <0x40004>;
++		};
++		input@40005 {
++			label = "Main Die corner top right 5 - HPS";
++			reg = <0x40005>;
++		};
++	};
++};
++
+diff -Naur --no-dereference '--exclude=.git' A/arch/arm64/configs/socfpga_agilex5_iG58m_defconfig B/arch/arm64/configs/socfpga_agilex5_iG58m_defconfig
+--- A/arch/arm64/configs/socfpga_agilex5_iG58m_defconfig	1970-01-01 05:30:00.000000000 +0530
++++ B/arch/arm64/configs/socfpga_agilex5_iG58m_defconfig	2025-12-08 11:06:15.659495693 +0530
+@@ -0,0 +1,1758 @@
++CONFIG_SYSVIPC=y
++CONFIG_I2C_MUX_GPIO=y
++CONFIG_POSIX_MQUEUE=y
++CONFIG_AUDIT=y
++CONFIG_IG58M_BDINFO=y
++CONFIG_NO_HZ_IDLE=y
++CONFIG_PM_WAKELOCKS=y
++CONFIG_PM_WAKELOCKS_LIMIT=100
++CONFIG_PM_WAKELOCKS_GC=y
++CONFIG_PM_DEBUG=y
++CONFIG_PM_TEST_SUSPEND=y
++CONFIG_PM_SLEEP_DEBUG=y
++CONFIG_INTEL_STRATIX10_RSU=y
++CONFIG_MTD_UBI=y
++CONFIG_SPI_MT65XX=y
++CONFIG_SPI_MTK_NOR=m
++CONFIG_SPI_OMAP24XX=m
++CONFIG_MTD_OF_PARTS=y
++CONFIG_MTD_SPI_NOR_SWP_DISABLE_ON_VOLATILE=y
++CONFIG_HIGH_RES_TIMERS=y
++CONFIG_BSP_VER_INFO=y
++CONFIG_CC_REV_INFO=y
++CONFIG_SOM_REV_INFO=y
++CONFIG_BPF_SYSCALL=y
++CONFIG_BPF_JIT=y
++CONFIG_PREEMPT=y
++CONFIG_IRQ_TIME_ACCOUNTING=y
++CONFIG_BSD_PROCESS_ACCT=y
++CONFIG_BSD_PROCESS_ACCT_V3=y
++CONFIG_TASKSTATS=y
++CONFIG_TASK_XACCT=y
++CONFIG_RTC_DRV_DA9063=y
++CONFIG_TASK_IO_ACCOUNTING=y
++CONFIG_IKCONFIG=y
++CONFIG_CC_I2C_BUS=0
++CONFIG_CC_EEPROM_ADDR=0x52
++CONFIG_SOM_I2C_BUS=0
++CONFIG_SOM_EEPROM_ADDR=0X56
++CONFIG_IKCONFIG_PROC=y
++CONFIG_NUMA_BALANCING=y
++CONFIG_MEMCG=y
++CONFIG_BLK_CGROUP=y
++CONFIG_CGROUP_PIDS=y
++CONFIG_CGROUP_FREEZER=y
++CONFIG_CGROUP_HUGETLB=y
++CONFIG_CPUSETS=y
++CONFIG_CGROUP_DEVICE=y
++CONFIG_CGROUP_CPUACCT=y
++CONFIG_CGROUP_PERF=y
++CONFIG_CGROUP_BPF=y
++CONFIG_USER_NS=y
++CONFIG_SCHED_AUTOGROUP=y
++CONFIG_BLK_DEV_INITRD=y
++CONFIG_EXPERT=y
++CONFIG_KALLSYMS_ALL=y
++CONFIG_PROFILING=y
++CONFIG_KEXEC=y
++CONFIG_KEXEC_FILE=y
++CONFIG_CRASH_DUMP=y
++CONFIG_ARCH_ACTIONS=y
++CONFIG_ARCH_AIROHA=y
++CONFIG_ARCH_SUNXI=y
++CONFIG_ARCH_ALPINE=y
++CONFIG_ARCH_APPLE=y
++CONFIG_ARCH_BCM=y
++CONFIG_ARCH_BCM2835=y
++CONFIG_ARCH_BCM_IPROC=y
++CONFIG_ARCH_BCMBCA=y
++CONFIG_ARCH_BRCMSTB=y
++CONFIG_ARCH_DM=y
++CONFIG_ARCH_BERLIN=y
++CONFIG_ARCH_EXYNOS=y
++CONFIG_ARCH_SPARX5=y
++CONFIG_ARCH_K3=y
++CONFIG_ARCH_LG1K=y
++CONFIG_ARCH_HISI=y
++CONFIG_ARCH_KEEMBAY=y
++CONFIG_ARCH_MEDIATEK=y
++CONFIG_ARCH_MESON=y
++CONFIG_ARCH_MVEBU=y
++CONFIG_ARCH_NXP=y
++CONFIG_ARCH_LAYERSCAPE=y
++CONFIG_ARCH_MXC=y
++CONFIG_ARCH_S32=y
++CONFIG_ARCH_MA35=y
++CONFIG_ARCH_NPCM=y
++CONFIG_ARCH_QCOM=y
++CONFIG_ARCH_REALTEK=y
++CONFIG_ARCH_RENESAS=y
++CONFIG_ARCH_ROCKCHIP=y
++CONFIG_ARCH_SEATTLE=y
++CONFIG_ARCH_INTEL_SOCFPGA=y
++CONFIG_ARCH_STM32=y
++CONFIG_ARCH_SYNQUACER=y
++CONFIG_ARCH_TEGRA=y
++CONFIG_ARCH_TESLA_FSD=y
++CONFIG_ARCH_SPRD=y
++CONFIG_ARCH_THUNDER=y
++CONFIG_ARCH_THUNDER2=y
++CONFIG_ARCH_UNIPHIER=y
++CONFIG_ARCH_VEXPRESS=y
++CONFIG_ARCH_VISCONTI=y
++CONFIG_ARCH_XGENE=y
++CONFIG_ARCH_ZYNQMP=y
++CONFIG_SCHED_MC=y
++CONFIG_SCHED_SMT=y
++CONFIG_NUMA=y
++CONFIG_XEN=y
++CONFIG_COMPAT=y
++CONFIG_RANDOMIZE_BASE=y
++CONFIG_HIBERNATION=y
++CONFIG_WQ_POWER_EFFICIENT_DEFAULT=y
++CONFIG_ENERGY_MODEL=y
++CONFIG_ARM_PSCI_CPUIDLE=y
++CONFIG_CPU_FREQ=y
++CONFIG_CPU_FREQ_STAT=y
++CONFIG_CPU_FREQ_GOV_POWERSAVE=m
++CONFIG_CPU_FREQ_GOV_USERSPACE=y
++CONFIG_CPU_FREQ_GOV_ONDEMAND=y
++CONFIG_CPU_FREQ_GOV_CONSERVATIVE=m
++CONFIG_CPUFREQ_DT=y
++CONFIG_ACPI_CPPC_CPUFREQ=m
++CONFIG_ARM_ALLWINNER_SUN50I_CPUFREQ_NVMEM=m
++CONFIG_ARM_ARMADA_37XX_CPUFREQ=y
++CONFIG_ARM_SCPI_CPUFREQ=y
++CONFIG_ARM_IMX_CPUFREQ_DT=m
++CONFIG_ARM_MEDIATEK_CPUFREQ=y
++CONFIG_ARM_QCOM_CPUFREQ_NVMEM=y
++CONFIG_ARM_QCOM_CPUFREQ_HW=y
++CONFIG_ARM_RASPBERRYPI_CPUFREQ=m
++CONFIG_ARM_SCMI_CPUFREQ=y
++CONFIG_ARM_TEGRA186_CPUFREQ=y
++CONFIG_QORIQ_CPUFREQ=y
++CONFIG_ACPI=y
++CONFIG_ACPI_HOTPLUG_MEMORY=y
++CONFIG_ACPI_HMAT=y
++CONFIG_ACPI_APEI=y
++CONFIG_ACPI_APEI_GHES=y
++CONFIG_ACPI_APEI_PCIEAER=y
++CONFIG_ACPI_APEI_MEMORY_FAILURE=y
++CONFIG_ACPI_APEI_EINJ=y
++CONFIG_VIRTUALIZATION=y
++CONFIG_KVM=y
++CONFIG_CRYPTO_DEV_INTEL_FCS=m
++CONFIG_JUMP_LABEL=y
++CONFIG_MODULES=y
++CONFIG_MODULE_UNLOAD=y
++CONFIG_IOSCHED_BFQ=y
++CONFIG_MEMORY_HOTPLUG=y
++CONFIG_MEMORY_HOTREMOVE=y
++CONFIG_KSM=y
++CONFIG_MEMORY_FAILURE=y
++CONFIG_TRANSPARENT_HUGEPAGE=y
++CONFIG_NET=y
++CONFIG_PACKET=y
++CONFIG_UNIX=y
++CONFIG_INET=y
++CONFIG_IP_MULTICAST=y
++CONFIG_IP_PNP=y
++CONFIG_IP_PNP_DHCP=y
++CONFIG_IP_PNP_BOOTP=y
++CONFIG_IPV6=m
++CONFIG_NETFILTER=y
++CONFIG_BRIDGE_NETFILTER=m
++CONFIG_NF_CONNTRACK=m
++CONFIG_NF_CONNTRACK_EVENTS=y
++CONFIG_NETFILTER_XT_MARK=m
++CONFIG_NETFILTER_XT_TARGET_CHECKSUM=m
++CONFIG_NETFILTER_XT_TARGET_LOG=m
++CONFIG_NETFILTER_XT_MATCH_ADDRTYPE=m
++CONFIG_NETFILTER_XT_MATCH_CONNTRACK=m
++CONFIG_NETFILTER_XT_MATCH_IPVS=m
++CONFIG_IP_VS=m
++CONFIG_IP_NF_IPTABLES=m
++CONFIG_IP_NF_FILTER=m
++CONFIG_IP_NF_TARGET_REJECT=m
++CONFIG_IP_NF_NAT=m
++CONFIG_IP_NF_TARGET_MASQUERADE=m
++CONFIG_IP_NF_MANGLE=m
++CONFIG_IP6_NF_IPTABLES=m
++CONFIG_IP6_NF_FILTER=m
++CONFIG_IP6_NF_TARGET_REJECT=m
++CONFIG_IP6_NF_MANGLE=m
++CONFIG_IP6_NF_NAT=m
++CONFIG_IP6_NF_TARGET_MASQUERADE=m
++CONFIG_BRIDGE=m
++CONFIG_BRIDGE_VLAN_FILTERING=y
++CONFIG_NET_DSA=m
++CONFIG_VLAN_8021Q=m
++CONFIG_VLAN_8021Q_GVRP=y
++CONFIG_VLAN_8021Q_MVRP=y
++CONFIG_NET_SCHED=y
++CONFIG_NET_SCH_CBS=m
++CONFIG_NET_SCH_ETF=m
++CONFIG_NET_SCH_TAPRIO=m
++CONFIG_NET_SCH_MQPRIO=m
++CONFIG_NET_SCH_INGRESS=m
++CONFIG_NET_CLS_BASIC=m
++CONFIG_NET_CLS_FLOWER=m
++CONFIG_NET_CLS_ACT=y
++CONFIG_NET_ACT_GACT=m
++CONFIG_NET_ACT_MIRRED=m
++CONFIG_NET_ACT_GATE=m
++CONFIG_QRTR_SMD=m
++CONFIG_QRTR_TUN=m
++CONFIG_CAN=m
++CONFIG_BT=m
++CONFIG_BT_HIDP=m
++CONFIG_BT_LEDS=y
++CONFIG_BT_HCIBTUSB=m
++CONFIG_BT_HCIBTUSB_MTK=y
++CONFIG_BT_HCIUART=m
++CONFIG_BT_HCIUART_LL=y
++CONFIG_BT_HCIUART_BCM=y
++CONFIG_BT_HCIUART_QCA=y
++CONFIG_BT_HCIUART_MRVL=y
++CONFIG_BT_MRVL=m
++CONFIG_BT_MRVL_SDIO=m
++CONFIG_BT_QCOMSMD=m
++CONFIG_BT_NXPUART=m
++CONFIG_CFG80211=m
++CONFIG_MAC80211=m
++CONFIG_MAC80211_LEDS=y
++CONFIG_RFKILL=m
++CONFIG_NET_9P=y
++CONFIG_NET_9P_VIRTIO=y
++CONFIG_NFC=m
++CONFIG_NFC_NCI=m
++CONFIG_NFC_S3FWRN5_I2C=m
++CONFIG_PCI=y
++CONFIG_PCIEPORTBUS=y
++CONFIG_PCIEAER=y
++CONFIG_PCI_IOV=y
++CONFIG_PCI_PASID=y
++CONFIG_HOTPLUG_PCI=y
++CONFIG_HOTPLUG_PCI_ACPI=y
++CONFIG_PCI_AARDVARK=y
++CONFIG_PCIE_ALTERA=y
++CONFIG_PCIE_ALTERA_MSI=y
++CONFIG_PCIE_BRCMSTB=m
++CONFIG_PCI_HOST_THUNDER_PEM=y
++CONFIG_PCI_HOST_THUNDER_ECAM=y
++CONFIG_PCI_HOST_GENERIC=y
++CONFIG_PCIE_MEDIATEK_GEN3=m
++CONFIG_PCI_TEGRA=y
++CONFIG_PCIE_RCAR_HOST=y
++CONFIG_PCIE_RCAR_EP=y
++CONFIG_PCIE_ROCKCHIP_HOST=m
++CONFIG_PCI_XGENE=y
++CONFIG_PCI_IMX6_HOST=y
++CONFIG_PCI_LAYERSCAPE=y
++CONFIG_PCI_HISI=y
++CONFIG_PCIE_KIRIN=y
++CONFIG_PCIE_HISI_STB=y
++CONFIG_PCIE_ARMADA_8K=y
++CONFIG_PCIE_TEGRA194_HOST=m
++CONFIG_PCIE_TEGRA194_EP=m
++CONFIG_PCIE_QCOM=y
++CONFIG_PCIE_RCAR_GEN4_HOST=m
++CONFIG_PCIE_RCAR_GEN4_EP=m
++CONFIG_PCIE_ROCKCHIP_DW_HOST=y
++CONFIG_PCIE_VISCONTI_HOST=y
++CONFIG_PCIE_LAYERSCAPE_GEN4=y
++CONFIG_PCI_ENDPOINT=y
++CONFIG_PCI_ENDPOINT_CONFIGFS=y
++CONFIG_PCI_EPF_TEST=m
++CONFIG_DEVTMPFS=y
++CONFIG_DEVTMPFS_MOUNT=y
++CONFIG_FW_LOADER_USER_HELPER=y
++CONFIG_HISILICON_LPC=y
++CONFIG_TEGRA_ACONNECT=m
++CONFIG_MHI_BUS_PCI_GENERIC=m
++CONFIG_ARM_SCMI_PROTOCOL=y
++CONFIG_ARM_SCPI_PROTOCOL=y
++CONFIG_RASPBERRYPI_FIRMWARE=y
++CONFIG_INTEL_STRATIX10_SERVICE=y
++CONFIG_MTK_ADSP_IPC=m
++CONFIG_GOOGLE_FIRMWARE=y
++CONFIG_GOOGLE_CBMEM=m
++CONFIG_GOOGLE_COREBOOT_TABLE=m
++CONFIG_EFI_CAPSULE_LOADER=y
++CONFIG_IMX_SCU=y
++CONFIG_QCOM_TZMEM_MODE_SHMBRIDGE=y
++CONFIG_QCOM_QSEECOM=y
++CONFIG_QCOM_QSEECOM_UEFISECAPP=y
++CONFIG_GNSS=m
++CONFIG_GNSS_MTK_SERIAL=m
++CONFIG_MTD=y
++CONFIG_MTD_BLOCK=y
++CONFIG_MTD_CFI=y
++CONFIG_MTD_CFI_ADV_OPTIONS=y
++CONFIG_MTD_CFI_INTELEXT=y
++CONFIG_MTD_CFI_AMDSTD=y
++CONFIG_MTD_CFI_STAA=y
++CONFIG_MTD_PHYSMAP=y
++CONFIG_MTD_PHYSMAP_OF=y
++CONFIG_MTD_DATAFLASH=y
++CONFIG_MTD_SST25L=y
++CONFIG_MTD_RAW_NAND=y
++CONFIG_MTD_NAND_DENALI_DT=y
++CONFIG_MTD_NAND_MARVELL=y
++CONFIG_MTD_NAND_BRCMNAND=m
++CONFIG_MTD_NAND_FSL_IFC=y
++CONFIG_MTD_NAND_QCOM=y
++CONFIG_MTD_SPI_NOR=y
++CONFIG_MTD_HYPERBUS=m
++CONFIG_HBMC_AM654=m
++CONFIG_BLK_DEV_LOOP=y
++CONFIG_BLK_DEV_NBD=m
++CONFIG_VIRTIO_BLK=y
++CONFIG_BLK_DEV_NVME=m
++CONFIG_QCOM_COINCELL=m
++CONFIG_QCOM_FASTRPC=m
++CONFIG_SRAM=y
++CONFIG_PCI_ENDPOINT_TEST=m
++CONFIG_EEPROM_AT24=y
++CONFIG_ALTERA_SYSID=y
++CONFIG_ALTERA_ILC=m
++CONFIG_EEPROM_AT25=m
++CONFIG_UACCE=m
++CONFIG_BLK_DEV_SD=y
++CONFIG_SCSI_SAS_ATA=y
++CONFIG_SCSI_HISI_SAS=y
++CONFIG_SCSI_HISI_SAS_PCI=y
++CONFIG_MEGARAID_SAS=y
++CONFIG_SCSI_MPT3SAS=m
++CONFIG_ATA=y
++CONFIG_SATA_AHCI=y
++CONFIG_SATA_AHCI_PLATFORM=y
++CONFIG_AHCI_BRCM=m
++CONFIG_AHCI_DWC=m
++CONFIG_AHCI_CEVA=y
++CONFIG_AHCI_MVEBU=y
++CONFIG_AHCI_XGENE=y
++CONFIG_AHCI_QORIQ=y
++CONFIG_SATA_SIL24=y
++CONFIG_SATA_RCAR=y
++CONFIG_PATA_PLATFORM=y
++CONFIG_PATA_OF_PLATFORM=y
++CONFIG_MD=y
++CONFIG_BLK_DEV_MD=m
++CONFIG_BLK_DEV_DM=m
++CONFIG_DM_MIRROR=m
++CONFIG_DM_ZERO=m
++CONFIG_NETDEVICES=y
++CONFIG_MACVLAN=m
++CONFIG_MACVTAP=m
++CONFIG_TUN=y
++CONFIG_VETH=m
++CONFIG_VIRTIO_NET=y
++CONFIG_MHI_NET=m
++CONFIG_NET_DSA_BCM_SF2=m
++CONFIG_NET_DSA_MSCC_FELIX=m
++CONFIG_AMD_XGBE=y
++CONFIG_NET_XGENE=y
++CONFIG_ATL1C=m
++CONFIG_BCMGENET=m
++CONFIG_BNX2X=m
++CONFIG_SYSTEMPORT=m
++CONFIG_MACB=y
++CONFIG_THUNDER_NIC_PF=y
++CONFIG_FEC=y
++CONFIG_FSL_FMAN=y
++CONFIG_FSL_DPAA_ETH=y
++CONFIG_FSL_DPAA2_ETH=y
++CONFIG_FSL_ENETC=y
++CONFIG_FSL_ENETC_VF=y
++CONFIG_FSL_ENETC_QOS=y
++CONFIG_HIX5HD2_GMAC=y
++CONFIG_HNS_DSAF=y
++CONFIG_HNS_ENET=y
++CONFIG_HNS3=y
++CONFIG_HNS3_HCLGE=y
++CONFIG_HNS3_ENET=y
++CONFIG_E1000=y
++CONFIG_E1000E=y
++CONFIG_IGB=y
++CONFIG_IGBVF=y
++CONFIG_MVNETA=y
++CONFIG_MVPP2=y
++CONFIG_SKY2=y
++CONFIG_MLX4_EN=m
++CONFIG_MLX5_CORE=m
++CONFIG_MLX5_CORE_EN=y
++CONFIG_QCOM_EMAC=m
++CONFIG_RMNET=m
++CONFIG_R8169=m
++CONFIG_SH_ETH=y
++CONFIG_RAVB=y
++CONFIG_RENESAS_ETHER_SWITCH=y
++CONFIG_RTSN=y
++CONFIG_SMC91X=y
++CONFIG_SMSC911X=y
++CONFIG_SNI_AVE=y
++CONFIG_SNI_NETSEC=y
++CONFIG_DWMAC_TEGRA=m
++CONFIG_STMMAC_ETH=y
++CONFIG_TI_K3_AM65_CPSW_NUSS=y
++CONFIG_TI_ICSSG_PRUETH=m
++CONFIG_QCOM_IPA=m
++CONFIG_MESON_GXL_PHY=m
++CONFIG_AQUANTIA_PHY=y
++CONFIG_BCM54140_PHY=m
++CONFIG_MARVELL_PHY=m
++CONFIG_MARVELL_10G_PHY=y
++CONFIG_MARVELL_88Q2XXX_PHY=y
++CONFIG_MICREL_PHY=y
++CONFIG_MICROSEMI_PHY=y
++CONFIG_AT803X_PHY=y
++CONFIG_REALTEK_PHY=y
++CONFIG_ROCKCHIP_PHY=y
++CONFIG_DP83867_PHY=y
++CONFIG_DP83869_PHY=m
++CONFIG_DP83TD510_PHY=y
++CONFIG_VITESSE_PHY=y
++CONFIG_CAN_FLEXCAN=m
++CONFIG_CAN_M_CAN=m
++CONFIG_CAN_M_CAN_PLATFORM=m
++CONFIG_CAN_RCAR=m
++CONFIG_CAN_RCAR_CANFD=m
++CONFIG_CAN_MCP251XFD=m
++CONFIG_MDIO_GPIO=y
++CONFIG_MDIO_BUS_MUX_MULTIPLEXER=y
++CONFIG_MDIO_BUS_MUX_MMIOREG=y
++CONFIG_USB_PEGASUS=m
++CONFIG_USB_RTL8150=m
++CONFIG_USB_RTL8152=m
++CONFIG_USB_LAN78XX=m
++CONFIG_USB_USBNET=m
++CONFIG_USB_NET_DM9601=m
++CONFIG_USB_NET_SR9800=m
++CONFIG_USB_NET_SMSC75XX=m
++CONFIG_USB_NET_SMSC95XX=m
++CONFIG_USB_NET_PLUSB=m
++CONFIG_USB_NET_MCS7830=m
++CONFIG_ATH10K=m
++CONFIG_ATH10K_PCI=m
++CONFIG_ATH10K_SDIO=m
++CONFIG_ATH10K_SNOC=m
++CONFIG_WCN36XX=m
++CONFIG_ATH11K=m
++CONFIG_ATH11K_AHB=m
++CONFIG_ATH11K_PCI=m
++CONFIG_ATH12K=m
++CONFIG_BRCMFMAC=m
++CONFIG_IWLWIFI=m
++CONFIG_IWLDVM=m
++CONFIG_IWLMVM=m
++CONFIG_MWIFIEX=m
++CONFIG_MWIFIEX_SDIO=m
++CONFIG_MWIFIEX_PCIE=m
++CONFIG_MT7921E=m
++CONFIG_RSI_91X=m
++CONFIG_WL18XX=m
++CONFIG_WLCORE_SDIO=m
++CONFIG_WWAN=m
++CONFIG_MHI_WWAN_CTRL=m
++CONFIG_MHI_WWAN_MBIM=m
++CONFIG_INPUT_EVDEV=y
++CONFIG_KEYBOARD_ADC=m
++CONFIG_KEYBOARD_GPIO=y
++CONFIG_KEYBOARD_GPIO_POLLED=m
++CONFIG_KEYBOARD_SNVS_PWRKEY=m
++CONFIG_KEYBOARD_IMX_SC_KEY=m
++CONFIG_KEYBOARD_CROS_EC=y
++CONFIG_KEYBOARD_MTK_PMIC=m
++CONFIG_MOUSE_ELAN_I2C=m
++CONFIG_INPUT_TOUCHSCREEN=y
++CONFIG_TOUCHSCREEN_ATMEL_MXT=m
++CONFIG_TOUCHSCREEN_GOODIX=m
++CONFIG_TOUCHSCREEN_GOODIX_BERLIN_SPI=m
++CONFIG_TOUCHSCREEN_ELAN=m
++CONFIG_TOUCHSCREEN_EDT_FT5X06=m
++CONFIG_INPUT_MISC=y
++CONFIG_INPUT_BBNSM_PWRKEY=m
++CONFIG_INPUT_PM8941_PWRKEY=y
++CONFIG_INPUT_PM8XXX_VIBRATOR=m
++CONFIG_INPUT_TPS65219_PWRBUTTON=m
++CONFIG_INPUT_PWM_BEEPER=m
++CONFIG_INPUT_PWM_VIBRA=m
++CONFIG_INPUT_RK805_PWRKEY=m
++CONFIG_INPUT_DA9063_ONKEY=m
++CONFIG_INPUT_HISI_POWERKEY=y
++CONFIG_SERIO_AMBAKMI=y
++CONFIG_LEGACY_PTY_COUNT=16
++CONFIG_SERIAL_8250=y
++CONFIG_SERIAL_8250_CONSOLE=y
++CONFIG_SERIAL_8250_NR_UARTS=8
++CONFIG_SERIAL_8250_EXTENDED=y
++CONFIG_SERIAL_8250_SHARE_IRQ=y
++CONFIG_SERIAL_8250_BCM2835AUX=y
++CONFIG_SERIAL_8250_DW=y
++CONFIG_SERIAL_8250_EM=y
++CONFIG_SERIAL_8250_OMAP=y
++CONFIG_SERIAL_8250_MT6577=y
++CONFIG_SERIAL_8250_UNIPHIER=y
++CONFIG_SERIAL_OF_PLATFORM=y
++CONFIG_SERIAL_AMBA_PL011=y
++CONFIG_SERIAL_AMBA_PL011_CONSOLE=y
++CONFIG_SERIAL_MESON=y
++CONFIG_SERIAL_MESON_CONSOLE=y
++CONFIG_SERIAL_SAMSUNG=y
++CONFIG_SERIAL_SAMSUNG_CONSOLE=y
++CONFIG_SERIAL_TEGRA=y
++CONFIG_SERIAL_TEGRA_TCU=y
++CONFIG_SERIAL_IMX=y
++CONFIG_SERIAL_IMX_CONSOLE=y
++CONFIG_SERIAL_SH_SCI=y
++CONFIG_SERIAL_MSM=y
++CONFIG_SERIAL_MSM_CONSOLE=y
++CONFIG_SERIAL_QCOM_GENI=y
++CONFIG_SERIAL_QCOM_GENI_CONSOLE=y
++CONFIG_SERIAL_XILINX_PS_UART=y
++CONFIG_SERIAL_XILINX_PS_UART_CONSOLE=y
++CONFIG_SERIAL_FSL_LPUART=y
++CONFIG_SERIAL_FSL_LPUART_CONSOLE=y
++CONFIG_SERIAL_FSL_LINFLEXUART=y
++CONFIG_SERIAL_FSL_LINFLEXUART_CONSOLE=y
++CONFIG_SERIAL_STM32=y
++CONFIG_SERIAL_STM32_CONSOLE=y
++CONFIG_SERIAL_MVEBU_UART=y
++CONFIG_SERIAL_OWL=y
++CONFIG_SERIAL_DEV_BUS=y
++CONFIG_VIRTIO_CONSOLE=y
++CONFIG_IPMI_HANDLER=m
++CONFIG_IPMI_DEVICE_INTERFACE=m
++CONFIG_IPMI_SI=m
++CONFIG_HW_RANDOM=m
++CONFIG_HW_RANDOM_VIRTIO=y
++CONFIG_TCG_TPM=y
++CONFIG_TCG_TIS=m
++CONFIG_TCG_TIS_SPI=m
++CONFIG_TCG_TIS_SPI_CR50=y
++CONFIG_TCG_TIS_I2C_CR50=m
++CONFIG_TCG_TIS_I2C_INFINEON=y
++CONFIG_I2C_CHARDEV=y
++CONFIG_I2C_MUX=y
++CONFIG_I2C_MUX_PCA954x=y
++CONFIG_I2C_BCM2835=m
++CONFIG_I2C_CADENCE=m
++CONFIG_I2C_DESIGNWARE_CORE=y
++CONFIG_I2C_DESIGNWARE_PLATFORM=y
++CONFIG_I2C_GPIO=m
++CONFIG_I2C_IMX=y
++CONFIG_I2C_IMX_LPI2C=y
++CONFIG_I2C_MESON=y
++CONFIG_I2C_MT65XX=y
++CONFIG_I2C_MV64XXX=y
++CONFIG_I2C_OMAP=y
++CONFIG_I2C_OWL=y
++CONFIG_I2C_PXA=y
++CONFIG_I2C_QCOM_CCI=m
++CONFIG_I2C_QCOM_GENI=m
++CONFIG_I2C_QUP=y
++CONFIG_I2C_RIIC=y
++CONFIG_I2C_RK3X=y
++CONFIG_I2C_RZV2M=m
++CONFIG_I2C_S3C2410=y
++CONFIG_I2C_SH_MOBILE=y
++CONFIG_I2C_TEGRA=y
++CONFIG_I2C_UNIPHIER_F=y
++CONFIG_I2C_RCAR=y
++CONFIG_I2C_CROS_EC_TUNNEL=y
++CONFIG_SPI=y
++CONFIG_SPI_ARMADA_3700=y
++CONFIG_SPI_BCM2835=m
++CONFIG_SPI_BCM2835AUX=m
++CONFIG_SPI_CADENCE_QUADSPI=y
++CONFIG_SPI_DESIGNWARE=m
++CONFIG_SPI_DW_DMA=y
++CONFIG_SPI_DW_MMIO=m
++CONFIG_SPI_FSL_LPSPI=y
++CONFIG_SPI_FSL_QUADSPI=y
++CONFIG_SPI_NXP_FLEXSPI=y
++CONFIG_SPI_IMX=m
++CONFIG_SPI_FSL_DSPI=y
++CONFIG_SPI_MESON_SPICC=m
++CONFIG_SPI_MESON_SPIFC=m
++CONFIG_SPI_ORION=y
++CONFIG_SPI_PL022=y
++CONFIG_SPI_ROCKCHIP=y
++CONFIG_SPI_ROCKCHIP_SFC=m
++CONFIG_SPI_RPCIF=m
++CONFIG_SPI_RSPI=m
++CONFIG_SPI_RZV2M_CSI=m
++CONFIG_SPI_QCOM_QSPI=m
++CONFIG_SPI_QUP=y
++CONFIG_SPI_QCOM_GENI=m
++CONFIG_SPI_S3C64XX=y
++CONFIG_SPI_SH_MSIOF=m
++CONFIG_SPI_SUN6I=y
++CONFIG_SPI_TEGRA210_QUAD=m
++CONFIG_SPI_TEGRA114=m
++CONFIG_SPI_SPIDEV=m
++CONFIG_SPMI=y
++CONFIG_SPMI_MTK_PMIF=m
++CONFIG_PINCTRL_DA9062=y
++CONFIG_PINCTRL_MAX77620=y
++CONFIG_PINCTRL_RK805=m
++CONFIG_PINCTRL_SINGLE=y
++CONFIG_PINCTRL_OWL=y
++CONFIG_PINCTRL_S700=y
++CONFIG_PINCTRL_S900=y
++CONFIG_PINCTRL_IMX8MM=y
++CONFIG_PINCTRL_IMX8MN=y
++CONFIG_PINCTRL_IMX8MP=y
++CONFIG_PINCTRL_IMX8MQ=y
++CONFIG_PINCTRL_IMX8QM=y
++CONFIG_PINCTRL_IMX8QXP=y
++CONFIG_PINCTRL_IMX8DXL=y
++CONFIG_PINCTRL_IMX8ULP=y
++CONFIG_PINCTRL_IMX93=y
++CONFIG_PINCTRL_MSM=y
++CONFIG_PINCTRL_IPQ5018=y
++CONFIG_PINCTRL_IPQ5332=y
++CONFIG_PINCTRL_IPQ8074=y
++CONFIG_PINCTRL_IPQ6018=y
++CONFIG_PINCTRL_IPQ9574=y
++CONFIG_PINCTRL_MSM8916=y
++CONFIG_PINCTRL_MSM8953=y
++CONFIG_PINCTRL_MSM8976=y
++CONFIG_PINCTRL_MSM8994=y
++CONFIG_PINCTRL_MSM8996=y
++CONFIG_PINCTRL_MSM8998=y
++CONFIG_PINCTRL_QCM2290=y
++CONFIG_PINCTRL_QCS404=y
++CONFIG_PINCTRL_QDF2XXX=y
++CONFIG_PINCTRL_QDU1000=y
++CONFIG_PINCTRL_SA8775P=y
++CONFIG_PINCTRL_SC7180=y
++CONFIG_PINCTRL_SC7280=y
++CONFIG_PINCTRL_SC8180X=y
++CONFIG_PINCTRL_SC8280XP=y
++CONFIG_PINCTRL_SDM660=y
++CONFIG_PINCTRL_SDM670=y
++CONFIG_PINCTRL_SDM845=y
++CONFIG_PINCTRL_SDX75=y
++CONFIG_PINCTRL_SM4450=y
++CONFIG_PINCTRL_SM6115=y
++CONFIG_PINCTRL_SM6125=y
++CONFIG_PINCTRL_SM6350=y
++CONFIG_PINCTRL_SM6375=y
++CONFIG_PINCTRL_SM8150=y
++CONFIG_PINCTRL_SM8250=y
++CONFIG_PINCTRL_SM8350=y
++CONFIG_PINCTRL_SM8450=y
++CONFIG_PINCTRL_SM8550=y
++CONFIG_PINCTRL_SM8650=y
++CONFIG_PINCTRL_X1E80100=y
++CONFIG_PINCTRL_QCOM_SPMI_PMIC=y
++CONFIG_PINCTRL_LPASS_LPI=m
++CONFIG_PINCTRL_SC7280_LPASS_LPI=m
++CONFIG_PINCTRL_SM6115_LPASS_LPI=m
++CONFIG_PINCTRL_SM8250_LPASS_LPI=m
++CONFIG_PINCTRL_SM8350_LPASS_LPI=m
++CONFIG_PINCTRL_SM8450_LPASS_LPI=m
++CONFIG_PINCTRL_SC8280XP_LPASS_LPI=m
++CONFIG_PINCTRL_SM8550_LPASS_LPI=m
++CONFIG_PINCTRL_SM8650_LPASS_LPI=m
++CONFIG_DEBUG_GPIO=y
++CONFIG_GPIO_SYSFS=y
++CONFIG_GPIO_ALTERA=y
++CONFIG_GPIO_DAVINCI=y
++CONFIG_GPIO_DWAPB=y
++CONFIG_GPIO_MB86S7X=y
++CONFIG_GPIO_MPC8XXX=y
++CONFIG_GPIO_MXC=y
++CONFIG_GPIO_PL061=y
++CONFIG_GPIO_RCAR=y
++CONFIG_GPIO_SYSCON=y
++CONFIG_GPIO_UNIPHIER=y
++CONFIG_GPIO_VISCONTI=y
++CONFIG_GPIO_WCD934X=m
++CONFIG_GPIO_VF610=y
++CONFIG_GPIO_XGENE=y
++CONFIG_GPIO_XGENE_SB=y
++CONFIG_GPIO_MAX732X=y
++CONFIG_GPIO_PCA953X=y
++CONFIG_GPIO_PCA953X_IRQ=y
++CONFIG_GPIO_ADP5585=m
++CONFIG_GPIO_BD9571MWV=m
++CONFIG_GPIO_MAX77620=y
++CONFIG_GPIO_SL28CPLD=m
++CONFIG_GPIO_AGGREGATOR=m
++CONFIG_POWER_RESET_MSM=y
++CONFIG_POWER_RESET_QCOM_PON=m
++CONFIG_POWER_RESET_XGENE=y
++CONFIG_POWER_RESET_SYSCON=y
++CONFIG_POWER_RESET_SYSCON_POWEROFF=y
++CONFIG_SYSCON_REBOOT_MODE=y
++CONFIG_NVMEM_REBOOT_MODE=m
++CONFIG_BATTERY_QCOM_BATTMGR=m
++CONFIG_BATTERY_SBS=m
++CONFIG_BATTERY_BQ27XXX=y
++CONFIG_BATTERY_MAX17042=m
++CONFIG_CHARGER_MT6360=m
++CONFIG_CHARGER_BQ25890=m
++CONFIG_CHARGER_BQ25980=m
++CONFIG_CHARGER_RK817=m
++CONFIG_SENSORS_ARM_SCMI=y
++CONFIG_SENSORS_ARM_SCPI=y
++CONFIG_SENSORS_GPIO_FAN=m
++CONFIG_SENSORS_JC42=m
++CONFIG_SENSORS_LM75=m
++CONFIG_SENSORS_LM90=m
++CONFIG_SENSORS_PWM_FAN=m
++CONFIG_SENSORS_RASPBERRYPI_HWMON=m
++CONFIG_SENSORS_SL28CPLD=m
++CONFIG_SENSORS_SOC64=y
++CONFIG_SENSORS_INA2XX=m
++CONFIG_SENSORS_INA3221=m
++CONFIG_THERMAL_GOV_POWER_ALLOCATOR=y
++CONFIG_CPU_THERMAL=y
++CONFIG_DEVFREQ_THERMAL=y
++CONFIG_THERMAL_EMULATION=y
++CONFIG_IMX_SC_THERMAL=m
++CONFIG_IMX8MM_THERMAL=m
++CONFIG_K3_THERMAL=m
++CONFIG_QORIQ_THERMAL=m
++CONFIG_SUN8I_THERMAL=y
++CONFIG_ROCKCHIP_THERMAL=m
++CONFIG_RCAR_THERMAL=y
++CONFIG_RCAR_GEN3_THERMAL=y
++CONFIG_RZG2L_THERMAL=y
++CONFIG_ARMADA_THERMAL=y
++CONFIG_MTK_THERMAL=m
++CONFIG_MTK_LVTS_THERMAL=m
++CONFIG_BCM2711_THERMAL=m
++CONFIG_BCM2835_THERMAL=m
++CONFIG_BRCMSTB_THERMAL=m
++CONFIG_EXYNOS_THERMAL=y
++CONFIG_TEGRA_SOCTHERM=m
++CONFIG_TEGRA_BPMP_THERMAL=m
++CONFIG_GENERIC_ADC_THERMAL=m
++CONFIG_QCOM_TSENS=y
++CONFIG_QCOM_SPMI_ADC_TM5=m
++CONFIG_QCOM_SPMI_TEMP_ALARM=m
++CONFIG_QCOM_LMH=m
++CONFIG_UNIPHIER_THERMAL=y
++CONFIG_KHADAS_MCU_FAN_THERMAL=m
++CONFIG_WATCHDOG=y
++CONFIG_SL28CPLD_WATCHDOG=m
++CONFIG_ARM_SP805_WATCHDOG=y
++CONFIG_ARM_SBSA_WATCHDOG=y
++CONFIG_S3C2410_WATCHDOG=y
++CONFIG_DW_WATCHDOG=y
++CONFIG_K3_RTI_WATCHDOG=m
++CONFIG_SUNXI_WATCHDOG=m
++CONFIG_NPCM7XX_WATCHDOG=y
++CONFIG_IMX2_WDT=y
++CONFIG_IMX_SC_WDT=m
++CONFIG_IMX7ULP_WDT=m
++CONFIG_QCOM_WDT=m
++CONFIG_MESON_GXBB_WATCHDOG=m
++CONFIG_MESON_WATCHDOG=m
++CONFIG_ARM_SMC_WATCHDOG=y
++CONFIG_RENESAS_WDT=y
++CONFIG_RENESAS_RZG2LWDT=y
++CONFIG_UNIPHIER_WATCHDOG=y
++CONFIG_PM8916_WATCHDOG=m
++CONFIG_BCM2835_WDT=y
++CONFIG_BCM7038_WDT=m
++CONFIG_MFD_ADP5585=m
++CONFIG_MFD_ALTERA_SYSMGR=y
++CONFIG_MFD_BD9571MWV=y
++CONFIG_MFD_AXP20X_I2C=y
++CONFIG_MFD_AXP20X_RSB=y
++CONFIG_MFD_DA9062=y
++CONFIG_MFD_EXYNOS_LPASS=m
++CONFIG_MFD_HI6421_PMIC=y
++CONFIG_MFD_HI655X_PMIC=y
++CONFIG_MFD_MAX77620=y
++CONFIG_MFD_MT6360=y
++CONFIG_MFD_MT6397=y
++CONFIG_MFD_SPMI_PMIC=y
++CONFIG_MFD_RK8XX_I2C=y
++CONFIG_MFD_RK8XX_SPI=y
++CONFIG_MFD_SEC_CORE=y
++CONFIG_MFD_SL28CPLD=y
++CONFIG_RZ_MTU3=y
++CONFIG_MFD_TI_AM335X_TSCADC=m
++CONFIG_MFD_TI_LP873X=m
++CONFIG_MFD_TPS65219=y
++CONFIG_MFD_TPS6594_I2C=m
++CONFIG_MFD_ROHM_BD718XX=y
++CONFIG_MFD_WCD934X=m
++CONFIG_MFD_KHADAS_MCU=m
++CONFIG_REGULATOR_FIXED_VOLTAGE=y
++CONFIG_REGULATOR_AXP20X=y
++CONFIG_REGULATOR_BD718XX=y
++CONFIG_REGULATOR_BD9571MWV=y
++CONFIG_REGULATOR_CROS_EC=y
++CONFIG_REGULATOR_DA9062=y
++CONFIG_REGULATOR_DA9211=m
++CONFIG_REGULATOR_FAN53555=y
++CONFIG_REGULATOR_GPIO=y
++CONFIG_REGULATOR_HI6421V530=y
++CONFIG_REGULATOR_HI655X=y
++CONFIG_REGULATOR_LP873X=m
++CONFIG_REGULATOR_MAX77620=y
++CONFIG_REGULATOR_MAX8973=y
++CONFIG_REGULATOR_MAX20411=m
++CONFIG_REGULATOR_MP8859=y
++CONFIG_REGULATOR_MT6315=m
++CONFIG_REGULATOR_MT6357=y
++CONFIG_REGULATOR_MT6358=y
++CONFIG_REGULATOR_MT6359=y
++CONFIG_REGULATOR_MT6360=y
++CONFIG_REGULATOR_MT6397=y
++CONFIG_REGULATOR_PCA9450=y
++CONFIG_REGULATOR_PF8X00=y
++CONFIG_REGULATOR_PFUZE100=y
++CONFIG_REGULATOR_PWM=y
++CONFIG_REGULATOR_QCOM_REFGEN=m
++CONFIG_REGULATOR_QCOM_RPMH=y
++CONFIG_REGULATOR_QCOM_SMD_RPM=y
++CONFIG_REGULATOR_QCOM_SPMI=y
++CONFIG_REGULATOR_QCOM_USB_VBUS=m
++CONFIG_REGULATOR_RAA215300=y
++CONFIG_REGULATOR_RK808=y
++CONFIG_REGULATOR_S2MPS11=y
++CONFIG_REGULATOR_TPS65132=m
++CONFIG_REGULATOR_TPS65219=y
++CONFIG_REGULATOR_VCTRL=m
++CONFIG_RC_CORE=m
++CONFIG_RC_DECODERS=y
++CONFIG_RC_DEVICES=y
++CONFIG_IR_GPIO_CIR=m
++CONFIG_IR_MESON=m
++CONFIG_IR_SUNXI=m
++CONFIG_MEDIA_CEC_SUPPORT=y
++CONFIG_CEC_MESON_G12A_AO=m
++CONFIG_MEDIA_SUPPORT=m
++CONFIG_MEDIA_CAMERA_SUPPORT=y
++CONFIG_MEDIA_ANALOG_TV_SUPPORT=y
++CONFIG_MEDIA_DIGITAL_TV_SUPPORT=y
++CONFIG_MEDIA_SDR_SUPPORT=y
++CONFIG_MEDIA_PLATFORM_SUPPORT=y
++CONFIG_MEDIA_USB_SUPPORT=y
++CONFIG_USB_VIDEO_CLASS=m
++CONFIG_V4L_PLATFORM_DRIVERS=y
++CONFIG_SDR_PLATFORM_DRIVERS=y
++CONFIG_V4L_MEM2MEM_DRIVERS=y
++CONFIG_VIDEO_AMPHION_VPU=m
++CONFIG_VIDEO_CADENCE_CSI2RX=m
++CONFIG_VIDEO_MEDIATEK_JPEG=m
++CONFIG_VIDEO_MEDIATEK_VCODEC=m
++CONFIG_VIDEO_WAVE_VPU=m
++CONFIG_VIDEO_E5010_JPEG_ENC=m
++CONFIG_VIDEO_IMX7_CSI=m
++CONFIG_VIDEO_IMX_MIPI_CSIS=m
++CONFIG_VIDEO_IMX8_ISI=m
++CONFIG_VIDEO_IMX8_ISI_M2M=y
++CONFIG_VIDEO_IMX8_JPEG=m
++CONFIG_VIDEO_QCOM_CAMSS=m
++CONFIG_VIDEO_QCOM_VENUS=m
++CONFIG_VIDEO_RCAR_ISP=m
++CONFIG_VIDEO_RCAR_CSI2=m
++CONFIG_VIDEO_RCAR_VIN=m
++CONFIG_VIDEO_RZG2L_CSI2=m
++CONFIG_VIDEO_RZG2L_CRU=m
++CONFIG_VIDEO_RENESAS_FCP=m
++CONFIG_VIDEO_RENESAS_FDP1=m
++CONFIG_VIDEO_RENESAS_VSP1=m
++CONFIG_VIDEO_RCAR_DRIF=m
++CONFIG_VIDEO_SAMSUNG_EXYNOS_GSC=m
++CONFIG_VIDEO_SAMSUNG_S5P_JPEG=m
++CONFIG_VIDEO_SAMSUNG_S5P_MFC=m
++CONFIG_VIDEO_SUN6I_CSI=m
++CONFIG_VIDEO_TI_J721E_CSI2RX=m
++CONFIG_VIDEO_HANTRO=m
++CONFIG_VIDEO_IMX219=m
++CONFIG_VIDEO_IMX412=m
++CONFIG_VIDEO_OV5640=m
++CONFIG_VIDEO_OV5645=m
++CONFIG_DRM=m
++CONFIG_DRM_I2C_NXP_TDA998X=m
++CONFIG_DRM_HDLCD=m
++CONFIG_DRM_MALI_DISPLAY=m
++CONFIG_DRM_KOMEDA=m
++CONFIG_DRM_NOUVEAU=m
++CONFIG_DRM_EXYNOS=m
++CONFIG_DRM_EXYNOS5433_DECON=y
++CONFIG_DRM_EXYNOS7_DECON=y
++CONFIG_DRM_EXYNOS_DSI=y
++CONFIG_DRM_EXYNOS_HDMI=y
++CONFIG_DRM_EXYNOS_MIC=y
++CONFIG_DRM_ROCKCHIP=m
++CONFIG_ROCKCHIP_VOP2=y
++CONFIG_ROCKCHIP_ANALOGIX_DP=y
++CONFIG_ROCKCHIP_CDN_DP=y
++CONFIG_ROCKCHIP_DW_HDMI=y
++CONFIG_ROCKCHIP_DW_MIPI_DSI=y
++CONFIG_ROCKCHIP_INNO_HDMI=y
++CONFIG_ROCKCHIP_LVDS=y
++CONFIG_DRM_RCAR_DU=m
++CONFIG_DRM_RCAR_DW_HDMI=m
++CONFIG_DRM_RCAR_MIPI_DSI=m
++CONFIG_DRM_RZG2L_MIPI_DSI=m
++CONFIG_DRM_RZG2L_DU=m
++CONFIG_DRM_SUN4I=m
++CONFIG_DRM_SUN6I_DSI=m
++CONFIG_DRM_SUN8I_DW_HDMI=m
++CONFIG_DRM_SUN8I_MIXER=m
++CONFIG_DRM_MSM=m
++CONFIG_DRM_TEGRA=m
++CONFIG_DRM_PANEL_BOE_TV101WUM_NL6=m
++CONFIG_DRM_PANEL_LVDS=m
++CONFIG_DRM_PANEL_SIMPLE=m
++CONFIG_DRM_PANEL_EDP=m
++CONFIG_DRM_PANEL_ILITEK_ILI9882T=m
++CONFIG_DRM_PANEL_KHADAS_TS050=m
++CONFIG_DRM_PANEL_MANTIX_MLAF057WE51=m
++CONFIG_DRM_PANEL_NOVATEK_NT36672E=m
++CONFIG_DRM_PANEL_RAYDIUM_RM67191=m
++CONFIG_DRM_PANEL_SAMSUNG_ATNA33XC20=m
++CONFIG_DRM_PANEL_SITRONIX_ST7703=m
++CONFIG_DRM_PANEL_TRULY_NT35597_WQXGA=m
++CONFIG_DRM_PANEL_VISIONOX_VTDR6130=m
++CONFIG_DRM_FSL_LDB=m
++CONFIG_DRM_LONTIUM_LT8912B=m
++CONFIG_DRM_LONTIUM_LT9611=m
++CONFIG_DRM_LONTIUM_LT9611UXC=m
++CONFIG_DRM_ITE_IT66121=m
++CONFIG_DRM_NWL_MIPI_DSI=m
++CONFIG_DRM_PARADE_PS8640=m
++CONFIG_DRM_SAMSUNG_DSIM=m
++CONFIG_DRM_SII902X=m
++CONFIG_DRM_SIMPLE_BRIDGE=m
++CONFIG_DRM_THINE_THC63LVD1024=m
++CONFIG_DRM_TOSHIBA_TC358767=m
++CONFIG_DRM_TOSHIBA_TC358768=m
++CONFIG_DRM_TI_TFP410=m
++CONFIG_DRM_TI_SN65DSI83=m
++CONFIG_DRM_TI_SN65DSI86=m
++CONFIG_DRM_ANALOGIX_ANX7625=m
++CONFIG_DRM_I2C_ADV7511=m
++CONFIG_DRM_I2C_ADV7511_AUDIO=y
++CONFIG_DRM_CDNS_MHDP8546=m
++CONFIG_DRM_IMX8MP_DW_HDMI_BRIDGE=m
++CONFIG_DRM_DW_HDMI_AHB_AUDIO=m
++CONFIG_DRM_DW_HDMI_CEC=m
++CONFIG_DRM_IMX_DCSS=m
++CONFIG_DRM_V3D=m
++CONFIG_DRM_VC4=m
++CONFIG_DRM_ETNAVIV=m
++CONFIG_DRM_HISI_HIBMC=m
++CONFIG_DRM_HISI_KIRIN=m
++CONFIG_DRM_MEDIATEK=m
++CONFIG_DRM_MEDIATEK_DP=m
++CONFIG_DRM_MEDIATEK_HDMI=m
++CONFIG_DRM_MXSFB=m
++CONFIG_DRM_IMX_LCDIF=m
++CONFIG_DRM_MESON=m
++CONFIG_DRM_PL111=m
++CONFIG_DRM_LIMA=m
++CONFIG_DRM_PANFROST=m
++CONFIG_DRM_PANTHOR=m
++CONFIG_DRM_TIDSS=m
++CONFIG_DRM_POWERVR=m
++CONFIG_FB=y
++CONFIG_FB_EFI=y
++CONFIG_FB_MODE_HELPERS=y
++CONFIG_BACKLIGHT_PWM=m
++CONFIG_BACKLIGHT_LP855X=m
++CONFIG_LOGO=y
++CONFIG_SOUND=y
++CONFIG_SND=y
++CONFIG_SND_ALOOP=m
++CONFIG_SND_HDA_TEGRA=m
++CONFIG_SND_HDA_CODEC_HDMI=m
++CONFIG_SND_SOC=y
++CONFIG_SND_BCM2835_SOC_I2S=m
++CONFIG_SND_SOC_FSL_ASRC=m
++CONFIG_SND_SOC_FSL_MICFIL=m
++CONFIG_SND_SOC_FSL_EASRC=m
++CONFIG_SND_IMX_SOC=m
++CONFIG_SND_SOC_IMX_SGTL5000=m
++CONFIG_SND_SOC_FSL_ASOC_CARD=m
++CONFIG_SND_SOC_IMX_AUDMIX=m
++CONFIG_SND_SOC_MT8183=m
++CONFIG_SND_SOC_MT8183_MT6358_TS3A227E_MAX98357A=m
++CONFIG_SND_SOC_MT8183_DA7219_MAX98357A=m
++CONFIG_SND_SOC_MT8192=m
++CONFIG_SND_SOC_MT8192_MT6359_RT1015_RT5682=m
++CONFIG_SND_SOC_MT8195=m
++CONFIG_SND_SOC_MT8195_MT6359=m
++CONFIG_SND_SOC_MT8365=m
++CONFIG_SND_SOC_MT8365_MT6357=m
++CONFIG_SND_MESON_AXG_SOUND_CARD=m
++CONFIG_SND_MESON_GX_SOUND_CARD=m
++CONFIG_SND_SOC_QCOM=m
++CONFIG_SND_SOC_APQ8016_SBC=m
++CONFIG_SND_SOC_MSM8996=m
++CONFIG_SND_SOC_SDM845=m
++CONFIG_SND_SOC_SM8250=m
++CONFIG_SND_SOC_SC8280XP=m
++CONFIG_SND_SOC_SC7180=m
++CONFIG_SND_SOC_SC7280=m
++CONFIG_SND_SOC_X1E80100=m
++CONFIG_SND_SOC_ROCKCHIP=m
++CONFIG_SND_SOC_ROCKCHIP_I2S_TDM=m
++CONFIG_SND_SOC_ROCKCHIP_SPDIF=m
++CONFIG_SND_SOC_ROCKCHIP_RT5645=m
++CONFIG_SND_SOC_RK3399_GRU_SOUND=m
++CONFIG_SND_SOC_SAMSUNG=y
++CONFIG_SND_SOC_RCAR=m
++CONFIG_SND_SOC_RZ=m
++CONFIG_SND_SOC_SOF_TOPLEVEL=y
++CONFIG_SND_SOC_SOF_OF=y
++CONFIG_SND_SOC_SOF_MTK_TOPLEVEL=y
++CONFIG_SND_SOC_SOF_MT8195=m
++CONFIG_SND_SUN8I_CODEC=m
++CONFIG_SND_SUN8I_CODEC_ANALOG=m
++CONFIG_SND_SUN50I_CODEC_ANALOG=m
++CONFIG_SND_SUN4I_I2S=m
++CONFIG_SND_SUN4I_SPDIF=m
++CONFIG_SND_SOC_TEGRA=m
++CONFIG_SND_SOC_TEGRA210_AHUB=m
++CONFIG_SND_SOC_TEGRA210_DMIC=m
++CONFIG_SND_SOC_TEGRA210_I2S=m
++CONFIG_SND_SOC_TEGRA210_OPE=m
++CONFIG_SND_SOC_TEGRA186_ASRC=m
++CONFIG_SND_SOC_TEGRA186_DSPK=m
++CONFIG_SND_SOC_TEGRA210_ADMAIF=m
++CONFIG_SND_SOC_TEGRA210_MVC=m
++CONFIG_SND_SOC_TEGRA210_SFC=m
++CONFIG_SND_SOC_TEGRA210_AMX=m
++CONFIG_SND_SOC_TEGRA210_ADX=m
++CONFIG_SND_SOC_TEGRA210_MIXER=m
++CONFIG_SND_SOC_TEGRA_AUDIO_GRAPH_CARD=m
++CONFIG_SND_SOC_DAVINCI_MCASP=m
++CONFIG_SND_SOC_J721E_EVM=m
++CONFIG_SND_SOC_AK4613=m
++CONFIG_SND_SOC_AK4619=m
++CONFIG_SND_SOC_DA7213=m
++CONFIG_SND_SOC_ES7134=m
++CONFIG_SND_SOC_ES7241=m
++CONFIG_SND_SOC_ES8316=m
++CONFIG_SND_SOC_GTM601=m
++CONFIG_SND_SOC_MSM8916_WCD_ANALOG=m
++CONFIG_SND_SOC_MSM8916_WCD_DIGITAL=m
++CONFIG_SND_SOC_PCM3168A_I2C=m
++CONFIG_SND_SOC_RK3308=m
++CONFIG_SND_SOC_RK817=m
++CONFIG_SND_SOC_RT5640=m
++CONFIG_SND_SOC_RT5659=m
++CONFIG_SND_SOC_SIMPLE_AMPLIFIER=m
++CONFIG_SND_SOC_SIMPLE_MUX=m
++CONFIG_SND_SOC_TAS2552=m
++CONFIG_SND_SOC_TAS571X=m
++CONFIG_SND_SOC_TLV320AIC32X4_I2C=m
++CONFIG_SND_SOC_TLV320AIC3X_I2C=m
++CONFIG_SND_SOC_WCD9335=m
++CONFIG_SND_SOC_WCD934X=m
++CONFIG_SND_SOC_WCD939X=m
++CONFIG_SND_SOC_WCD939X_SDW=m
++CONFIG_SND_SOC_WM8524=m
++CONFIG_SND_SOC_WM8904=m
++CONFIG_SND_SOC_WM8960=m
++CONFIG_SND_SOC_WM8962=m
++CONFIG_SND_SOC_WM8978=m
++CONFIG_SND_SOC_WSA881X=m
++CONFIG_SND_SOC_WSA883X=m
++CONFIG_SND_SOC_WSA884X=m
++CONFIG_SND_SOC_NAU8822=m
++CONFIG_SND_SOC_LPASS_WSA_MACRO=m
++CONFIG_SND_SOC_LPASS_VA_MACRO=m
++CONFIG_SND_SOC_LPASS_RX_MACRO=m
++CONFIG_SND_SOC_LPASS_TX_MACRO=m
++CONFIG_SND_SIMPLE_CARD=m
++CONFIG_SND_AUDIO_GRAPH_CARD=m
++CONFIG_SND_AUDIO_GRAPH_CARD2=m
++CONFIG_HID_MULTITOUCH=m
++CONFIG_I2C_HID_ACPI=m
++CONFIG_I2C_HID_OF=m
++CONFIG_I2C_HID_OF_ELAN=m
++CONFIG_USB=y
++CONFIG_USB_OTG=y
++CONFIG_USB_XHCI_HCD=y
++CONFIG_USB_XHCI_PCI_RENESAS=m
++CONFIG_USB_XHCI_RZV2M=y
++CONFIG_USB_XHCI_TEGRA=y
++CONFIG_USB_BRCMSTB=m
++CONFIG_USB_EHCI_HCD=y
++CONFIG_USB_EHCI_EXYNOS=y
++CONFIG_USB_EHCI_HCD_PLATFORM=y
++CONFIG_USB_OHCI_HCD=y
++CONFIG_USB_OHCI_EXYNOS=y
++CONFIG_USB_OHCI_HCD_PLATFORM=y
++CONFIG_USB_RENESAS_USBHS_HCD=m
++CONFIG_USB_RENESAS_USBHS=m
++CONFIG_USB_ACM=m
++CONFIG_USB_STORAGE=y
++CONFIG_USB_CDNS_SUPPORT=m
++CONFIG_USB_CDNS3=m
++CONFIG_USB_CDNS3_GADGET=y
++CONFIG_USB_CDNS3_HOST=y
++CONFIG_USB_CDNS3_IMX=m
++CONFIG_USB_MTU3=y
++CONFIG_USB_MUSB_HDRC=y
++CONFIG_USB_MUSB_SUNXI=y
++CONFIG_USB_DWC3=y
++CONFIG_OMAP_USB2=m
++CONFIG_USB_DWC2=y
++CONFIG_USB_CHIPIDEA=y
++CONFIG_USB_CHIPIDEA_UDC=y
++CONFIG_USB_CHIPIDEA_HOST=y
++CONFIG_USB_ISP1760=y
++CONFIG_USB_SERIAL=m
++CONFIG_USB_SERIAL_CP210X=m
++CONFIG_USB_SERIAL_FTDI_SIO=m
++CONFIG_USB_SERIAL_OPTION=m
++CONFIG_USB_QCOM_EUD=m
++CONFIG_USB_HSIC_USB3503=y
++CONFIG_USB_ONBOARD_DEV=m
++CONFIG_NOP_USB_XCEIV=y
++CONFIG_USB_MXS_PHY=m
++CONFIG_USB_GADGET=y
++CONFIG_USB_RENESAS_USBHS_UDC=m
++CONFIG_USB_RZV2M_USB3DRD=y
++CONFIG_USB_RENESAS_USB3=m
++CONFIG_USB_TEGRA_XUDC=m
++CONFIG_USB_CONFIGFS=m
++CONFIG_USB_CONFIGFS_SERIAL=y
++CONFIG_USB_CONFIGFS_ACM=y
++CONFIG_USB_CONFIGFS_OBEX=y
++CONFIG_USB_CONFIGFS_NCM=y
++CONFIG_USB_CONFIGFS_ECM=y
++CONFIG_USB_CONFIGFS_ECM_SUBSET=y
++CONFIG_USB_CONFIGFS_RNDIS=y
++CONFIG_USB_CONFIGFS_EEM=y
++CONFIG_USB_CONFIGFS_MASS_STORAGE=y
++CONFIG_USB_MASS_STORAGE=m
++CONFIG_USB_G_SERIAL=m
++CONFIG_TYPEC=y
++CONFIG_TYPEC_TCPM=y
++CONFIG_TYPEC_TCPCI=m
++CONFIG_TYPEC_FUSB302=y
++CONFIG_TYPEC_QCOM_PMIC=m
++CONFIG_TYPEC_UCSI=m
++CONFIG_UCSI_CCG=m
++CONFIG_UCSI_PMIC_GLINK=m
++CONFIG_TYPEC_TPS6598X=m
++CONFIG_TYPEC_HD3SS3220=m
++CONFIG_TYPEC_MUX_FSA4480=m
++CONFIG_TYPEC_MUX_GPIO_SBU=m
++CONFIG_TYPEC_MUX_NB7VPQ904M=m
++CONFIG_TYPEC_MUX_WCD939X_USBSS=m
++CONFIG_TYPEC_DP_ALTMODE=m
++CONFIG_MMC=y
++CONFIG_MMC_BLOCK_MINORS=32
++CONFIG_MMC_ARMMMCI=y
++CONFIG_MMC_SDHCI=y
++CONFIG_MMC_SDHCI_ACPI=y
++CONFIG_MMC_SDHCI_PLTFM=y
++CONFIG_MMC_SDHCI_OF_ARASAN=y
++CONFIG_MMC_SDHCI_OF_ESDHC=y
++CONFIG_MMC_SDHCI_OF_DWCMSHC=y
++CONFIG_MMC_SDHCI_OF_SPARX5=y
++CONFIG_MMC_SDHCI_CADENCE=y
++CONFIG_MMC_SDHCI_ESDHC_IMX=y
++CONFIG_MMC_SDHCI_TEGRA=y
++CONFIG_MMC_SDHCI_F_SDH30=y
++CONFIG_MMC_MESON_GX=y
++CONFIG_MMC_SDHCI_MSM=y
++CONFIG_MMC_SPI=y
++CONFIG_MMC_SDHI=y
++CONFIG_MMC_UNIPHIER=y
++CONFIG_MMC_DW=y
++CONFIG_MMC_DW_EXYNOS=y
++CONFIG_MMC_DW_HI3798CV200=y
++CONFIG_MMC_DW_K3=y
++CONFIG_MMC_DW_ROCKCHIP=y
++CONFIG_MMC_SUNXI=y
++CONFIG_MMC_BCM2835=y
++CONFIG_MMC_MTK=y
++CONFIG_MMC_SDHCI_XENON=y
++CONFIG_MMC_SDHCI_AM654=y
++CONFIG_MMC_OWL=y
++CONFIG_SCSI_UFSHCD=y
++CONFIG_SCSI_UFS_BSG=y
++CONFIG_SCSI_UFSHCD_PLATFORM=y
++CONFIG_SCSI_UFS_CDNS_PLATFORM=m
++CONFIG_SCSI_UFS_QCOM=m
++CONFIG_SCSI_UFS_HISI=y
++CONFIG_SCSI_UFS_RENESAS=m
++CONFIG_SCSI_UFS_TI_J721E=m
++CONFIG_SCSI_UFS_EXYNOS=y
++CONFIG_NEW_LEDS=y
++CONFIG_LEDS_CLASS=y
++CONFIG_LEDS_CLASS_MULTICOLOR=m
++CONFIG_LEDS_LM3692X=m
++CONFIG_LEDS_PCA9532=m
++CONFIG_LEDS_GPIO=y
++CONFIG_LEDS_PWM=y
++CONFIG_LEDS_SYSCON=y
++CONFIG_LEDS_QCOM_LPG=m
++CONFIG_LEDS_TRIGGER_TIMER=y
++CONFIG_LEDS_TRIGGER_DISK=y
++CONFIG_LEDS_TRIGGER_HEARTBEAT=y
++CONFIG_LEDS_TRIGGER_CPU=y
++CONFIG_LEDS_TRIGGER_DEFAULT_ON=y
++CONFIG_LEDS_TRIGGER_PANIC=y
++CONFIG_EDAC=y
++CONFIG_EDAC_GHES=y
++CONFIG_EDAC_LAYERSCAPE=m
++CONFIG_RTC_CLASS=y
++CONFIG_RTC_DRV_DS1307=m
++CONFIG_RTC_DRV_HYM8563=m
++CONFIG_RTC_DRV_MAX77686=y
++CONFIG_RTC_DRV_RK808=m
++CONFIG_RTC_DRV_ISL1208=m
++CONFIG_RTC_DRV_PCF85063=m
++CONFIG_RTC_DRV_PCF85363=m
++CONFIG_RTC_DRV_PCF8563=m
++CONFIG_RTC_DRV_M41T80=m
++CONFIG_RTC_DRV_BQ32K=m
++CONFIG_RTC_DRV_RX8581=m
++CONFIG_RTC_DRV_RV3028=m
++CONFIG_RTC_DRV_RV8803=m
++CONFIG_RTC_DRV_S5M=y
++CONFIG_RTC_DRV_DS3232=y
++CONFIG_RTC_DRV_PCF2127=m
++CONFIG_RTC_DRV_EFI=y
++CONFIG_RTC_DRV_CROS_EC=y
++CONFIG_RTC_DRV_FSL_FTM_ALARM=m
++CONFIG_RTC_DRV_S3C=y
++CONFIG_RTC_DRV_PL031=y
++CONFIG_RTC_DRV_SUN6I=y
++CONFIG_RTC_DRV_ARMADA38X=y
++CONFIG_RTC_DRV_PM8XXX=m
++CONFIG_RTC_DRV_TEGRA=y
++CONFIG_RTC_DRV_SNVS=m
++CONFIG_RTC_DRV_BBNSM=m
++CONFIG_RTC_DRV_IMX_SC=m
++CONFIG_RTC_DRV_MT6397=m
++CONFIG_RTC_DRV_XGENE=y
++CONFIG_RTC_DRV_TI_K3=m
++CONFIG_DMADEVICES=y
++CONFIG_DMA_BCM2835=y
++CONFIG_DMA_SUN6I=m
++CONFIG_FSL_EDMA=y
++CONFIG_IMX_SDMA=m
++CONFIG_K3_DMA=y
++CONFIG_MV_XOR=y
++CONFIG_MV_XOR_V2=y
++CONFIG_OWL_DMA=y
++CONFIG_PL330_DMA=y
++CONFIG_TEGRA186_GPC_DMA=y
++CONFIG_TEGRA20_APB_DMA=y
++CONFIG_TEGRA210_ADMA=m
++CONFIG_QCOM_BAM_DMA=y
++CONFIG_QCOM_GPI_DMA=m
++CONFIG_QCOM_HIDMA_MGMT=y
++CONFIG_QCOM_HIDMA=y
++CONFIG_DW_EDMA=m
++CONFIG_RCAR_DMAC=y
++CONFIG_RENESAS_USB_DMAC=m
++CONFIG_RZ_DMAC=y
++CONFIG_TI_K3_UDMA=y
++CONFIG_TI_K3_UDMA_GLUE_LAYER=y
++CONFIG_UIO=m
++CONFIG_UIO_PDRV_GENIRQ=m
++CONFIG_VFIO=m
++CONFIG_VFIO_PCI=m
++CONFIG_VIRTIO_PCI=y
++CONFIG_VIRTIO_BALLOON=y
++CONFIG_VIRTIO_MMIO=y
++CONFIG_XEN_GNTDEV=y
++CONFIG_XEN_GRANT_DEV_ALLOC=y
++CONFIG_STAGING=y
++CONFIG_STAGING_MEDIA=y
++CONFIG_VIDEO_MAX96712=m
++CONFIG_VIDEO_MESON_VDEC=m
++CONFIG_SND_BCM2835=m
++CONFIG_CHROME_PLATFORMS=y
++CONFIG_CROS_EC=y
++CONFIG_CROS_EC_I2C=y
++CONFIG_CROS_EC_RPMSG=m
++CONFIG_CROS_EC_SPI=y
++CONFIG_CROS_KBD_LED_BACKLIGHT=m
++CONFIG_CROS_EC_CHARDEV=m
++CONFIG_COMMON_CLK_RK808=y
++CONFIG_COMMON_CLK_SCMI=y
++CONFIG_COMMON_CLK_SCPI=y
++CONFIG_COMMON_CLK_CS2000_CP=y
++CONFIG_COMMON_CLK_FSL_SAI=y
++CONFIG_COMMON_CLK_S2MPS11=y
++CONFIG_COMMON_CLK_PWM=y
++CONFIG_COMMON_CLK_RS9_PCIE=y
++CONFIG_COMMON_CLK_VC3=y
++CONFIG_COMMON_CLK_VC5=y
++CONFIG_COMMON_CLK_BD718XX=m
++CONFIG_CLK_RASPBERRYPI=m
++CONFIG_CLK_IMX8MM=y
++CONFIG_CLK_IMX8MN=y
++CONFIG_CLK_IMX8MP=y
++CONFIG_CLK_IMX8MQ=y
++CONFIG_CLK_IMX8QXP=y
++CONFIG_CLK_IMX8ULP=y
++CONFIG_CLK_IMX93=y
++CONFIG_TI_SCI_CLK=y
++CONFIG_COMMON_CLK_MT8192_AUDSYS=y
++CONFIG_COMMON_CLK_MT8192_CAMSYS=y
++CONFIG_COMMON_CLK_MT8192_IMGSYS=y
++CONFIG_COMMON_CLK_MT8192_IMP_IIC_WRAP=y
++CONFIG_COMMON_CLK_MT8192_IPESYS=y
++CONFIG_COMMON_CLK_MT8192_MDPSYS=y
++CONFIG_COMMON_CLK_MT8192_MFGCFG=y
++CONFIG_COMMON_CLK_MT8192_MMSYS=y
++CONFIG_COMMON_CLK_MT8192_MSDC=y
++CONFIG_COMMON_CLK_MT8192_SCP_ADSP=y
++CONFIG_COMMON_CLK_MT8192_VDECSYS=y
++CONFIG_COMMON_CLK_MT8192_VENCSYS=y
++CONFIG_COMMON_CLK_QCOM=y
++CONFIG_CLK_X1E80100_CAMCC=m
++CONFIG_CLK_X1E80100_DISPCC=m
++CONFIG_CLK_X1E80100_GCC=y
++CONFIG_CLK_X1E80100_GPUCC=m
++CONFIG_CLK_X1E80100_TCSRCC=y
++CONFIG_QCOM_A53PLL=y
++CONFIG_QCOM_CLK_APCS_MSM8916=y
++CONFIG_QCOM_CLK_APCC_MSM8996=y
++CONFIG_QCOM_CLK_SMD_RPM=y
++CONFIG_QCOM_CLK_RPMH=y
++CONFIG_IPQ_APSS_6018=y
++CONFIG_IPQ_APSS_5018=y
++CONFIG_IPQ_GCC_5018=y
++CONFIG_IPQ_GCC_5332=y
++CONFIG_IPQ_GCC_6018=y
++CONFIG_IPQ_GCC_8074=y
++CONFIG_IPQ_GCC_9574=y
++CONFIG_MSM_GCC_8916=y
++CONFIG_MSM_MMCC_8994=m
++CONFIG_MSM_GCC_8994=y
++CONFIG_MSM_GCC_8996=y
++CONFIG_MSM_MMCC_8996=m
++CONFIG_MSM_GCC_8998=y
++CONFIG_MSM_MMCC_8998=m
++CONFIG_QCM_GCC_2290=y
++CONFIG_QCM_DISPCC_2290=m
++CONFIG_QCS_GCC_404=y
++CONFIG_QDU_GCC_1000=y
++CONFIG_SC_CAMCC_8280XP=m
++CONFIG_SC_DISPCC_7280=m
++CONFIG_SC_DISPCC_8280XP=m
++CONFIG_SA_GCC_8775P=y
++CONFIG_SA_GPUCC_8775P=m
++CONFIG_SC_GCC_7180=y
++CONFIG_SC_GCC_7280=y
++CONFIG_SC_GCC_8180X=y
++CONFIG_SC_GCC_8280XP=y
++CONFIG_SC_GPUCC_7280=m
++CONFIG_SC_GPUCC_8280XP=m
++CONFIG_SC_LPASSCC_8280XP=m
++CONFIG_SDM_CAMCC_845=m
++CONFIG_SDM_GPUCC_845=y
++CONFIG_SDM_VIDEOCC_845=y
++CONFIG_SDM_DISPCC_845=y
++CONFIG_SDM_LPASSCC_845=m
++CONFIG_SDX_GCC_75=y
++CONFIG_SM_CAMCC_8250=m
++CONFIG_SM_DISPCC_6115=m
++CONFIG_SM_DISPCC_8250=y
++CONFIG_SM_DISPCC_8450=m
++CONFIG_SM_DISPCC_8550=m
++CONFIG_SM_DISPCC_8650=m
++CONFIG_SM_GCC_4450=y
++CONFIG_SM_GCC_6115=y
++CONFIG_SM_GCC_8350=y
++CONFIG_SM_GCC_8450=y
++CONFIG_SM_GCC_8550=y
++CONFIG_SM_GCC_8650=y
++CONFIG_SM_GPUCC_6115=m
++CONFIG_SM_GPUCC_8150=y
++CONFIG_SM_GPUCC_8250=y
++CONFIG_SM_GPUCC_8350=m
++CONFIG_SM_GPUCC_8450=m
++CONFIG_SM_GPUCC_8550=m
++CONFIG_SM_GPUCC_8650=m
++CONFIG_SM_TCSRCC_8550=y
++CONFIG_SM_TCSRCC_8650=y
++CONFIG_SM_VIDEOCC_8250=y
++CONFIG_QCOM_HFPLL=y
++CONFIG_CLK_GFM_LPASS_SM8250=m
++CONFIG_CLK_RCAR_USB2_CLOCK_SEL=y
++CONFIG_HWSPINLOCK=y
++CONFIG_HWSPINLOCK_QCOM=y
++CONFIG_TEGRA186_TIMER=y
++CONFIG_RENESAS_OSTM=y
++CONFIG_ARM_MHU=y
++CONFIG_IMX_MBOX=y
++CONFIG_OMAP2PLUS_MBOX=m
++CONFIG_PLATFORM_MHU=y
++CONFIG_BCM2835_MBOX=y
++CONFIG_QCOM_APCS_IPC=y
++CONFIG_MTK_ADSP_MBOX=m
++CONFIG_QCOM_IPCC=y
++CONFIG_ROCKCHIP_IOMMU=y
++CONFIG_TEGRA_IOMMU_SMMU=y
++CONFIG_ARM_SMMU=y
++CONFIG_ARM_SMMU_V3=y
++CONFIG_MTK_IOMMU=y
++CONFIG_QCOM_IOMMU=y
++CONFIG_REMOTEPROC=y
++CONFIG_IMX_REMOTEPROC=y
++CONFIG_MTK_SCP=m
++CONFIG_QCOM_Q6V5_ADSP=m
++CONFIG_QCOM_Q6V5_MSS=m
++CONFIG_QCOM_Q6V5_PAS=m
++CONFIG_QCOM_SYSMON=m
++CONFIG_QCOM_WCNSS_PIL=m
++CONFIG_TI_K3_DSP_REMOTEPROC=m
++CONFIG_TI_K3_R5_REMOTEPROC=m
++CONFIG_RPMSG_CHAR=m
++CONFIG_RPMSG_CTRL=m
++CONFIG_RPMSG_QCOM_GLINK_RPM=y
++CONFIG_RPMSG_QCOM_GLINK_SMEM=m
++CONFIG_RPMSG_QCOM_SMD=y
++CONFIG_RPMSG_VIRTIO=y
++CONFIG_SOUNDWIRE=m
++CONFIG_SOUNDWIRE_QCOM=m
++CONFIG_FSL_DPAA=y
++CONFIG_FSL_MC_DPIO=y
++CONFIG_FSL_RCPM=y
++CONFIG_MTK_CMDQ=m
++CONFIG_MTK_DEVAPC=m
++CONFIG_MTK_PMIC_WRAP=y
++CONFIG_MTK_SVS=m
++CONFIG_QCOM_AOSS_QMP=y
++CONFIG_QCOM_COMMAND_DB=y
++CONFIG_QCOM_GENI_SE=y
++CONFIG_QCOM_LLCC=m
++CONFIG_QCOM_OCMEM=m
++CONFIG_QCOM_PMIC_GLINK=m
++CONFIG_QCOM_RMTFS_MEM=m
++CONFIG_QCOM_RPMH=y
++CONFIG_QCOM_SMEM=y
++CONFIG_QCOM_SMD_RPM=y
++CONFIG_QCOM_SMP2P=y
++CONFIG_QCOM_SMSM=y
++CONFIG_QCOM_SOCINFO=m
++CONFIG_QCOM_SPM=m
++CONFIG_QCOM_STATS=m
++CONFIG_QCOM_WCNSS_CTRL=m
++CONFIG_QCOM_APR=m
++CONFIG_QCOM_ICC_BWMON=m
++CONFIG_QCOM_PBS=m
++CONFIG_ARCH_R8A77995=y
++CONFIG_ARCH_R8A77990=y
++CONFIG_ARCH_R8A77951=y
++CONFIG_ARCH_R8A77965=y
++CONFIG_ARCH_R8A77960=y
++CONFIG_ARCH_R8A77961=y
++CONFIG_ARCH_R8A779F0=y
++CONFIG_ARCH_R8A77980=y
++CONFIG_ARCH_R8A77970=y
++CONFIG_ARCH_R8A779A0=y
++CONFIG_ARCH_R8A779G0=y
++CONFIG_ARCH_R8A779H0=y
++CONFIG_ARCH_R8A774C0=y
++CONFIG_ARCH_R8A774E1=y
++CONFIG_ARCH_R8A774A1=y
++CONFIG_ARCH_R8A774B1=y
++CONFIG_ARCH_R9A07G043=y
++CONFIG_ARCH_R9A07G044=y
++CONFIG_ARCH_R9A07G054=y
++CONFIG_ARCH_R9A08G045=y
++CONFIG_ARCH_R9A09G011=y
++CONFIG_ARCH_R9A09G057=y
++CONFIG_ROCKCHIP_IODOMAIN=y
++CONFIG_ARCH_TEGRA_132_SOC=y
++CONFIG_ARCH_TEGRA_210_SOC=y
++CONFIG_ARCH_TEGRA_186_SOC=y
++CONFIG_ARCH_TEGRA_194_SOC=y
++CONFIG_ARCH_TEGRA_234_SOC=y
++CONFIG_TI_PRUSS=m
++CONFIG_OWL_PM_DOMAINS=y
++CONFIG_RASPBERRYPI_POWER=y
++CONFIG_IMX_SCU_PD=y
++CONFIG_QCOM_CPR=y
++CONFIG_QCOM_RPMHPD=y
++CONFIG_QCOM_RPMPD=y
++CONFIG_ROCKCHIP_PM_DOMAINS=y
++CONFIG_TI_SCI_PM_DOMAINS=y
++CONFIG_ARM_IMX_BUS_DEVFREQ=y
++CONFIG_ARM_IMX8M_DDRC_DEVFREQ=m
++CONFIG_ARM_MEDIATEK_CCI_DEVFREQ=m
++CONFIG_EXTCON_PTN5150=m
++CONFIG_EXTCON_USB_GPIO=y
++CONFIG_EXTCON_USBC_CROS_EC=y
++CONFIG_RENESAS_RPCIF=m
++CONFIG_IIO=y
++CONFIG_EXYNOS_ADC=y
++CONFIG_IMX8QXP_ADC=m
++CONFIG_IMX93_ADC=m
++CONFIG_MAX9611=m
++CONFIG_MEDIATEK_MT6577_AUXADC=m
++CONFIG_QCOM_SPMI_VADC=m
++CONFIG_QCOM_SPMI_ADC5=m
++CONFIG_ROCKCHIP_SARADC=m
++CONFIG_RZG2L_ADC=m
++CONFIG_TI_ADS1015=m
++CONFIG_TI_AM335X_ADC=m
++CONFIG_IIO_CROS_EC_SENSORS_CORE=m
++CONFIG_IIO_CROS_EC_SENSORS=m
++CONFIG_IIO_ST_LSM6DSX=m
++CONFIG_IIO_CROS_EC_LIGHT_PROX=m
++CONFIG_SENSORS_ISL29018=m
++CONFIG_VCNL4000=m
++CONFIG_IIO_ST_MAGN_3AXIS=m
++CONFIG_IIO_CROS_EC_BARO=m
++CONFIG_MPL3115=m
++CONFIG_PWM=y
++CONFIG_PWM_ADP5585=m
++CONFIG_PWM_BCM2835=m
++CONFIG_PWM_BRCMSTB=m
++CONFIG_PWM_CROS_EC=m
++CONFIG_PWM_IMX27=m
++CONFIG_PWM_MESON=m
++CONFIG_PWM_MTK_DISP=m
++CONFIG_PWM_MEDIATEK=m
++CONFIG_PWM_RCAR=m
++CONFIG_PWM_RENESAS_TPU=m
++CONFIG_PWM_ROCKCHIP=y
++CONFIG_PWM_RZ_MTU3=m
++CONFIG_PWM_SAMSUNG=y
++CONFIG_PWM_SL28CPLD=m
++CONFIG_PWM_SUN4I=m
++CONFIG_PWM_TEGRA=m
++CONFIG_PWM_TIECAP=m
++CONFIG_PWM_TIEHRPWM=m
++CONFIG_PWM_VISCONTI=m
++CONFIG_SL28CPLD_INTC=y
++CONFIG_QCOM_PDC=y
++CONFIG_QCOM_MPM=y
++CONFIG_RESET_GPIO=m
++CONFIG_RESET_IMX7=y
++CONFIG_RESET_QCOM_AOSS=y
++CONFIG_RESET_QCOM_PDC=m
++CONFIG_RESET_RZG2L_USBPHY_CTRL=y
++CONFIG_RESET_TI_SCI=y
++CONFIG_PHY_XGENE=y
++CONFIG_PHY_CAN_TRANSCEIVER=m
++CONFIG_PHY_SUN4I_USB=y
++CONFIG_PHY_CADENCE_TORRENT=m
++CONFIG_PHY_CADENCE_DPHY_RX=m
++CONFIG_PHY_CADENCE_SIERRA=m
++CONFIG_PHY_CADENCE_SALVO=m
++CONFIG_PHY_MIXEL_MIPI_DPHY=m
++CONFIG_PHY_FSL_IMX8M_PCIE=y
++CONFIG_PHY_HI6220_USB=y
++CONFIG_PHY_HISTB_COMBPHY=y
++CONFIG_PHY_HISI_INNO_USB2=y
++CONFIG_PHY_MVEBU_CP110_COMPHY=y
++CONFIG_PHY_MTK_TPHY=y
++CONFIG_PHY_QCOM_EDP=m
++CONFIG_PHY_QCOM_PCIE2=m
++CONFIG_PHY_QCOM_QMP=m
++CONFIG_PHY_QCOM_QUSB2=m
++CONFIG_PHY_QCOM_SNPS_EUSB2=m
++CONFIG_PHY_QCOM_EUSB2_REPEATER=m
++CONFIG_PHY_QCOM_M31_USB=m
++CONFIG_PHY_QCOM_USB_HS=m
++CONFIG_PHY_QCOM_USB_SNPS_FEMTO_V2=m
++CONFIG_PHY_QCOM_USB_HS_28NM=m
++CONFIG_PHY_QCOM_USB_SS=m
++CONFIG_PHY_QCOM_SGMII_ETH=m
++CONFIG_PHY_R8A779F0_ETHERNET_SERDES=y
++CONFIG_PHY_RCAR_GEN3_PCIE=y
++CONFIG_PHY_RCAR_GEN3_USB2=y
++CONFIG_PHY_RCAR_GEN3_USB3=m
++CONFIG_PHY_ROCKCHIP_EMMC=y
++CONFIG_PHY_ROCKCHIP_INNO_HDMI=m
++CONFIG_PHY_ROCKCHIP_INNO_USB2=y
++CONFIG_PHY_ROCKCHIP_INNO_DSIDPHY=m
++CONFIG_PHY_ROCKCHIP_NANENG_COMBO_PHY=m
++CONFIG_PHY_ROCKCHIP_PCIE=m
++CONFIG_PHY_ROCKCHIP_SAMSUNG_HDPTX=m
++CONFIG_PHY_ROCKCHIP_SNPS_PCIE3=y
++CONFIG_PHY_ROCKCHIP_TYPEC=y
++CONFIG_PHY_ROCKCHIP_USBDP=m
++CONFIG_PHY_SAMSUNG_UFS=y
++CONFIG_PHY_UNIPHIER_USB2=y
++CONFIG_PHY_UNIPHIER_USB3=y
++CONFIG_PHY_TEGRA_XUSB=y
++CONFIG_PHY_AM654_SERDES=m
++CONFIG_PHY_J721E_WIZ=m
++CONFIG_ARM_CCI_PMU=m
++CONFIG_ARM_CCN=m
++CONFIG_ARM_CMN=m
++CONFIG_ARM_SMMU_V3_PMU=m
++CONFIG_ARM_DSU_PMU=m
++CONFIG_FSL_IMX8_DDR_PMU=m
++CONFIG_QCOM_L2_PMU=y
++CONFIG_QCOM_L3_PMU=y
++CONFIG_ARM_SPE_PMU=m
++CONFIG_ARM_DMC620_PMU=m
++CONFIG_HISI_PMU=y
++CONFIG_ARM_CORESIGHT_PMU_ARCH_SYSTEM_PMU=m
++CONFIG_NVIDIA_CORESIGHT_PMU_ARCH_SYSTEM_PMU=m
++CONFIG_MESON_DDR_PMU=m
++CONFIG_NVMEM_LAYOUT_SL28_VPD=m
++CONFIG_NVMEM_IMX_OCOTP=y
++CONFIG_NVMEM_IMX_OCOTP_ELE=m
++CONFIG_NVMEM_IMX_OCOTP_SCU=y
++CONFIG_NVMEM_LAYERSCAPE_SFP=m
++CONFIG_NVMEM_MESON_EFUSE=m
++CONFIG_NVMEM_MTK_EFUSE=y
++CONFIG_NVMEM_QCOM_QFPROM=y
++CONFIG_NVMEM_QCOM_SEC_QFPROM=m
++CONFIG_NVMEM_RMEM=m
++CONFIG_NVMEM_ROCKCHIP_EFUSE=y
++CONFIG_NVMEM_ROCKCHIP_OTP=y
++CONFIG_NVMEM_SNVS_LPGPR=y
++CONFIG_NVMEM_SPMI_SDAM=m
++CONFIG_NVMEM_SUNXI_SID=y
++CONFIG_NVMEM_UNIPHIER_EFUSE=y
++CONFIG_FPGA=y
++CONFIG_FPGA_MGR_ALTERA_CVP=m
++CONFIG_FPGA_MGR_STRATIX10_SOC=y
++CONFIG_FPGA_BRIDGE=y
++CONFIG_SOCFPGA_FPGA_BRIDGE=y
++#CONFIG_EDAC_DEBUG=y
++#CONFIG_EDAC_ALTERA=y
++#CONFIG_EDAC_ALTERA_IO96B=y
++CONFIG_ALTERA_FREEZE_BRIDGE=m
++CONFIG_OF_RESOLVE=y 
++CONFIG_FPGA_REGION=y
++CONFIG_OF_FPGA_REGION=y
++CONFIG_TEE=y
++CONFIG_OPTEE=y
++CONFIG_MUX_GPIO=m
++CONFIG_MUX_MMIO=y
++CONFIG_SLIMBUS=m
++CONFIG_SLIM_QCOM_CTRL=m
++CONFIG_SLIM_QCOM_NGD_CTRL=m
++CONFIG_INTERCONNECT=y
++CONFIG_INTERCONNECT_IMX=y
++CONFIG_INTERCONNECT_IMX8MM=m
++CONFIG_INTERCONNECT_IMX8MN=m
++CONFIG_INTERCONNECT_IMX8MQ=m
++CONFIG_INTERCONNECT_IMX8MP=y
++CONFIG_INTERCONNECT_QCOM=y
++CONFIG_INTERCONNECT_QCOM_MSM8916=m
++CONFIG_INTERCONNECT_QCOM_MSM8996=y
++CONFIG_INTERCONNECT_QCOM_OSM_L3=m
++CONFIG_INTERCONNECT_QCOM_QCM2290=y
++CONFIG_INTERCONNECT_QCOM_QCS404=m
++CONFIG_INTERCONNECT_QCOM_QDU1000=y
++CONFIG_INTERCONNECT_QCOM_SA8775P=y
++CONFIG_INTERCONNECT_QCOM_SC7180=y
++CONFIG_INTERCONNECT_QCOM_SC7280=y
++CONFIG_INTERCONNECT_QCOM_SC8180X=y
++CONFIG_INTERCONNECT_QCOM_SC8280XP=y
++CONFIG_INTERCONNECT_QCOM_SDM845=y
++CONFIG_INTERCONNECT_QCOM_SDX75=y
++CONFIG_INTERCONNECT_QCOM_SM6115=y
++CONFIG_INTERCONNECT_QCOM_SM8150=y
++CONFIG_INTERCONNECT_QCOM_SM8250=y
++CONFIG_INTERCONNECT_QCOM_SM8350=y
++CONFIG_INTERCONNECT_QCOM_SM8450=y
++CONFIG_INTERCONNECT_QCOM_SM8550=y
++CONFIG_INTERCONNECT_QCOM_SM8650=y
++CONFIG_INTERCONNECT_QCOM_X1E80100=y
++CONFIG_COUNTER=m
++CONFIG_RZ_MTU3_CNT=m
++CONFIG_HTE=y
++CONFIG_HTE_TEGRA194=y
++CONFIG_HTE_TEGRA194_TEST=m
++CONFIG_EXT4_FS=y
++CONFIG_EXT4_FS_POSIX_ACL=y
++CONFIG_EXT4_FS_SECURITY=y
++CONFIG_BTRFS_FS=m
++CONFIG_BTRFS_FS_POSIX_ACL=y
++CONFIG_FANOTIFY=y
++CONFIG_FANOTIFY_ACCESS_PERMISSIONS=y
++CONFIG_QUOTA=y
++CONFIG_AUTOFS_FS=y
++CONFIG_FUSE_FS=m
++CONFIG_CUSE=m
++CONFIG_OVERLAY_FS=y
++CONFIG_OF_OVERLAY=y
++CONFIG_OF_CONFIGFS=y
++CONFIG_VFAT_FS=y
++CONFIG_TMPFS_POSIX_ACL=y
++CONFIG_HUGETLBFS=y
++CONFIG_CONFIGFS_FS=y
++CONFIG_EFIVAR_FS=y
++CONFIG_UBIFS_FS=y
++CONFIG_MTD_SPI_NOR_USE_4K_SECTORS=n
++CONFIG_SQUASHFS=y
++CONFIG_PSTORE_RAM=m
++CONFIG_NFS_FS=y
++CONFIG_NFS_V4=y
++CONFIG_NFS_V4_1=y
++CONFIG_NFS_V4_2=y
++CONFIG_ROOT_NFS=y
++CONFIG_NFSD=y
++CONFIG_9P_FS=y
++CONFIG_NLS_CODEPAGE_437=y
++CONFIG_NLS_ISO8859_1=y
++CONFIG_SECURITY=y
++CONFIG_CRYPTO_USER=y
++CONFIG_CRYPTO_TEST=m
++CONFIG_CRYPTO_ECHAINIV=y
++CONFIG_CRYPTO_MICHAEL_MIC=m
++CONFIG_CRYPTO_ANSI_CPRNG=y
++CONFIG_CRYPTO_USER_API_RNG=m
++CONFIG_CRYPTO_CHACHA20_NEON=m
++CONFIG_CRYPTO_GHASH_ARM64_CE=y
++CONFIG_CRYPTO_SHA1_ARM64_CE=y
++CONFIG_CRYPTO_SHA2_ARM64_CE=y
++CONFIG_CRYPTO_SHA512_ARM64_CE=m
++CONFIG_CRYPTO_SHA3_ARM64=m
++CONFIG_CRYPTO_SM3_ARM64_CE=m
++CONFIG_CRYPTO_AES_ARM64_CE_BLK=y
++CONFIG_CRYPTO_AES_ARM64_BS=m
++CONFIG_CRYPTO_AES_ARM64_CE_CCM=y
++CONFIG_CRYPTO_CRCT10DIF_ARM64_CE=m
++CONFIG_CRYPTO_DEV_SUN8I_CE=m
++CONFIG_CRYPTO_DEV_FSL_CAAM=m
++CONFIG_CRYPTO_DEV_FSL_DPAA2_CAAM=m
++CONFIG_CRYPTO_DEV_QCE=m
++CONFIG_CRYPTO_DEV_QCOM_RNG=m
++CONFIG_CRYPTO_DEV_TEGRA=m
++CONFIG_CRYPTO_DEV_CCREE=m
++CONFIG_CRYPTO_DEV_HISI_SEC2=m
++CONFIG_CRYPTO_DEV_HISI_ZIP=m
++CONFIG_CRYPTO_DEV_HISI_HPRE=m
++CONFIG_CRYPTO_DEV_HISI_TRNG=m
++CONFIG_CRYPTO_DEV_SA2UL=m
++CONFIG_DMA_RESTRICTED_POOL=y
++CONFIG_CMA_SIZE_MBYTES=32
++CONFIG_PRINTK_TIME=y
++CONFIG_DEBUG_KERNEL=y
++CONFIG_DEBUG_INFO_DWARF_TOOLCHAIN_DEFAULT=y
++CONFIG_DEBUG_INFO_REDUCED=y
++CONFIG_MAGIC_SYSRQ=y
++CONFIG_DEBUG_FS=y
++CONFIG_CORESIGHT=m
++CONFIG_CORESIGHT_LINK_AND_SINK_TMC=m
++CONFIG_CORESIGHT_CATU=m
++CONFIG_CORESIGHT_SINK_TPIU=m
++CONFIG_CORESIGHT_SINK_ETBV10=m
++CONFIG_CORESIGHT_STM=m
++CONFIG_CORESIGHT_CPU_DEBUG=m
++CONFIG_CORESIGHT_CTI=m
++CONFIG_MEMTEST=y
++CONFIG_CRYPTO_USER_API_HASH=m
++CONFIG_CRYPTO_USER_API_SKCIPHER=m
++CONFIG_CRYPTO_USER_API_AEAD=m
++CONFIG_ALTERA_SOCFPGA_FCS_HAL=m
++CONFIG_ALTERA_SOCFPGA_CONFIG=m
++CONFIG_CRYPTO_DEV_ALTERA_FCS=m
++CONFIG_I2C_ALTERA=y
++CONFIG_SENSORS_IIO_HWMON=y
+diff -Naur --no-dereference '--exclude=.git' A/arch/arm64/Kconfig.platforms B/arch/arm64/Kconfig.platforms
+--- A/arch/arm64/Kconfig.platforms	2025-11-19 15:57:17.915331672 +0530
++++ B/arch/arm64/Kconfig.platforms	2025-12-08 11:06:15.659495693 +0530
+@@ -304,6 +304,14 @@
+ 	  Stratix 10 (ex. Altera), Stratix10 Software Virtual Platform,
+ 	  Agilex and eASIC N5X.
+ 
++config AGILEX5_IG58M_H
++       bool "Enable Support for iWave IG58M"
++       depends on ARCH_INTEL_SOCFPGA
++       default y
++       help
++         This enables support for the iWave's IG58M Platform. If you don't know what to do here, say N
++
++
+ config ARCH_STM32
+ 	bool "STMicroelectronics STM32 SoC Family"
+ 	select GPIOLIB
+diff -Naur --no-dereference '--exclude=.git' A/drivers/fpga/altera-hps2fpga.c B/drivers/fpga/altera-hps2fpga.c
+--- A/drivers/fpga/altera-hps2fpga.c	2025-11-19 15:56:39.026082522 +0530
++++ B/drivers/fpga/altera-hps2fpga.c	2025-12-08 11:06:15.659495693 +0530
+@@ -38,6 +38,7 @@
+ #define HPS2FPGA_BRIDGE_NAME			"hps2fpga"
+ #define LWHPS2FPGA_BRIDGE_NAME			"lwhps2fpga"
+ #define FPGA2HPS_BRIDGE_NAME			"fpga2hps"
++#define FPGA2SDRAM_BRIDGE_NAME			"fpga2sdram"
+ 
+ struct altera_hps2fpga_data {
+ 	const char *name;
+@@ -102,18 +103,22 @@
+ 
+ static struct altera_hps2fpga_data hps2fpga_data  = {
+ 	.name = HPS2FPGA_BRIDGE_NAME,
+-	.remap_mask = ALT_L3_REMAP_H2F_MSK,
++//	.remap_mask = ALT_L3_REMAP_H2F_MSK,
+ };
+ 
+ static struct altera_hps2fpga_data lwhps2fpga_data  = {
+ 	.name = LWHPS2FPGA_BRIDGE_NAME,
+-	.remap_mask = ALT_L3_REMAP_LWH2F_MSK,
++//	.remap_mask = ALT_L3_REMAP_LWH2F_MSK,
+ };
+ 
+ static struct altera_hps2fpga_data fpga2hps_data  = {
+ 	.name = FPGA2HPS_BRIDGE_NAME,
+ };
+ 
++static struct altera_hps2fpga_data fpga2sdram_data  = {
++	.name = FPGA2SDRAM_BRIDGE_NAME,
++};
++
+ static const struct of_device_id altera_fpga_of_match[] = {
+ 	{ .compatible = "altr,socfpga-hps2fpga-bridge",
+ 	  .data = &hps2fpga_data },
+@@ -121,6 +126,8 @@
+ 	  .data = &lwhps2fpga_data },
+ 	{ .compatible = "altr,socfpga-fpga2hps-bridge",
+ 	  .data = &fpga2hps_data },
++	{ .compatible = "altr,socfpga-fpga2sdram-bridge",
++	  .data = &fpga2sdram_data },	
+ 	{},
+ };
+ 
+@@ -133,7 +140,7 @@
+ 	int ret;
+ 
+ 	priv = (struct altera_hps2fpga_data *)device_get_match_data(dev);
+-
++	printk("@alt_fpga_bridge_probe() - Name: %s remap_mask: %d\n", priv->name, priv->remap_mask);
+ 	priv->bridge_reset = of_reset_control_get_exclusive_by_index(dev->of_node,
+ 								     0);
+ 	if (IS_ERR(priv->bridge_reset)) {
+@@ -182,10 +189,11 @@
+ 	}
+ 
+ 	platform_set_drvdata(pdev, br);
+-
++	printk("@alt_fpga_bridge_probe() - Exit sucsessfully!\n");
+ 	return 0;
+ 
+ err:
++	printk("@alt_fpga_bridge_probe() - Probe failed with 0x%x \n", ret);
+ 	clk_disable_unprepare(priv->clk);
+ 
+ 	return ret;
+diff -Naur --no-dereference '--exclude=.git' A/drivers/gpio/gpiolib.c B/drivers/gpio/gpiolib.c
+--- A/drivers/gpio/gpiolib.c	2025-11-19 15:56:39.225078513 +0530
++++ B/drivers/gpio/gpiolib.c	2025-12-08 11:06:15.659495693 +0530
+@@ -2988,7 +2988,7 @@
+ 
+ 	/* If the driver supports it, set the persistence state now */
+ 	return gpio_set_config_with_argument_optional(desc,
+-						      PIN_CONFIG_PERSIST_STATE,
++						     0,
+ 						      !transitory);
+ }
+ 
+diff -Naur --no-dereference '--exclude=.git' A/drivers/mfd/da9062-core.c B/drivers/mfd/da9062-core.c
+--- A/drivers/mfd/da9062-core.c	2025-11-19 15:56:56.101744664 +0530
++++ B/drivers/mfd/da9062-core.c	2025-12-08 11:06:15.660495706 +0530
+@@ -663,7 +663,8 @@
+ 			cell_num = ARRAY_SIZE(da9062_devs_irq);
+ 			irq_chip = &da9062_irq_chip;
+ 		}
+-
++/* IG58M: Removing interrupt for iWave board */
++#ifndef CONFIG_AGILEX5_IG58M_H
+ 		ret = da9062_configure_irq_type(chip, i2c->irq, &trigger_type);
+ 		if (ret < 0) {
+ 			dev_err(chip->dev, "Failed to configure IRQ type\n");
+@@ -680,6 +681,10 @@
+ 		}
+ 
+ 		irq_base = regmap_irq_chip_get_base(chip->regmap_irq);
++#else
++	irq_base = 0;
++#endif
++
+ 	}
+ 
+ 	ret = mfd_add_devices(chip->dev, PLATFORM_DEVID_NONE, cell,
+diff -Naur --no-dereference '--exclude=.git' A/drivers/mfd/iG58m_info.c B/drivers/mfd/iG58m_info.c
+--- A/drivers/mfd/iG58m_info.c	1970-01-01 05:30:00.000000000 +0530
++++ B/drivers/mfd/iG58m_info.c	2025-12-09 12:02:34.538324088 +0530
+@@ -0,0 +1,184 @@
++// SPDX-License-Identifier: GPL-2.0-or-later
++/*
++ * iG-Rainbow-G58M Platform Info Driver
++ * Copyright (C) 2025 iWave Global 
++ */
++
++#include <linux/module.h>
++#include <linux/kernel.h>
++#include <linux/of_gpio.h>
++#include <linux/gpio.h>
++#include <linux/i2c.h>
++#include <linux/err.h>
++#include <linux/platform_device.h>
++
++#define BSP_VERSION   		"iG-PRHSZ-SC-01-R2.0-REL0.1-SD2.0-Q25.1-L6.12.11"
++#define SOM_I2C_BUS        	CONFIG_SOM_I2C_BUS
++#define SOM_EEPROM_ADDR      	CONFIG_SOM_EEPROM_ADDR
++#define CC_I2C_BUS		CONFIG_CC_I2C_BUS
++#define CC_EEPROM_ADDR		CONFIG_CC_EEPROM_ADDR
++
++
++void print_carrier_board_version(void);
++void print_som_version(void);
++void print_som_version(void);
++
++void print_carrier_board_version(void)
++{
++	char crb_ver[17] = {0}; // Buffer size plus one for null termination
++	char crb_num[13] = {0}; // Buffer size plus one for null termination
++	int ret;
++	struct i2c_client *client;
++	struct i2c_adapter *adapter;
++
++	adapter = i2c_get_adapter(CC_I2C_BUS);
++	if (!adapter) {
++		pr_err("I2C: Failed to get adapter\n");
++		return;
++	}
++
++	client = kzalloc(sizeof(struct i2c_client), GFP_KERNEL);
++	if (!client) {
++		pr_err("Failed to allocate memory for I2C client\n");
++		i2c_put_adapter(adapter);
++		return;
++	}
++    
++	strncpy(client->name, "dummy", I2C_NAME_SIZE);
++	client->adapter = adapter;
++	client->addr = CC_EEPROM_ADDR;
++
++	/* Read the carrier board version */
++	ret = i2c_smbus_read_i2c_block_data(client, 0x20, 16, crb_ver);
++	if (ret < 0) {
++		pr_err("I2C: Failed to read carrier board version\n");
++		goto cleanup;
++	}
++
++	/* Read the carrier board number */
++	ret = i2c_smbus_read_i2c_block_data(client, 0x30, 12, crb_num);
++	if (ret < 0) {
++		pr_err("I2C: Failed to read carrier board number\n");
++		goto cleanup;
++	}
++
++	printk("\tCarrier Version\t: %s-%s\n", crb_ver, crb_num);
++
++cleanup:
++	kfree(client);
++	i2c_put_adapter(adapter);
++}
++void print_som_version(void)
++{
++        char bsp_ver1[33] = {0}; // Buffer size plus one for null termination
++        char bsp_ver2[18] = {0}; // Buffer size plus one for null termination
++        char som_serial_ver[20] = {0}; // Buffer size plus one for null termination
++        char som_num[20] = {0}; // Buffer size plus one for null termination
++	int ret;
++	struct i2c_client *client;
++	struct i2c_adapter *adapter;
++
++
++	adapter = i2c_get_adapter(SOM_I2C_BUS);
++	if (!adapter) {
++		pr_err("I2C: Failed to get adapter\n");
++		return;
++	}
++
++	client = kzalloc(sizeof(struct i2c_client), GFP_KERNEL);
++	if (!client) {
++		pr_err("Failed to allocate memory for I2C client\n");
++		i2c_put_adapter(adapter);
++		return;
++	}
++
++	i2c_set_clientdata(client, NULL);
++	strncpy(client->name, "dummy", I2C_NAME_SIZE);
++	client->adapter = adapter;
++	client->addr = SOM_EEPROM_ADDR;
++	client->flags = 0;
++	client->irq = 0;
++
++	ret = i2c_smbus_read_i2c_block_data(client, 0x40, 32, bsp_ver1);
++	if (ret < 0) {
++		pr_err("I2C: Failed to read BSP version\n");
++		goto cleanup;
++	}
++
++	ret = i2c_smbus_read_i2c_block_data(client, 0x60, 17, bsp_ver2);
++	if (ret < 0) {
++		pr_err("I2C: Failed to read BSP version\n");
++		goto cleanup;
++	}
++
++	ret = i2c_smbus_read_i2c_block_data(client, 0x20, 16, som_serial_ver);
++	if (ret < 0) {
++		pr_err("I2C: Failed to read SOM version\n");
++		goto cleanup;
++	}
++
++	ret = i2c_smbus_read_i2c_block_data(client, 0x30, 12, som_num);
++	if (ret < 0) {
++		pr_err("I2C: Failed to read SOM Number\n");
++		goto cleanup;
++	}
++
++	pr_info("\nBoard Info:\n");
++	pr_info("\tSOM Version\t: %s-%s\n", som_serial_ver, som_num);
++	pr_info("\tBSP Version (Shipped)\t: %s%s\n", bsp_ver1,bsp_ver2);
++
++cleanup:
++	kfree(client);
++	i2c_put_adapter(adapter);
++}
++
++static int iG58m_probe(struct platform_device *pdev)
++{
++	printk("\nBSP Info:\n");
++#ifdef CONFIG_BSP_VER_INFO	
++	printk("\tBSP Version\t: %s\n", BSP_VERSION);
++#endif
++	
++#ifdef CONFIG_SOM_REV_INFO
++	print_som_version();
++#endif
++	
++#ifdef CONFIG_CC_REV_INFO	
++	print_carrier_board_version();
++#endif	
++	printk("\n");
++
++	return 0;
++}
++
++static const struct of_device_id iG58m_info_match[] = {
++	{ .compatible = "iwave,iG58m-info" },
++	{ },
++};
++MODULE_DEVICE_TABLE(of, iG58m_info_match);
++
++static struct platform_driver iG58m_driver = {
++	.driver = {
++		.name = "iG58m_info",
++		.owner = THIS_MODULE,
++		.of_match_table = of_match_ptr(iG58m_info_match),
++	},
++	.probe = iG58m_probe,
++};
++
++static int __init iG58m_info_init(void)
++{
++	return platform_driver_register(&iG58m_driver);
++}
++
++static void __exit iG58m_info_exit(void)
++{
++	platform_driver_unregister(&iG58m_driver);
++}
++
++late_initcall(iG58m_info_init);
++module_exit(iG58m_info_exit);
++
++MODULE_AUTHOR("iWave Global");
++MODULE_DESCRIPTION("IG58m Board Info driver");
++MODULE_LICENSE("GPL v2");
+diff -Naur --no-dereference '--exclude=.git' A/drivers/mfd/Kconfig B/drivers/mfd/Kconfig
+--- A/drivers/mfd/Kconfig	2025-11-19 15:56:56.074745187 +0530
++++ B/drivers/mfd/Kconfig	2025-12-08 11:06:15.660495706 +0530
+@@ -424,6 +424,13 @@
+ 	  Additional drivers must be enabled in order to use the functionality
+ 	  of the device.
+ 
++config IG58M_BDINFO
++       bool "iG-RainboW-G58M platform info driver"
++       depends on AGILEX5_IG58M_H
++       default y
++       help
++         Enable iWave's IWG58M Platform Specific code. Display BSP, SOM and carrier card revision etc.
++
+ config MFD_DA9150
+ 	tristate "Dialog Semiconductor DA9150 Charger Fuel-Gauge chip"
+ 	depends on I2C
+@@ -2388,6 +2395,50 @@
+ 	  Additional drivers must be enabled in order to use the functionality
+ 	  of the device.
+ 
++config CC_I2C_BUS
++       int "I2C bus number for the Carrier board EEPROM"
++       range 0 9
++       default 0
++       help
++        Specify the I2C bus number where the Carrier board EEPROM is connected.
++
++config CC_EEPROM_ADDR
++       hex "I2C address for the Carrier board EEPROM"
++       default 0x52
++       help
++        Specify the I2C address of the Carrier board EEPROM.
++
++config SOM_I2C_BUS
++       int "I2C bus number for the PMIC Regulator 1"
++       range 0 9
++       default 0
++       help
++        Specify the I2C bus number where the PMIC Regulator 1 is connected.
++
++config SOM_EEPROM_ADDR
++       hex "I2C address for the PMIC Regulator 1"
++       default 0x58
++       help
++        Specify the I2C address of the PMIC Regulator 1.
++
++config BSP_VER_INFO
++       bool "Print BSP Version"
++       default y
++       help
++        Enable this option to print BSP Version information.
++
++config CC_REV_INFO
++       bool "Print Carrier card revision"
++       default y
++       help
++        Enable this option to print SOM Revision information.
++
++config SOM_REV_INFO
++       bool "Print SOM revision"
++       default y
++       help
++        Enable this option to print Carrier Revision information.
++
+ config MFD_RSMU_SPI
+ 	tristate "Renesas Synchronization Management Unit with SPI"
+ 	depends on SPI && OF
+diff -Naur --no-dereference '--exclude=.git' A/drivers/mfd/Makefile B/drivers/mfd/Makefile
+--- A/drivers/mfd/Makefile	2025-11-19 15:56:56.075745168 +0530
++++ B/drivers/mfd/Makefile	2025-12-08 11:06:15.660495706 +0530
+@@ -159,6 +159,7 @@
+ obj-$(CONFIG_MFD_DA9062)	+= da9062-core.o
+ da9063-objs			:= da9063-core.o da9063-irq.o da9063-i2c.o
+ obj-$(CONFIG_MFD_DA9063)	+= da9063.o
++obj-$(CONFIG_IG58M_BDINFO)      += iG58m_info.o
+ obj-$(CONFIG_MFD_DA9150)	+= da9150-core.o
+ 
+ obj-$(CONFIG_MFD_MAX14577)	+= max14577.o
+diff -Naur --no-dereference '--exclude=.git' A/drivers/mfd/mfd-core.c B/drivers/mfd/mfd-core.c
+--- A/drivers/mfd/mfd-core.c	2025-11-19 15:56:56.144743830 +0530
++++ B/drivers/mfd/mfd-core.c	2025-12-08 11:06:15.660495706 +0530
+@@ -169,7 +169,12 @@
+ 
+ 	pdev->dev.parent = parent;
+ 	pdev->dev.type = &mfd_dev_type;
++	/* IWG58M: DMA Mask: inherit the DMA mask from  parent device when it's available, or set it to zero  */
++	#ifndef CONFIG_AGILEX5_IWG58M_H
+ 	pdev->dev.dma_mask = parent->dma_mask;
++	#else
++        pdev->platform_dma_mask = parent->dma_mask ? *parent->dma_mask : 0;
++	#endif
+ 	pdev->dev.dma_parms = parent->dma_parms;
+ 	pdev->dev.coherent_dma_mask = parent->coherent_dma_mask;
+ 
+diff -Naur --no-dereference '--exclude=.git' A/drivers/pinctrl/pinctrl-da9062.c B/drivers/pinctrl/pinctrl-da9062.c
+--- A/drivers/pinctrl/pinctrl-da9062.c	2025-11-19 15:56:27.966308399 +0530
++++ B/drivers/pinctrl/pinctrl-da9062.c	2025-12-08 11:06:15.660495706 +0530
+@@ -240,7 +240,9 @@
+ 	.direction_input = da9062_gpio_direction_input,
+ 	.direction_output = da9062_gpio_direction_output,
+ 	.set_config = da9062_gpio_set_config,
++#ifndef CONFIG_AGILEX5_IG58M_H 	
+ 	.to_irq = da9062_gpio_to_irq,
++#endif		
+ 	.can_sleep = true,
+ 	.ngpio = DA9062_GPIO_NUM,
+ 	.base = -1,
+diff -Naur --no-dereference '--exclude=.git' A/drivers/rtc/rtc-da9063.c B/drivers/rtc/rtc-da9063.c
+--- A/drivers/rtc/rtc-da9063.c	2025-11-19 15:56:35.475154436 +0530
++++ B/drivers/rtc/rtc-da9063.c	2025-12-08 11:06:15.665495769 +0530
+@@ -368,9 +368,12 @@
+ static const struct rtc_class_ops da9063_rtc_ops = {
+ 	.read_time = da9063_rtc_read_time,
+ 	.set_time = da9063_rtc_set_time,
++	/* IG58M: Removing interrupt for iWave board */
++	#ifndef CONFIG_AGILEX5_IG58M_H
+ 	.read_alarm = da9063_rtc_read_alarm,
+ 	.set_alarm = da9063_rtc_set_alarm,
+ 	.alarm_irq_enable = da9063_rtc_alarm_irq_enable,
++	#endif
+ };
+ 
+ static int da9063_rtc_probe(struct platform_device *pdev)
+@@ -473,16 +476,19 @@
+ 		clear_bit(RTC_FEATURE_UPDATE_INTERRUPT, rtc->rtc_dev->features);
+ 	}
+ 
++	#ifndef CONFIG_AGILEX5_IG58M_H
+ 	irq_alarm = platform_get_irq_byname_optional(pdev, "ALARM");
+ 	if (irq_alarm >= 0) {
+ 		ret = devm_request_threaded_irq(&pdev->dev, irq_alarm, NULL,
+ 						da9063_alarm_event,
+ 						IRQF_TRIGGER_LOW | IRQF_ONESHOT,
+ 						"ALARM", rtc);
+-		if (ret)
++		if (ret) {
+ 			dev_err(&pdev->dev,
+ 				"Failed to request ALARM IRQ %d: %d\n",
+ 				irq_alarm, ret);
++			return ret;
++		}
+ 
+ 		ret = dev_pm_set_wake_irq(&pdev->dev, irq_alarm);
+ 		if (ret)
+@@ -491,11 +497,12 @@
+ 				 irq_alarm, ret);
+ 
+ 		device_init_wakeup(&pdev->dev, true);
+-	}  else if (irq_alarm != -ENXIO) {
++	} else if (irq_alarm != -ENXIO) {
+ 		return irq_alarm;
+ 	} else {
+ 		clear_bit(RTC_FEATURE_ALARM, rtc->rtc_dev->features);
+ 	}
++	#endif
+ 
+ 	return devm_rtc_register_device(rtc->rtc_dev);
+ }
diff -Naur '--exclude=.git' --no-dereference A/meta-iwave/recipes-kernel/linux/linux-socfpga-lts-ig58/socfpga_agilex5_ig58m.cfg B/meta-iwave/recipes-kernel/linux/linux-socfpga-lts-ig58/socfpga_agilex5_ig58m.cfg
--- A/meta-iwave/recipes-kernel/linux/linux-socfpga-lts-ig58/socfpga_agilex5_ig58m.cfg	1970-01-01 05:30:00.000000000 +0530
+++ B/meta-iwave/recipes-kernel/linux/linux-socfpga-lts-ig58/socfpga_agilex5_ig58m.cfg	2025-12-09 19:57:47.594926389 +0530
@@ -0,0 +1,1758 @@
+CONFIG_SYSVIPC=y
+CONFIG_I2C_MUX_GPIO=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_AUDIT=y
+CONFIG_IG58M_BDINFO=y
+CONFIG_NO_HZ_IDLE=y
+CONFIG_PM_WAKELOCKS=y
+CONFIG_PM_WAKELOCKS_LIMIT=100
+CONFIG_PM_WAKELOCKS_GC=y
+CONFIG_PM_DEBUG=y
+CONFIG_PM_TEST_SUSPEND=y
+CONFIG_PM_SLEEP_DEBUG=y
+CONFIG_INTEL_STRATIX10_RSU=y
+CONFIG_MTD_UBI=y
+CONFIG_SPI_MT65XX=y
+CONFIG_SPI_MTK_NOR=m
+CONFIG_SPI_OMAP24XX=m
+CONFIG_MTD_OF_PARTS=y
+CONFIG_MTD_SPI_NOR_SWP_DISABLE_ON_VOLATILE=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_BSP_VER_INFO=y
+CONFIG_CC_REV_INFO=y
+CONFIG_SOM_REV_INFO=y
+CONFIG_BPF_SYSCALL=y
+CONFIG_BPF_JIT=y
+CONFIG_PREEMPT=y
+CONFIG_IRQ_TIME_ACCOUNTING=y
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_TASKSTATS=y
+CONFIG_TASK_XACCT=y
+CONFIG_RTC_DRV_DA9063=y
+CONFIG_TASK_IO_ACCOUNTING=y
+CONFIG_IKCONFIG=y
+CONFIG_CC_I2C_BUS=0
+CONFIG_CC_EEPROM_ADDR=0x52
+CONFIG_SOM_I2C_BUS=0
+CONFIG_SOM_EEPROM_ADDR=0X56
+CONFIG_IKCONFIG_PROC=y
+CONFIG_NUMA_BALANCING=y
+CONFIG_MEMCG=y
+CONFIG_BLK_CGROUP=y
+CONFIG_CGROUP_PIDS=y
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_HUGETLB=y
+CONFIG_CPUSETS=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_CGROUP_PERF=y
+CONFIG_CGROUP_BPF=y
+CONFIG_USER_NS=y
+CONFIG_SCHED_AUTOGROUP=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_EXPERT=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_PROFILING=y
+CONFIG_KEXEC=y
+CONFIG_KEXEC_FILE=y
+CONFIG_CRASH_DUMP=y
+CONFIG_ARCH_ACTIONS=y
+CONFIG_ARCH_AIROHA=y
+CONFIG_ARCH_SUNXI=y
+CONFIG_ARCH_ALPINE=y
+CONFIG_ARCH_APPLE=y
+CONFIG_ARCH_BCM=y
+CONFIG_ARCH_BCM2835=y
+CONFIG_ARCH_BCM_IPROC=y
+CONFIG_ARCH_BCMBCA=y
+CONFIG_ARCH_BRCMSTB=y
+CONFIG_ARCH_DM=y
+CONFIG_ARCH_BERLIN=y
+CONFIG_ARCH_EXYNOS=y
+CONFIG_ARCH_SPARX5=y
+CONFIG_ARCH_K3=y
+CONFIG_ARCH_LG1K=y
+CONFIG_ARCH_HISI=y
+CONFIG_ARCH_KEEMBAY=y
+CONFIG_ARCH_MEDIATEK=y
+CONFIG_ARCH_MESON=y
+CONFIG_ARCH_MVEBU=y
+CONFIG_ARCH_NXP=y
+CONFIG_ARCH_LAYERSCAPE=y
+CONFIG_ARCH_MXC=y
+CONFIG_ARCH_S32=y
+CONFIG_ARCH_MA35=y
+CONFIG_ARCH_NPCM=y
+CONFIG_ARCH_QCOM=y
+CONFIG_ARCH_REALTEK=y
+CONFIG_ARCH_RENESAS=y
+CONFIG_ARCH_ROCKCHIP=y
+CONFIG_ARCH_SEATTLE=y
+CONFIG_ARCH_INTEL_SOCFPGA=y
+CONFIG_ARCH_STM32=y
+CONFIG_ARCH_SYNQUACER=y
+CONFIG_ARCH_TEGRA=y
+CONFIG_ARCH_TESLA_FSD=y
+CONFIG_ARCH_SPRD=y
+CONFIG_ARCH_THUNDER=y
+CONFIG_ARCH_THUNDER2=y
+CONFIG_ARCH_UNIPHIER=y
+CONFIG_ARCH_VEXPRESS=y
+CONFIG_ARCH_VISCONTI=y
+CONFIG_ARCH_XGENE=y
+CONFIG_ARCH_ZYNQMP=y
+CONFIG_SCHED_MC=y
+CONFIG_SCHED_SMT=y
+CONFIG_NUMA=y
+CONFIG_XEN=y
+CONFIG_COMPAT=y
+CONFIG_RANDOMIZE_BASE=y
+CONFIG_HIBERNATION=y
+CONFIG_WQ_POWER_EFFICIENT_DEFAULT=y
+CONFIG_ENERGY_MODEL=y
+CONFIG_ARM_PSCI_CPUIDLE=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=m
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=m
+CONFIG_CPUFREQ_DT=y
+CONFIG_ACPI_CPPC_CPUFREQ=m
+CONFIG_ARM_ALLWINNER_SUN50I_CPUFREQ_NVMEM=m
+CONFIG_ARM_ARMADA_37XX_CPUFREQ=y
+CONFIG_ARM_SCPI_CPUFREQ=y
+CONFIG_ARM_IMX_CPUFREQ_DT=m
+CONFIG_ARM_MEDIATEK_CPUFREQ=y
+CONFIG_ARM_QCOM_CPUFREQ_NVMEM=y
+CONFIG_ARM_QCOM_CPUFREQ_HW=y
+CONFIG_ARM_RASPBERRYPI_CPUFREQ=m
+CONFIG_ARM_SCMI_CPUFREQ=y
+CONFIG_ARM_TEGRA186_CPUFREQ=y
+CONFIG_QORIQ_CPUFREQ=y
+CONFIG_ACPI=y
+CONFIG_ACPI_HOTPLUG_MEMORY=y
+CONFIG_ACPI_HMAT=y
+CONFIG_ACPI_APEI=y
+CONFIG_ACPI_APEI_GHES=y
+CONFIG_ACPI_APEI_PCIEAER=y
+CONFIG_ACPI_APEI_MEMORY_FAILURE=y
+CONFIG_ACPI_APEI_EINJ=y
+CONFIG_VIRTUALIZATION=y
+CONFIG_KVM=y
+CONFIG_CRYPTO_DEV_INTEL_FCS=m
+CONFIG_JUMP_LABEL=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_IOSCHED_BFQ=y
+CONFIG_MEMORY_HOTPLUG=y
+CONFIG_MEMORY_HOTREMOVE=y
+CONFIG_KSM=y
+CONFIG_MEMORY_FAILURE=y
+CONFIG_TRANSPARENT_HUGEPAGE=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IPV6=m
+CONFIG_NETFILTER=y
+CONFIG_BRIDGE_NETFILTER=m
+CONFIG_NF_CONNTRACK=m
+CONFIG_NF_CONNTRACK_EVENTS=y
+CONFIG_NETFILTER_XT_MARK=m
+CONFIG_NETFILTER_XT_TARGET_CHECKSUM=m
+CONFIG_NETFILTER_XT_TARGET_LOG=m
+CONFIG_NETFILTER_XT_MATCH_ADDRTYPE=m
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=m
+CONFIG_NETFILTER_XT_MATCH_IPVS=m
+CONFIG_IP_VS=m
+CONFIG_IP_NF_IPTABLES=m
+CONFIG_IP_NF_FILTER=m
+CONFIG_IP_NF_TARGET_REJECT=m
+CONFIG_IP_NF_NAT=m
+CONFIG_IP_NF_TARGET_MASQUERADE=m
+CONFIG_IP_NF_MANGLE=m
+CONFIG_IP6_NF_IPTABLES=m
+CONFIG_IP6_NF_FILTER=m
+CONFIG_IP6_NF_TARGET_REJECT=m
+CONFIG_IP6_NF_MANGLE=m
+CONFIG_IP6_NF_NAT=m
+CONFIG_IP6_NF_TARGET_MASQUERADE=m
+CONFIG_BRIDGE=m
+CONFIG_BRIDGE_VLAN_FILTERING=y
+CONFIG_NET_DSA=m
+CONFIG_VLAN_8021Q=m
+CONFIG_VLAN_8021Q_GVRP=y
+CONFIG_VLAN_8021Q_MVRP=y
+CONFIG_NET_SCHED=y
+CONFIG_NET_SCH_CBS=m
+CONFIG_NET_SCH_ETF=m
+CONFIG_NET_SCH_TAPRIO=m
+CONFIG_NET_SCH_MQPRIO=m
+CONFIG_NET_SCH_INGRESS=m
+CONFIG_NET_CLS_BASIC=m
+CONFIG_NET_CLS_FLOWER=m
+CONFIG_NET_CLS_ACT=y
+CONFIG_NET_ACT_GACT=m
+CONFIG_NET_ACT_MIRRED=m
+CONFIG_NET_ACT_GATE=m
+CONFIG_QRTR_SMD=m
+CONFIG_QRTR_TUN=m
+CONFIG_CAN=m
+CONFIG_BT=m
+CONFIG_BT_HIDP=m
+CONFIG_BT_LEDS=y
+CONFIG_BT_HCIBTUSB=m
+CONFIG_BT_HCIBTUSB_MTK=y
+CONFIG_BT_HCIUART=m
+CONFIG_BT_HCIUART_LL=y
+CONFIG_BT_HCIUART_BCM=y
+CONFIG_BT_HCIUART_QCA=y
+CONFIG_BT_HCIUART_MRVL=y
+CONFIG_BT_MRVL=m
+CONFIG_BT_MRVL_SDIO=m
+CONFIG_BT_QCOMSMD=m
+CONFIG_BT_NXPUART=m
+CONFIG_CFG80211=m
+CONFIG_MAC80211=m
+CONFIG_MAC80211_LEDS=y
+CONFIG_RFKILL=m
+CONFIG_NET_9P=y
+CONFIG_NET_9P_VIRTIO=y
+CONFIG_NFC=m
+CONFIG_NFC_NCI=m
+CONFIG_NFC_S3FWRN5_I2C=m
+CONFIG_PCI=y
+CONFIG_PCIEPORTBUS=y
+CONFIG_PCIEAER=y
+CONFIG_PCI_IOV=y
+CONFIG_PCI_PASID=y
+CONFIG_HOTPLUG_PCI=y
+CONFIG_HOTPLUG_PCI_ACPI=y
+CONFIG_PCI_AARDVARK=y
+CONFIG_PCIE_ALTERA=y
+CONFIG_PCIE_ALTERA_MSI=y
+CONFIG_PCIE_BRCMSTB=m
+CONFIG_PCI_HOST_THUNDER_PEM=y
+CONFIG_PCI_HOST_THUNDER_ECAM=y
+CONFIG_PCI_HOST_GENERIC=y
+CONFIG_PCIE_MEDIATEK_GEN3=m
+CONFIG_PCI_TEGRA=y
+CONFIG_PCIE_RCAR_HOST=y
+CONFIG_PCIE_RCAR_EP=y
+CONFIG_PCIE_ROCKCHIP_HOST=m
+CONFIG_PCI_XGENE=y
+CONFIG_PCI_IMX6_HOST=y
+CONFIG_PCI_LAYERSCAPE=y
+CONFIG_PCI_HISI=y
+CONFIG_PCIE_KIRIN=y
+CONFIG_PCIE_HISI_STB=y
+CONFIG_PCIE_ARMADA_8K=y
+CONFIG_PCIE_TEGRA194_HOST=m
+CONFIG_PCIE_TEGRA194_EP=m
+CONFIG_PCIE_QCOM=y
+CONFIG_PCIE_RCAR_GEN4_HOST=m
+CONFIG_PCIE_RCAR_GEN4_EP=m
+CONFIG_PCIE_ROCKCHIP_DW_HOST=y
+CONFIG_PCIE_VISCONTI_HOST=y
+CONFIG_PCIE_LAYERSCAPE_GEN4=y
+CONFIG_PCI_ENDPOINT=y
+CONFIG_PCI_ENDPOINT_CONFIGFS=y
+CONFIG_PCI_EPF_TEST=m
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_FW_LOADER_USER_HELPER=y
+CONFIG_HISILICON_LPC=y
+CONFIG_TEGRA_ACONNECT=m
+CONFIG_MHI_BUS_PCI_GENERIC=m
+CONFIG_ARM_SCMI_PROTOCOL=y
+CONFIG_ARM_SCPI_PROTOCOL=y
+CONFIG_RASPBERRYPI_FIRMWARE=y
+CONFIG_INTEL_STRATIX10_SERVICE=y
+CONFIG_MTK_ADSP_IPC=m
+CONFIG_GOOGLE_FIRMWARE=y
+CONFIG_GOOGLE_CBMEM=m
+CONFIG_GOOGLE_COREBOOT_TABLE=m
+CONFIG_EFI_CAPSULE_LOADER=y
+CONFIG_IMX_SCU=y
+CONFIG_QCOM_TZMEM_MODE_SHMBRIDGE=y
+CONFIG_QCOM_QSEECOM=y
+CONFIG_QCOM_QSEECOM_UEFISECAPP=y
+CONFIG_GNSS=m
+CONFIG_GNSS_MTK_SERIAL=m
+CONFIG_MTD=y
+CONFIG_MTD_BLOCK=y
+CONFIG_MTD_CFI=y
+CONFIG_MTD_CFI_ADV_OPTIONS=y
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_STAA=y
+CONFIG_MTD_PHYSMAP=y
+CONFIG_MTD_PHYSMAP_OF=y
+CONFIG_MTD_DATAFLASH=y
+CONFIG_MTD_SST25L=y
+CONFIG_MTD_RAW_NAND=y
+CONFIG_MTD_NAND_DENALI_DT=y
+CONFIG_MTD_NAND_MARVELL=y
+CONFIG_MTD_NAND_BRCMNAND=m
+CONFIG_MTD_NAND_FSL_IFC=y
+CONFIG_MTD_NAND_QCOM=y
+CONFIG_MTD_SPI_NOR=y
+CONFIG_MTD_HYPERBUS=m
+CONFIG_HBMC_AM654=m
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_NBD=m
+CONFIG_VIRTIO_BLK=y
+CONFIG_BLK_DEV_NVME=m
+CONFIG_QCOM_COINCELL=m
+CONFIG_QCOM_FASTRPC=m
+CONFIG_SRAM=y
+CONFIG_PCI_ENDPOINT_TEST=m
+CONFIG_EEPROM_AT24=y
+CONFIG_ALTERA_SYSID=y
+CONFIG_ALTERA_ILC=m
+CONFIG_EEPROM_AT25=m
+CONFIG_UACCE=m
+CONFIG_BLK_DEV_SD=y
+CONFIG_SCSI_SAS_ATA=y
+CONFIG_SCSI_HISI_SAS=y
+CONFIG_SCSI_HISI_SAS_PCI=y
+CONFIG_MEGARAID_SAS=y
+CONFIG_SCSI_MPT3SAS=m
+CONFIG_ATA=y
+CONFIG_SATA_AHCI=y
+CONFIG_SATA_AHCI_PLATFORM=y
+CONFIG_AHCI_BRCM=m
+CONFIG_AHCI_DWC=m
+CONFIG_AHCI_CEVA=y
+CONFIG_AHCI_MVEBU=y
+CONFIG_AHCI_XGENE=y
+CONFIG_AHCI_QORIQ=y
+CONFIG_SATA_SIL24=y
+CONFIG_SATA_RCAR=y
+CONFIG_PATA_PLATFORM=y
+CONFIG_PATA_OF_PLATFORM=y
+CONFIG_MD=y
+CONFIG_BLK_DEV_MD=m
+CONFIG_BLK_DEV_DM=m
+CONFIG_DM_MIRROR=m
+CONFIG_DM_ZERO=m
+CONFIG_NETDEVICES=y
+CONFIG_MACVLAN=m
+CONFIG_MACVTAP=m
+CONFIG_TUN=y
+CONFIG_VETH=m
+CONFIG_VIRTIO_NET=y
+CONFIG_MHI_NET=m
+CONFIG_NET_DSA_BCM_SF2=m
+CONFIG_NET_DSA_MSCC_FELIX=m
+CONFIG_AMD_XGBE=y
+CONFIG_NET_XGENE=y
+CONFIG_ATL1C=m
+CONFIG_BCMGENET=m
+CONFIG_BNX2X=m
+CONFIG_SYSTEMPORT=m
+CONFIG_MACB=y
+CONFIG_THUNDER_NIC_PF=y
+CONFIG_FEC=y
+CONFIG_FSL_FMAN=y
+CONFIG_FSL_DPAA_ETH=y
+CONFIG_FSL_DPAA2_ETH=y
+CONFIG_FSL_ENETC=y
+CONFIG_FSL_ENETC_VF=y
+CONFIG_FSL_ENETC_QOS=y
+CONFIG_HIX5HD2_GMAC=y
+CONFIG_HNS_DSAF=y
+CONFIG_HNS_ENET=y
+CONFIG_HNS3=y
+CONFIG_HNS3_HCLGE=y
+CONFIG_HNS3_ENET=y
+CONFIG_E1000=y
+CONFIG_E1000E=y
+CONFIG_IGB=y
+CONFIG_IGBVF=y
+CONFIG_MVNETA=y
+CONFIG_MVPP2=y
+CONFIG_SKY2=y
+CONFIG_MLX4_EN=m
+CONFIG_MLX5_CORE=m
+CONFIG_MLX5_CORE_EN=y
+CONFIG_QCOM_EMAC=m
+CONFIG_RMNET=m
+CONFIG_R8169=m
+CONFIG_SH_ETH=y
+CONFIG_RAVB=y
+CONFIG_RENESAS_ETHER_SWITCH=y
+CONFIG_RTSN=y
+CONFIG_SMC91X=y
+CONFIG_SMSC911X=y
+CONFIG_SNI_AVE=y
+CONFIG_SNI_NETSEC=y
+CONFIG_DWMAC_TEGRA=m
+CONFIG_STMMAC_ETH=y
+CONFIG_TI_K3_AM65_CPSW_NUSS=y
+CONFIG_TI_ICSSG_PRUETH=m
+CONFIG_QCOM_IPA=m
+CONFIG_MESON_GXL_PHY=m
+CONFIG_AQUANTIA_PHY=y
+CONFIG_BCM54140_PHY=m
+CONFIG_MARVELL_PHY=m
+CONFIG_MARVELL_10G_PHY=y
+CONFIG_MARVELL_88Q2XXX_PHY=y
+CONFIG_MICREL_PHY=y
+CONFIG_MICROSEMI_PHY=y
+CONFIG_AT803X_PHY=y
+CONFIG_REALTEK_PHY=y
+CONFIG_ROCKCHIP_PHY=y
+CONFIG_DP83867_PHY=y
+CONFIG_DP83869_PHY=m
+CONFIG_DP83TD510_PHY=y
+CONFIG_VITESSE_PHY=y
+CONFIG_CAN_FLEXCAN=m
+CONFIG_CAN_M_CAN=m
+CONFIG_CAN_M_CAN_PLATFORM=m
+CONFIG_CAN_RCAR=m
+CONFIG_CAN_RCAR_CANFD=m
+CONFIG_CAN_MCP251XFD=m
+CONFIG_MDIO_GPIO=y
+CONFIG_MDIO_BUS_MUX_MULTIPLEXER=y
+CONFIG_MDIO_BUS_MUX_MMIOREG=y
+CONFIG_USB_PEGASUS=m
+CONFIG_USB_RTL8150=m
+CONFIG_USB_RTL8152=m
+CONFIG_USB_LAN78XX=m
+CONFIG_USB_USBNET=m
+CONFIG_USB_NET_DM9601=m
+CONFIG_USB_NET_SR9800=m
+CONFIG_USB_NET_SMSC75XX=m
+CONFIG_USB_NET_SMSC95XX=m
+CONFIG_USB_NET_PLUSB=m
+CONFIG_USB_NET_MCS7830=m
+CONFIG_ATH10K=m
+CONFIG_ATH10K_PCI=m
+CONFIG_ATH10K_SDIO=m
+CONFIG_ATH10K_SNOC=m
+CONFIG_WCN36XX=m
+CONFIG_ATH11K=m
+CONFIG_ATH11K_AHB=m
+CONFIG_ATH11K_PCI=m
+CONFIG_ATH12K=m
+CONFIG_BRCMFMAC=m
+CONFIG_IWLWIFI=m
+CONFIG_IWLDVM=m
+CONFIG_IWLMVM=m
+CONFIG_MWIFIEX=m
+CONFIG_MWIFIEX_SDIO=m
+CONFIG_MWIFIEX_PCIE=m
+CONFIG_MT7921E=m
+CONFIG_RSI_91X=m
+CONFIG_WL18XX=m
+CONFIG_WLCORE_SDIO=m
+CONFIG_WWAN=m
+CONFIG_MHI_WWAN_CTRL=m
+CONFIG_MHI_WWAN_MBIM=m
+CONFIG_INPUT_EVDEV=y
+CONFIG_KEYBOARD_ADC=m
+CONFIG_KEYBOARD_GPIO=y
+CONFIG_KEYBOARD_GPIO_POLLED=m
+CONFIG_KEYBOARD_SNVS_PWRKEY=m
+CONFIG_KEYBOARD_IMX_SC_KEY=m
+CONFIG_KEYBOARD_CROS_EC=y
+CONFIG_KEYBOARD_MTK_PMIC=m
+CONFIG_MOUSE_ELAN_I2C=m
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_ATMEL_MXT=m
+CONFIG_TOUCHSCREEN_GOODIX=m
+CONFIG_TOUCHSCREEN_GOODIX_BERLIN_SPI=m
+CONFIG_TOUCHSCREEN_ELAN=m
+CONFIG_TOUCHSCREEN_EDT_FT5X06=m
+CONFIG_INPUT_MISC=y
+CONFIG_INPUT_BBNSM_PWRKEY=m
+CONFIG_INPUT_PM8941_PWRKEY=y
+CONFIG_INPUT_PM8XXX_VIBRATOR=m
+CONFIG_INPUT_TPS65219_PWRBUTTON=m
+CONFIG_INPUT_PWM_BEEPER=m
+CONFIG_INPUT_PWM_VIBRA=m
+CONFIG_INPUT_RK805_PWRKEY=m
+CONFIG_INPUT_DA9063_ONKEY=m
+CONFIG_INPUT_HISI_POWERKEY=y
+CONFIG_SERIO_AMBAKMI=y
+CONFIG_LEGACY_PTY_COUNT=16
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=8
+CONFIG_SERIAL_8250_EXTENDED=y
+CONFIG_SERIAL_8250_SHARE_IRQ=y
+CONFIG_SERIAL_8250_BCM2835AUX=y
+CONFIG_SERIAL_8250_DW=y
+CONFIG_SERIAL_8250_EM=y
+CONFIG_SERIAL_8250_OMAP=y
+CONFIG_SERIAL_8250_MT6577=y
+CONFIG_SERIAL_8250_UNIPHIER=y
+CONFIG_SERIAL_OF_PLATFORM=y
+CONFIG_SERIAL_AMBA_PL011=y
+CONFIG_SERIAL_AMBA_PL011_CONSOLE=y
+CONFIG_SERIAL_MESON=y
+CONFIG_SERIAL_MESON_CONSOLE=y
+CONFIG_SERIAL_SAMSUNG=y
+CONFIG_SERIAL_SAMSUNG_CONSOLE=y
+CONFIG_SERIAL_TEGRA=y
+CONFIG_SERIAL_TEGRA_TCU=y
+CONFIG_SERIAL_IMX=y
+CONFIG_SERIAL_IMX_CONSOLE=y
+CONFIG_SERIAL_SH_SCI=y
+CONFIG_SERIAL_MSM=y
+CONFIG_SERIAL_MSM_CONSOLE=y
+CONFIG_SERIAL_QCOM_GENI=y
+CONFIG_SERIAL_QCOM_GENI_CONSOLE=y
+CONFIG_SERIAL_XILINX_PS_UART=y
+CONFIG_SERIAL_XILINX_PS_UART_CONSOLE=y
+CONFIG_SERIAL_FSL_LPUART=y
+CONFIG_SERIAL_FSL_LPUART_CONSOLE=y
+CONFIG_SERIAL_FSL_LINFLEXUART=y
+CONFIG_SERIAL_FSL_LINFLEXUART_CONSOLE=y
+CONFIG_SERIAL_STM32=y
+CONFIG_SERIAL_STM32_CONSOLE=y
+CONFIG_SERIAL_MVEBU_UART=y
+CONFIG_SERIAL_OWL=y
+CONFIG_SERIAL_DEV_BUS=y
+CONFIG_VIRTIO_CONSOLE=y
+CONFIG_IPMI_HANDLER=m
+CONFIG_IPMI_DEVICE_INTERFACE=m
+CONFIG_IPMI_SI=m
+CONFIG_HW_RANDOM=m
+CONFIG_HW_RANDOM_VIRTIO=y
+CONFIG_TCG_TPM=y
+CONFIG_TCG_TIS=m
+CONFIG_TCG_TIS_SPI=m
+CONFIG_TCG_TIS_SPI_CR50=y
+CONFIG_TCG_TIS_I2C_CR50=m
+CONFIG_TCG_TIS_I2C_INFINEON=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_MUX=y
+CONFIG_I2C_MUX_PCA954x=y
+CONFIG_I2C_BCM2835=m
+CONFIG_I2C_CADENCE=m
+CONFIG_I2C_DESIGNWARE_CORE=y
+CONFIG_I2C_DESIGNWARE_PLATFORM=y
+CONFIG_I2C_GPIO=m
+CONFIG_I2C_IMX=y
+CONFIG_I2C_IMX_LPI2C=y
+CONFIG_I2C_MESON=y
+CONFIG_I2C_MT65XX=y
+CONFIG_I2C_MV64XXX=y
+CONFIG_I2C_OMAP=y
+CONFIG_I2C_OWL=y
+CONFIG_I2C_PXA=y
+CONFIG_I2C_QCOM_CCI=m
+CONFIG_I2C_QCOM_GENI=m
+CONFIG_I2C_QUP=y
+CONFIG_I2C_RIIC=y
+CONFIG_I2C_RK3X=y
+CONFIG_I2C_RZV2M=m
+CONFIG_I2C_S3C2410=y
+CONFIG_I2C_SH_MOBILE=y
+CONFIG_I2C_TEGRA=y
+CONFIG_I2C_UNIPHIER_F=y
+CONFIG_I2C_RCAR=y
+CONFIG_I2C_CROS_EC_TUNNEL=y
+CONFIG_SPI=y
+CONFIG_SPI_ARMADA_3700=y
+CONFIG_SPI_BCM2835=m
+CONFIG_SPI_BCM2835AUX=m
+CONFIG_SPI_CADENCE_QUADSPI=y
+CONFIG_SPI_DESIGNWARE=m
+CONFIG_SPI_DW_DMA=y
+CONFIG_SPI_DW_MMIO=m
+CONFIG_SPI_FSL_LPSPI=y
+CONFIG_SPI_FSL_QUADSPI=y
+CONFIG_SPI_NXP_FLEXSPI=y
+CONFIG_SPI_IMX=m
+CONFIG_SPI_FSL_DSPI=y
+CONFIG_SPI_MESON_SPICC=m
+CONFIG_SPI_MESON_SPIFC=m
+CONFIG_SPI_ORION=y
+CONFIG_SPI_PL022=y
+CONFIG_SPI_ROCKCHIP=y
+CONFIG_SPI_ROCKCHIP_SFC=m
+CONFIG_SPI_RPCIF=m
+CONFIG_SPI_RSPI=m
+CONFIG_SPI_RZV2M_CSI=m
+CONFIG_SPI_QCOM_QSPI=m
+CONFIG_SPI_QUP=y
+CONFIG_SPI_QCOM_GENI=m
+CONFIG_SPI_S3C64XX=y
+CONFIG_SPI_SH_MSIOF=m
+CONFIG_SPI_SUN6I=y
+CONFIG_SPI_TEGRA210_QUAD=m
+CONFIG_SPI_TEGRA114=m
+CONFIG_SPI_SPIDEV=m
+CONFIG_SPMI=y
+CONFIG_SPMI_MTK_PMIF=m
+CONFIG_PINCTRL_DA9062=y
+CONFIG_PINCTRL_MAX77620=y
+CONFIG_PINCTRL_RK805=m
+CONFIG_PINCTRL_SINGLE=y
+CONFIG_PINCTRL_OWL=y
+CONFIG_PINCTRL_S700=y
+CONFIG_PINCTRL_S900=y
+CONFIG_PINCTRL_IMX8MM=y
+CONFIG_PINCTRL_IMX8MN=y
+CONFIG_PINCTRL_IMX8MP=y
+CONFIG_PINCTRL_IMX8MQ=y
+CONFIG_PINCTRL_IMX8QM=y
+CONFIG_PINCTRL_IMX8QXP=y
+CONFIG_PINCTRL_IMX8DXL=y
+CONFIG_PINCTRL_IMX8ULP=y
+CONFIG_PINCTRL_IMX93=y
+CONFIG_PINCTRL_MSM=y
+CONFIG_PINCTRL_IPQ5018=y
+CONFIG_PINCTRL_IPQ5332=y
+CONFIG_PINCTRL_IPQ8074=y
+CONFIG_PINCTRL_IPQ6018=y
+CONFIG_PINCTRL_IPQ9574=y
+CONFIG_PINCTRL_MSM8916=y
+CONFIG_PINCTRL_MSM8953=y
+CONFIG_PINCTRL_MSM8976=y
+CONFIG_PINCTRL_MSM8994=y
+CONFIG_PINCTRL_MSM8996=y
+CONFIG_PINCTRL_MSM8998=y
+CONFIG_PINCTRL_QCM2290=y
+CONFIG_PINCTRL_QCS404=y
+CONFIG_PINCTRL_QDF2XXX=y
+CONFIG_PINCTRL_QDU1000=y
+CONFIG_PINCTRL_SA8775P=y
+CONFIG_PINCTRL_SC7180=y
+CONFIG_PINCTRL_SC7280=y
+CONFIG_PINCTRL_SC8180X=y
+CONFIG_PINCTRL_SC8280XP=y
+CONFIG_PINCTRL_SDM660=y
+CONFIG_PINCTRL_SDM670=y
+CONFIG_PINCTRL_SDM845=y
+CONFIG_PINCTRL_SDX75=y
+CONFIG_PINCTRL_SM4450=y
+CONFIG_PINCTRL_SM6115=y
+CONFIG_PINCTRL_SM6125=y
+CONFIG_PINCTRL_SM6350=y
+CONFIG_PINCTRL_SM6375=y
+CONFIG_PINCTRL_SM8150=y
+CONFIG_PINCTRL_SM8250=y
+CONFIG_PINCTRL_SM8350=y
+CONFIG_PINCTRL_SM8450=y
+CONFIG_PINCTRL_SM8550=y
+CONFIG_PINCTRL_SM8650=y
+CONFIG_PINCTRL_X1E80100=y
+CONFIG_PINCTRL_QCOM_SPMI_PMIC=y
+CONFIG_PINCTRL_LPASS_LPI=m
+CONFIG_PINCTRL_SC7280_LPASS_LPI=m
+CONFIG_PINCTRL_SM6115_LPASS_LPI=m
+CONFIG_PINCTRL_SM8250_LPASS_LPI=m
+CONFIG_PINCTRL_SM8350_LPASS_LPI=m
+CONFIG_PINCTRL_SM8450_LPASS_LPI=m
+CONFIG_PINCTRL_SC8280XP_LPASS_LPI=m
+CONFIG_PINCTRL_SM8550_LPASS_LPI=m
+CONFIG_PINCTRL_SM8650_LPASS_LPI=m
+CONFIG_DEBUG_GPIO=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_ALTERA=y
+CONFIG_GPIO_DAVINCI=y
+CONFIG_GPIO_DWAPB=y
+CONFIG_GPIO_MB86S7X=y
+CONFIG_GPIO_MPC8XXX=y
+CONFIG_GPIO_MXC=y
+CONFIG_GPIO_PL061=y
+CONFIG_GPIO_RCAR=y
+CONFIG_GPIO_SYSCON=y
+CONFIG_GPIO_UNIPHIER=y
+CONFIG_GPIO_VISCONTI=y
+CONFIG_GPIO_WCD934X=m
+CONFIG_GPIO_VF610=y
+CONFIG_GPIO_XGENE=y
+CONFIG_GPIO_XGENE_SB=y
+CONFIG_GPIO_MAX732X=y
+CONFIG_GPIO_PCA953X=y
+CONFIG_GPIO_PCA953X_IRQ=y
+CONFIG_GPIO_ADP5585=m
+CONFIG_GPIO_BD9571MWV=m
+CONFIG_GPIO_MAX77620=y
+CONFIG_GPIO_SL28CPLD=m
+CONFIG_GPIO_AGGREGATOR=m
+CONFIG_POWER_RESET_MSM=y
+CONFIG_POWER_RESET_QCOM_PON=m
+CONFIG_POWER_RESET_XGENE=y
+CONFIG_POWER_RESET_SYSCON=y
+CONFIG_POWER_RESET_SYSCON_POWEROFF=y
+CONFIG_SYSCON_REBOOT_MODE=y
+CONFIG_NVMEM_REBOOT_MODE=m
+CONFIG_BATTERY_QCOM_BATTMGR=m
+CONFIG_BATTERY_SBS=m
+CONFIG_BATTERY_BQ27XXX=y
+CONFIG_BATTERY_MAX17042=m
+CONFIG_CHARGER_MT6360=m
+CONFIG_CHARGER_BQ25890=m
+CONFIG_CHARGER_BQ25980=m
+CONFIG_CHARGER_RK817=m
+CONFIG_SENSORS_ARM_SCMI=y
+CONFIG_SENSORS_ARM_SCPI=y
+CONFIG_SENSORS_GPIO_FAN=m
+CONFIG_SENSORS_JC42=m
+CONFIG_SENSORS_LM75=m
+CONFIG_SENSORS_LM90=m
+CONFIG_SENSORS_PWM_FAN=m
+CONFIG_SENSORS_RASPBERRYPI_HWMON=m
+CONFIG_SENSORS_SL28CPLD=m
+CONFIG_SENSORS_SOC64=y
+CONFIG_SENSORS_INA2XX=m
+CONFIG_SENSORS_INA3221=m
+CONFIG_THERMAL_GOV_POWER_ALLOCATOR=y
+CONFIG_CPU_THERMAL=y
+CONFIG_DEVFREQ_THERMAL=y
+CONFIG_THERMAL_EMULATION=y
+CONFIG_IMX_SC_THERMAL=m
+CONFIG_IMX8MM_THERMAL=m
+CONFIG_K3_THERMAL=m
+CONFIG_QORIQ_THERMAL=m
+CONFIG_SUN8I_THERMAL=y
+CONFIG_ROCKCHIP_THERMAL=m
+CONFIG_RCAR_THERMAL=y
+CONFIG_RCAR_GEN3_THERMAL=y
+CONFIG_RZG2L_THERMAL=y
+CONFIG_ARMADA_THERMAL=y
+CONFIG_MTK_THERMAL=m
+CONFIG_MTK_LVTS_THERMAL=m
+CONFIG_BCM2711_THERMAL=m
+CONFIG_BCM2835_THERMAL=m
+CONFIG_BRCMSTB_THERMAL=m
+CONFIG_EXYNOS_THERMAL=y
+CONFIG_TEGRA_SOCTHERM=m
+CONFIG_TEGRA_BPMP_THERMAL=m
+CONFIG_GENERIC_ADC_THERMAL=m
+CONFIG_QCOM_TSENS=y
+CONFIG_QCOM_SPMI_ADC_TM5=m
+CONFIG_QCOM_SPMI_TEMP_ALARM=m
+CONFIG_QCOM_LMH=m
+CONFIG_UNIPHIER_THERMAL=y
+CONFIG_KHADAS_MCU_FAN_THERMAL=m
+CONFIG_WATCHDOG=y
+CONFIG_SL28CPLD_WATCHDOG=m
+CONFIG_ARM_SP805_WATCHDOG=y
+CONFIG_ARM_SBSA_WATCHDOG=y
+CONFIG_S3C2410_WATCHDOG=y
+CONFIG_DW_WATCHDOG=y
+CONFIG_K3_RTI_WATCHDOG=m
+CONFIG_SUNXI_WATCHDOG=m
+CONFIG_NPCM7XX_WATCHDOG=y
+CONFIG_IMX2_WDT=y
+CONFIG_IMX_SC_WDT=m
+CONFIG_IMX7ULP_WDT=m
+CONFIG_QCOM_WDT=m
+CONFIG_MESON_GXBB_WATCHDOG=m
+CONFIG_MESON_WATCHDOG=m
+CONFIG_ARM_SMC_WATCHDOG=y
+CONFIG_RENESAS_WDT=y
+CONFIG_RENESAS_RZG2LWDT=y
+CONFIG_UNIPHIER_WATCHDOG=y
+CONFIG_PM8916_WATCHDOG=m
+CONFIG_BCM2835_WDT=y
+CONFIG_BCM7038_WDT=m
+CONFIG_MFD_ADP5585=m
+CONFIG_MFD_ALTERA_SYSMGR=y
+CONFIG_MFD_BD9571MWV=y
+CONFIG_MFD_AXP20X_I2C=y
+CONFIG_MFD_AXP20X_RSB=y
+CONFIG_MFD_DA9062=y
+CONFIG_MFD_EXYNOS_LPASS=m
+CONFIG_MFD_HI6421_PMIC=y
+CONFIG_MFD_HI655X_PMIC=y
+CONFIG_MFD_MAX77620=y
+CONFIG_MFD_MT6360=y
+CONFIG_MFD_MT6397=y
+CONFIG_MFD_SPMI_PMIC=y
+CONFIG_MFD_RK8XX_I2C=y
+CONFIG_MFD_RK8XX_SPI=y
+CONFIG_MFD_SEC_CORE=y
+CONFIG_MFD_SL28CPLD=y
+CONFIG_RZ_MTU3=y
+CONFIG_MFD_TI_AM335X_TSCADC=m
+CONFIG_MFD_TI_LP873X=m
+CONFIG_MFD_TPS65219=y
+CONFIG_MFD_TPS6594_I2C=m
+CONFIG_MFD_ROHM_BD718XX=y
+CONFIG_MFD_WCD934X=m
+CONFIG_MFD_KHADAS_MCU=m
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+CONFIG_REGULATOR_AXP20X=y
+CONFIG_REGULATOR_BD718XX=y
+CONFIG_REGULATOR_BD9571MWV=y
+CONFIG_REGULATOR_CROS_EC=y
+CONFIG_REGULATOR_DA9062=y
+CONFIG_REGULATOR_DA9211=m
+CONFIG_REGULATOR_FAN53555=y
+CONFIG_REGULATOR_GPIO=y
+CONFIG_REGULATOR_HI6421V530=y
+CONFIG_REGULATOR_HI655X=y
+CONFIG_REGULATOR_LP873X=m
+CONFIG_REGULATOR_MAX77620=y
+CONFIG_REGULATOR_MAX8973=y
+CONFIG_REGULATOR_MAX20411=m
+CONFIG_REGULATOR_MP8859=y
+CONFIG_REGULATOR_MT6315=m
+CONFIG_REGULATOR_MT6357=y
+CONFIG_REGULATOR_MT6358=y
+CONFIG_REGULATOR_MT6359=y
+CONFIG_REGULATOR_MT6360=y
+CONFIG_REGULATOR_MT6397=y
+CONFIG_REGULATOR_PCA9450=y
+CONFIG_REGULATOR_PF8X00=y
+CONFIG_REGULATOR_PFUZE100=y
+CONFIG_REGULATOR_PWM=y
+CONFIG_REGULATOR_QCOM_REFGEN=m
+CONFIG_REGULATOR_QCOM_RPMH=y
+CONFIG_REGULATOR_QCOM_SMD_RPM=y
+CONFIG_REGULATOR_QCOM_SPMI=y
+CONFIG_REGULATOR_QCOM_USB_VBUS=m
+CONFIG_REGULATOR_RAA215300=y
+CONFIG_REGULATOR_RK808=y
+CONFIG_REGULATOR_S2MPS11=y
+CONFIG_REGULATOR_TPS65132=m
+CONFIG_REGULATOR_TPS65219=y
+CONFIG_REGULATOR_VCTRL=m
+CONFIG_RC_CORE=m
+CONFIG_RC_DECODERS=y
+CONFIG_RC_DEVICES=y
+CONFIG_IR_GPIO_CIR=m
+CONFIG_IR_MESON=m
+CONFIG_IR_SUNXI=m
+CONFIG_MEDIA_CEC_SUPPORT=y
+CONFIG_CEC_MESON_G12A_AO=m
+CONFIG_MEDIA_SUPPORT=m
+CONFIG_MEDIA_CAMERA_SUPPORT=y
+CONFIG_MEDIA_ANALOG_TV_SUPPORT=y
+CONFIG_MEDIA_DIGITAL_TV_SUPPORT=y
+CONFIG_MEDIA_SDR_SUPPORT=y
+CONFIG_MEDIA_PLATFORM_SUPPORT=y
+CONFIG_MEDIA_USB_SUPPORT=y
+CONFIG_USB_VIDEO_CLASS=m
+CONFIG_V4L_PLATFORM_DRIVERS=y
+CONFIG_SDR_PLATFORM_DRIVERS=y
+CONFIG_V4L_MEM2MEM_DRIVERS=y
+CONFIG_VIDEO_AMPHION_VPU=m
+CONFIG_VIDEO_CADENCE_CSI2RX=m
+CONFIG_VIDEO_MEDIATEK_JPEG=m
+CONFIG_VIDEO_MEDIATEK_VCODEC=m
+CONFIG_VIDEO_WAVE_VPU=m
+CONFIG_VIDEO_E5010_JPEG_ENC=m
+CONFIG_VIDEO_IMX7_CSI=m
+CONFIG_VIDEO_IMX_MIPI_CSIS=m
+CONFIG_VIDEO_IMX8_ISI=m
+CONFIG_VIDEO_IMX8_ISI_M2M=y
+CONFIG_VIDEO_IMX8_JPEG=m
+CONFIG_VIDEO_QCOM_CAMSS=m
+CONFIG_VIDEO_QCOM_VENUS=m
+CONFIG_VIDEO_RCAR_ISP=m
+CONFIG_VIDEO_RCAR_CSI2=m
+CONFIG_VIDEO_RCAR_VIN=m
+CONFIG_VIDEO_RZG2L_CSI2=m
+CONFIG_VIDEO_RZG2L_CRU=m
+CONFIG_VIDEO_RENESAS_FCP=m
+CONFIG_VIDEO_RENESAS_FDP1=m
+CONFIG_VIDEO_RENESAS_VSP1=m
+CONFIG_VIDEO_RCAR_DRIF=m
+CONFIG_VIDEO_SAMSUNG_EXYNOS_GSC=m
+CONFIG_VIDEO_SAMSUNG_S5P_JPEG=m
+CONFIG_VIDEO_SAMSUNG_S5P_MFC=m
+CONFIG_VIDEO_SUN6I_CSI=m
+CONFIG_VIDEO_TI_J721E_CSI2RX=m
+CONFIG_VIDEO_HANTRO=m
+CONFIG_VIDEO_IMX219=m
+CONFIG_VIDEO_IMX412=m
+CONFIG_VIDEO_OV5640=m
+CONFIG_VIDEO_OV5645=m
+CONFIG_DRM=m
+CONFIG_DRM_I2C_NXP_TDA998X=m
+CONFIG_DRM_HDLCD=m
+CONFIG_DRM_MALI_DISPLAY=m
+CONFIG_DRM_KOMEDA=m
+CONFIG_DRM_NOUVEAU=m
+CONFIG_DRM_EXYNOS=m
+CONFIG_DRM_EXYNOS5433_DECON=y
+CONFIG_DRM_EXYNOS7_DECON=y
+CONFIG_DRM_EXYNOS_DSI=y
+CONFIG_DRM_EXYNOS_HDMI=y
+CONFIG_DRM_EXYNOS_MIC=y
+CONFIG_DRM_ROCKCHIP=m
+CONFIG_ROCKCHIP_VOP2=y
+CONFIG_ROCKCHIP_ANALOGIX_DP=y
+CONFIG_ROCKCHIP_CDN_DP=y
+CONFIG_ROCKCHIP_DW_HDMI=y
+CONFIG_ROCKCHIP_DW_MIPI_DSI=y
+CONFIG_ROCKCHIP_INNO_HDMI=y
+CONFIG_ROCKCHIP_LVDS=y
+CONFIG_DRM_RCAR_DU=m
+CONFIG_DRM_RCAR_DW_HDMI=m
+CONFIG_DRM_RCAR_MIPI_DSI=m
+CONFIG_DRM_RZG2L_MIPI_DSI=m
+CONFIG_DRM_RZG2L_DU=m
+CONFIG_DRM_SUN4I=m
+CONFIG_DRM_SUN6I_DSI=m
+CONFIG_DRM_SUN8I_DW_HDMI=m
+CONFIG_DRM_SUN8I_MIXER=m
+CONFIG_DRM_MSM=m
+CONFIG_DRM_TEGRA=m
+CONFIG_DRM_PANEL_BOE_TV101WUM_NL6=m
+CONFIG_DRM_PANEL_LVDS=m
+CONFIG_DRM_PANEL_SIMPLE=m
+CONFIG_DRM_PANEL_EDP=m
+CONFIG_DRM_PANEL_ILITEK_ILI9882T=m
+CONFIG_DRM_PANEL_KHADAS_TS050=m
+CONFIG_DRM_PANEL_MANTIX_MLAF057WE51=m
+CONFIG_DRM_PANEL_NOVATEK_NT36672E=m
+CONFIG_DRM_PANEL_RAYDIUM_RM67191=m
+CONFIG_DRM_PANEL_SAMSUNG_ATNA33XC20=m
+CONFIG_DRM_PANEL_SITRONIX_ST7703=m
+CONFIG_DRM_PANEL_TRULY_NT35597_WQXGA=m
+CONFIG_DRM_PANEL_VISIONOX_VTDR6130=m
+CONFIG_DRM_FSL_LDB=m
+CONFIG_DRM_LONTIUM_LT8912B=m
+CONFIG_DRM_LONTIUM_LT9611=m
+CONFIG_DRM_LONTIUM_LT9611UXC=m
+CONFIG_DRM_ITE_IT66121=m
+CONFIG_DRM_NWL_MIPI_DSI=m
+CONFIG_DRM_PARADE_PS8640=m
+CONFIG_DRM_SAMSUNG_DSIM=m
+CONFIG_DRM_SII902X=m
+CONFIG_DRM_SIMPLE_BRIDGE=m
+CONFIG_DRM_THINE_THC63LVD1024=m
+CONFIG_DRM_TOSHIBA_TC358767=m
+CONFIG_DRM_TOSHIBA_TC358768=m
+CONFIG_DRM_TI_TFP410=m
+CONFIG_DRM_TI_SN65DSI83=m
+CONFIG_DRM_TI_SN65DSI86=m
+CONFIG_DRM_ANALOGIX_ANX7625=m
+CONFIG_DRM_I2C_ADV7511=m
+CONFIG_DRM_I2C_ADV7511_AUDIO=y
+CONFIG_DRM_CDNS_MHDP8546=m
+CONFIG_DRM_IMX8MP_DW_HDMI_BRIDGE=m
+CONFIG_DRM_DW_HDMI_AHB_AUDIO=m
+CONFIG_DRM_DW_HDMI_CEC=m
+CONFIG_DRM_IMX_DCSS=m
+CONFIG_DRM_V3D=m
+CONFIG_DRM_VC4=m
+CONFIG_DRM_ETNAVIV=m
+CONFIG_DRM_HISI_HIBMC=m
+CONFIG_DRM_HISI_KIRIN=m
+CONFIG_DRM_MEDIATEK=m
+CONFIG_DRM_MEDIATEK_DP=m
+CONFIG_DRM_MEDIATEK_HDMI=m
+CONFIG_DRM_MXSFB=m
+CONFIG_DRM_IMX_LCDIF=m
+CONFIG_DRM_MESON=m
+CONFIG_DRM_PL111=m
+CONFIG_DRM_LIMA=m
+CONFIG_DRM_PANFROST=m
+CONFIG_DRM_PANTHOR=m
+CONFIG_DRM_TIDSS=m
+CONFIG_DRM_POWERVR=m
+CONFIG_FB=y
+CONFIG_FB_EFI=y
+CONFIG_FB_MODE_HELPERS=y
+CONFIG_BACKLIGHT_PWM=m
+CONFIG_BACKLIGHT_LP855X=m
+CONFIG_LOGO=y
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_ALOOP=m
+CONFIG_SND_HDA_TEGRA=m
+CONFIG_SND_HDA_CODEC_HDMI=m
+CONFIG_SND_SOC=y
+CONFIG_SND_BCM2835_SOC_I2S=m
+CONFIG_SND_SOC_FSL_ASRC=m
+CONFIG_SND_SOC_FSL_MICFIL=m
+CONFIG_SND_SOC_FSL_EASRC=m
+CONFIG_SND_IMX_SOC=m
+CONFIG_SND_SOC_IMX_SGTL5000=m
+CONFIG_SND_SOC_FSL_ASOC_CARD=m
+CONFIG_SND_SOC_IMX_AUDMIX=m
+CONFIG_SND_SOC_MT8183=m
+CONFIG_SND_SOC_MT8183_MT6358_TS3A227E_MAX98357A=m
+CONFIG_SND_SOC_MT8183_DA7219_MAX98357A=m
+CONFIG_SND_SOC_MT8192=m
+CONFIG_SND_SOC_MT8192_MT6359_RT1015_RT5682=m
+CONFIG_SND_SOC_MT8195=m
+CONFIG_SND_SOC_MT8195_MT6359=m
+CONFIG_SND_SOC_MT8365=m
+CONFIG_SND_SOC_MT8365_MT6357=m
+CONFIG_SND_MESON_AXG_SOUND_CARD=m
+CONFIG_SND_MESON_GX_SOUND_CARD=m
+CONFIG_SND_SOC_QCOM=m
+CONFIG_SND_SOC_APQ8016_SBC=m
+CONFIG_SND_SOC_MSM8996=m
+CONFIG_SND_SOC_SDM845=m
+CONFIG_SND_SOC_SM8250=m
+CONFIG_SND_SOC_SC8280XP=m
+CONFIG_SND_SOC_SC7180=m
+CONFIG_SND_SOC_SC7280=m
+CONFIG_SND_SOC_X1E80100=m
+CONFIG_SND_SOC_ROCKCHIP=m
+CONFIG_SND_SOC_ROCKCHIP_I2S_TDM=m
+CONFIG_SND_SOC_ROCKCHIP_SPDIF=m
+CONFIG_SND_SOC_ROCKCHIP_RT5645=m
+CONFIG_SND_SOC_RK3399_GRU_SOUND=m
+CONFIG_SND_SOC_SAMSUNG=y
+CONFIG_SND_SOC_RCAR=m
+CONFIG_SND_SOC_RZ=m
+CONFIG_SND_SOC_SOF_TOPLEVEL=y
+CONFIG_SND_SOC_SOF_OF=y
+CONFIG_SND_SOC_SOF_MTK_TOPLEVEL=y
+CONFIG_SND_SOC_SOF_MT8195=m
+CONFIG_SND_SUN8I_CODEC=m
+CONFIG_SND_SUN8I_CODEC_ANALOG=m
+CONFIG_SND_SUN50I_CODEC_ANALOG=m
+CONFIG_SND_SUN4I_I2S=m
+CONFIG_SND_SUN4I_SPDIF=m
+CONFIG_SND_SOC_TEGRA=m
+CONFIG_SND_SOC_TEGRA210_AHUB=m
+CONFIG_SND_SOC_TEGRA210_DMIC=m
+CONFIG_SND_SOC_TEGRA210_I2S=m
+CONFIG_SND_SOC_TEGRA210_OPE=m
+CONFIG_SND_SOC_TEGRA186_ASRC=m
+CONFIG_SND_SOC_TEGRA186_DSPK=m
+CONFIG_SND_SOC_TEGRA210_ADMAIF=m
+CONFIG_SND_SOC_TEGRA210_MVC=m
+CONFIG_SND_SOC_TEGRA210_SFC=m
+CONFIG_SND_SOC_TEGRA210_AMX=m
+CONFIG_SND_SOC_TEGRA210_ADX=m
+CONFIG_SND_SOC_TEGRA210_MIXER=m
+CONFIG_SND_SOC_TEGRA_AUDIO_GRAPH_CARD=m
+CONFIG_SND_SOC_DAVINCI_MCASP=m
+CONFIG_SND_SOC_J721E_EVM=m
+CONFIG_SND_SOC_AK4613=m
+CONFIG_SND_SOC_AK4619=m
+CONFIG_SND_SOC_DA7213=m
+CONFIG_SND_SOC_ES7134=m
+CONFIG_SND_SOC_ES7241=m
+CONFIG_SND_SOC_ES8316=m
+CONFIG_SND_SOC_GTM601=m
+CONFIG_SND_SOC_MSM8916_WCD_ANALOG=m
+CONFIG_SND_SOC_MSM8916_WCD_DIGITAL=m
+CONFIG_SND_SOC_PCM3168A_I2C=m
+CONFIG_SND_SOC_RK3308=m
+CONFIG_SND_SOC_RK817=m
+CONFIG_SND_SOC_RT5640=m
+CONFIG_SND_SOC_RT5659=m
+CONFIG_SND_SOC_SIMPLE_AMPLIFIER=m
+CONFIG_SND_SOC_SIMPLE_MUX=m
+CONFIG_SND_SOC_TAS2552=m
+CONFIG_SND_SOC_TAS571X=m
+CONFIG_SND_SOC_TLV320AIC32X4_I2C=m
+CONFIG_SND_SOC_TLV320AIC3X_I2C=m
+CONFIG_SND_SOC_WCD9335=m
+CONFIG_SND_SOC_WCD934X=m
+CONFIG_SND_SOC_WCD939X=m
+CONFIG_SND_SOC_WCD939X_SDW=m
+CONFIG_SND_SOC_WM8524=m
+CONFIG_SND_SOC_WM8904=m
+CONFIG_SND_SOC_WM8960=m
+CONFIG_SND_SOC_WM8962=m
+CONFIG_SND_SOC_WM8978=m
+CONFIG_SND_SOC_WSA881X=m
+CONFIG_SND_SOC_WSA883X=m
+CONFIG_SND_SOC_WSA884X=m
+CONFIG_SND_SOC_NAU8822=m
+CONFIG_SND_SOC_LPASS_WSA_MACRO=m
+CONFIG_SND_SOC_LPASS_VA_MACRO=m
+CONFIG_SND_SOC_LPASS_RX_MACRO=m
+CONFIG_SND_SOC_LPASS_TX_MACRO=m
+CONFIG_SND_SIMPLE_CARD=m
+CONFIG_SND_AUDIO_GRAPH_CARD=m
+CONFIG_SND_AUDIO_GRAPH_CARD2=m
+CONFIG_HID_MULTITOUCH=m
+CONFIG_I2C_HID_ACPI=m
+CONFIG_I2C_HID_OF=m
+CONFIG_I2C_HID_OF_ELAN=m
+CONFIG_USB=y
+CONFIG_USB_OTG=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_XHCI_PCI_RENESAS=m
+CONFIG_USB_XHCI_RZV2M=y
+CONFIG_USB_XHCI_TEGRA=y
+CONFIG_USB_BRCMSTB=m
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_EXYNOS=y
+CONFIG_USB_EHCI_HCD_PLATFORM=y
+CONFIG_USB_OHCI_HCD=y
+CONFIG_USB_OHCI_EXYNOS=y
+CONFIG_USB_OHCI_HCD_PLATFORM=y
+CONFIG_USB_RENESAS_USBHS_HCD=m
+CONFIG_USB_RENESAS_USBHS=m
+CONFIG_USB_ACM=m
+CONFIG_USB_STORAGE=y
+CONFIG_USB_CDNS_SUPPORT=m
+CONFIG_USB_CDNS3=m
+CONFIG_USB_CDNS3_GADGET=y
+CONFIG_USB_CDNS3_HOST=y
+CONFIG_USB_CDNS3_IMX=m
+CONFIG_USB_MTU3=y
+CONFIG_USB_MUSB_HDRC=y
+CONFIG_USB_MUSB_SUNXI=y
+CONFIG_USB_DWC3=y
+CONFIG_OMAP_USB2=m
+CONFIG_USB_DWC2=y
+CONFIG_USB_CHIPIDEA=y
+CONFIG_USB_CHIPIDEA_UDC=y
+CONFIG_USB_CHIPIDEA_HOST=y
+CONFIG_USB_ISP1760=y
+CONFIG_USB_SERIAL=m
+CONFIG_USB_SERIAL_CP210X=m
+CONFIG_USB_SERIAL_FTDI_SIO=m
+CONFIG_USB_SERIAL_OPTION=m
+CONFIG_USB_QCOM_EUD=m
+CONFIG_USB_HSIC_USB3503=y
+CONFIG_USB_ONBOARD_DEV=m
+CONFIG_NOP_USB_XCEIV=y
+CONFIG_USB_MXS_PHY=m
+CONFIG_USB_GADGET=y
+CONFIG_USB_RENESAS_USBHS_UDC=m
+CONFIG_USB_RZV2M_USB3DRD=y
+CONFIG_USB_RENESAS_USB3=m
+CONFIG_USB_TEGRA_XUDC=m
+CONFIG_USB_CONFIGFS=m
+CONFIG_USB_CONFIGFS_SERIAL=y
+CONFIG_USB_CONFIGFS_ACM=y
+CONFIG_USB_CONFIGFS_OBEX=y
+CONFIG_USB_CONFIGFS_NCM=y
+CONFIG_USB_CONFIGFS_ECM=y
+CONFIG_USB_CONFIGFS_ECM_SUBSET=y
+CONFIG_USB_CONFIGFS_RNDIS=y
+CONFIG_USB_CONFIGFS_EEM=y
+CONFIG_USB_CONFIGFS_MASS_STORAGE=y
+CONFIG_USB_MASS_STORAGE=m
+CONFIG_USB_G_SERIAL=m
+CONFIG_TYPEC=y
+CONFIG_TYPEC_TCPM=y
+CONFIG_TYPEC_TCPCI=m
+CONFIG_TYPEC_FUSB302=y
+CONFIG_TYPEC_QCOM_PMIC=m
+CONFIG_TYPEC_UCSI=m
+CONFIG_UCSI_CCG=m
+CONFIG_UCSI_PMIC_GLINK=m
+CONFIG_TYPEC_TPS6598X=m
+CONFIG_TYPEC_HD3SS3220=m
+CONFIG_TYPEC_MUX_FSA4480=m
+CONFIG_TYPEC_MUX_GPIO_SBU=m
+CONFIG_TYPEC_MUX_NB7VPQ904M=m
+CONFIG_TYPEC_MUX_WCD939X_USBSS=m
+CONFIG_TYPEC_DP_ALTMODE=m
+CONFIG_MMC=y
+CONFIG_MMC_BLOCK_MINORS=32
+CONFIG_MMC_ARMMMCI=y
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_ACPI=y
+CONFIG_MMC_SDHCI_PLTFM=y
+CONFIG_MMC_SDHCI_OF_ARASAN=y
+CONFIG_MMC_SDHCI_OF_ESDHC=y
+CONFIG_MMC_SDHCI_OF_DWCMSHC=y
+CONFIG_MMC_SDHCI_OF_SPARX5=y
+CONFIG_MMC_SDHCI_CADENCE=y
+CONFIG_MMC_SDHCI_ESDHC_IMX=y
+CONFIG_MMC_SDHCI_TEGRA=y
+CONFIG_MMC_SDHCI_F_SDH30=y
+CONFIG_MMC_MESON_GX=y
+CONFIG_MMC_SDHCI_MSM=y
+CONFIG_MMC_SPI=y
+CONFIG_MMC_SDHI=y
+CONFIG_MMC_UNIPHIER=y
+CONFIG_MMC_DW=y
+CONFIG_MMC_DW_EXYNOS=y
+CONFIG_MMC_DW_HI3798CV200=y
+CONFIG_MMC_DW_K3=y
+CONFIG_MMC_DW_ROCKCHIP=y
+CONFIG_MMC_SUNXI=y
+CONFIG_MMC_BCM2835=y
+CONFIG_MMC_MTK=y
+CONFIG_MMC_SDHCI_XENON=y
+CONFIG_MMC_SDHCI_AM654=y
+CONFIG_MMC_OWL=y
+CONFIG_SCSI_UFSHCD=y
+CONFIG_SCSI_UFS_BSG=y
+CONFIG_SCSI_UFSHCD_PLATFORM=y
+CONFIG_SCSI_UFS_CDNS_PLATFORM=m
+CONFIG_SCSI_UFS_QCOM=m
+CONFIG_SCSI_UFS_HISI=y
+CONFIG_SCSI_UFS_RENESAS=m
+CONFIG_SCSI_UFS_TI_J721E=m
+CONFIG_SCSI_UFS_EXYNOS=y
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+CONFIG_LEDS_CLASS_MULTICOLOR=m
+CONFIG_LEDS_LM3692X=m
+CONFIG_LEDS_PCA9532=m
+CONFIG_LEDS_GPIO=y
+CONFIG_LEDS_PWM=y
+CONFIG_LEDS_SYSCON=y
+CONFIG_LEDS_QCOM_LPG=m
+CONFIG_LEDS_TRIGGER_TIMER=y
+CONFIG_LEDS_TRIGGER_DISK=y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+CONFIG_LEDS_TRIGGER_CPU=y
+CONFIG_LEDS_TRIGGER_DEFAULT_ON=y
+CONFIG_LEDS_TRIGGER_PANIC=y
+CONFIG_EDAC=y
+CONFIG_EDAC_GHES=y
+CONFIG_EDAC_LAYERSCAPE=m
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_DS1307=m
+CONFIG_RTC_DRV_HYM8563=m
+CONFIG_RTC_DRV_MAX77686=y
+CONFIG_RTC_DRV_RK808=m
+CONFIG_RTC_DRV_ISL1208=m
+CONFIG_RTC_DRV_PCF85063=m
+CONFIG_RTC_DRV_PCF85363=m
+CONFIG_RTC_DRV_PCF8563=m
+CONFIG_RTC_DRV_M41T80=m
+CONFIG_RTC_DRV_BQ32K=m
+CONFIG_RTC_DRV_RX8581=m
+CONFIG_RTC_DRV_RV3028=m
+CONFIG_RTC_DRV_RV8803=m
+CONFIG_RTC_DRV_S5M=y
+CONFIG_RTC_DRV_DS3232=y
+CONFIG_RTC_DRV_PCF2127=m
+CONFIG_RTC_DRV_EFI=y
+CONFIG_RTC_DRV_CROS_EC=y
+CONFIG_RTC_DRV_FSL_FTM_ALARM=m
+CONFIG_RTC_DRV_S3C=y
+CONFIG_RTC_DRV_PL031=y
+CONFIG_RTC_DRV_SUN6I=y
+CONFIG_RTC_DRV_ARMADA38X=y
+CONFIG_RTC_DRV_PM8XXX=m
+CONFIG_RTC_DRV_TEGRA=y
+CONFIG_RTC_DRV_SNVS=m
+CONFIG_RTC_DRV_BBNSM=m
+CONFIG_RTC_DRV_IMX_SC=m
+CONFIG_RTC_DRV_MT6397=m
+CONFIG_RTC_DRV_XGENE=y
+CONFIG_RTC_DRV_TI_K3=m
+CONFIG_DMADEVICES=y
+CONFIG_DMA_BCM2835=y
+CONFIG_DMA_SUN6I=m
+CONFIG_FSL_EDMA=y
+CONFIG_IMX_SDMA=m
+CONFIG_K3_DMA=y
+CONFIG_MV_XOR=y
+CONFIG_MV_XOR_V2=y
+CONFIG_OWL_DMA=y
+CONFIG_PL330_DMA=y
+CONFIG_TEGRA186_GPC_DMA=y
+CONFIG_TEGRA20_APB_DMA=y
+CONFIG_TEGRA210_ADMA=m
+CONFIG_QCOM_BAM_DMA=y
+CONFIG_QCOM_GPI_DMA=m
+CONFIG_QCOM_HIDMA_MGMT=y
+CONFIG_QCOM_HIDMA=y
+CONFIG_DW_EDMA=m
+CONFIG_RCAR_DMAC=y
+CONFIG_RENESAS_USB_DMAC=m
+CONFIG_RZ_DMAC=y
+CONFIG_TI_K3_UDMA=y
+CONFIG_TI_K3_UDMA_GLUE_LAYER=y
+CONFIG_UIO=m
+CONFIG_UIO_PDRV_GENIRQ=m
+CONFIG_VFIO=m
+CONFIG_VFIO_PCI=m
+CONFIG_VIRTIO_PCI=y
+CONFIG_VIRTIO_BALLOON=y
+CONFIG_VIRTIO_MMIO=y
+CONFIG_XEN_GNTDEV=y
+CONFIG_XEN_GRANT_DEV_ALLOC=y
+CONFIG_STAGING=y
+CONFIG_STAGING_MEDIA=y
+CONFIG_VIDEO_MAX96712=m
+CONFIG_VIDEO_MESON_VDEC=m
+CONFIG_SND_BCM2835=m
+CONFIG_CHROME_PLATFORMS=y
+CONFIG_CROS_EC=y
+CONFIG_CROS_EC_I2C=y
+CONFIG_CROS_EC_RPMSG=m
+CONFIG_CROS_EC_SPI=y
+CONFIG_CROS_KBD_LED_BACKLIGHT=m
+CONFIG_CROS_EC_CHARDEV=m
+CONFIG_COMMON_CLK_RK808=y
+CONFIG_COMMON_CLK_SCMI=y
+CONFIG_COMMON_CLK_SCPI=y
+CONFIG_COMMON_CLK_CS2000_CP=y
+CONFIG_COMMON_CLK_FSL_SAI=y
+CONFIG_COMMON_CLK_S2MPS11=y
+CONFIG_COMMON_CLK_PWM=y
+CONFIG_COMMON_CLK_RS9_PCIE=y
+CONFIG_COMMON_CLK_VC3=y
+CONFIG_COMMON_CLK_VC5=y
+CONFIG_COMMON_CLK_BD718XX=m
+CONFIG_CLK_RASPBERRYPI=m
+CONFIG_CLK_IMX8MM=y
+CONFIG_CLK_IMX8MN=y
+CONFIG_CLK_IMX8MP=y
+CONFIG_CLK_IMX8MQ=y
+CONFIG_CLK_IMX8QXP=y
+CONFIG_CLK_IMX8ULP=y
+CONFIG_CLK_IMX93=y
+CONFIG_TI_SCI_CLK=y
+CONFIG_COMMON_CLK_MT8192_AUDSYS=y
+CONFIG_COMMON_CLK_MT8192_CAMSYS=y
+CONFIG_COMMON_CLK_MT8192_IMGSYS=y
+CONFIG_COMMON_CLK_MT8192_IMP_IIC_WRAP=y
+CONFIG_COMMON_CLK_MT8192_IPESYS=y
+CONFIG_COMMON_CLK_MT8192_MDPSYS=y
+CONFIG_COMMON_CLK_MT8192_MFGCFG=y
+CONFIG_COMMON_CLK_MT8192_MMSYS=y
+CONFIG_COMMON_CLK_MT8192_MSDC=y
+CONFIG_COMMON_CLK_MT8192_SCP_ADSP=y
+CONFIG_COMMON_CLK_MT8192_VDECSYS=y
+CONFIG_COMMON_CLK_MT8192_VENCSYS=y
+CONFIG_COMMON_CLK_QCOM=y
+CONFIG_CLK_X1E80100_CAMCC=m
+CONFIG_CLK_X1E80100_DISPCC=m
+CONFIG_CLK_X1E80100_GCC=y
+CONFIG_CLK_X1E80100_GPUCC=m
+CONFIG_CLK_X1E80100_TCSRCC=y
+CONFIG_QCOM_A53PLL=y
+CONFIG_QCOM_CLK_APCS_MSM8916=y
+CONFIG_QCOM_CLK_APCC_MSM8996=y
+CONFIG_QCOM_CLK_SMD_RPM=y
+CONFIG_QCOM_CLK_RPMH=y
+CONFIG_IPQ_APSS_6018=y
+CONFIG_IPQ_APSS_5018=y
+CONFIG_IPQ_GCC_5018=y
+CONFIG_IPQ_GCC_5332=y
+CONFIG_IPQ_GCC_6018=y
+CONFIG_IPQ_GCC_8074=y
+CONFIG_IPQ_GCC_9574=y
+CONFIG_MSM_GCC_8916=y
+CONFIG_MSM_MMCC_8994=m
+CONFIG_MSM_GCC_8994=y
+CONFIG_MSM_GCC_8996=y
+CONFIG_MSM_MMCC_8996=m
+CONFIG_MSM_GCC_8998=y
+CONFIG_MSM_MMCC_8998=m
+CONFIG_QCM_GCC_2290=y
+CONFIG_QCM_DISPCC_2290=m
+CONFIG_QCS_GCC_404=y
+CONFIG_QDU_GCC_1000=y
+CONFIG_SC_CAMCC_8280XP=m
+CONFIG_SC_DISPCC_7280=m
+CONFIG_SC_DISPCC_8280XP=m
+CONFIG_SA_GCC_8775P=y
+CONFIG_SA_GPUCC_8775P=m
+CONFIG_SC_GCC_7180=y
+CONFIG_SC_GCC_7280=y
+CONFIG_SC_GCC_8180X=y
+CONFIG_SC_GCC_8280XP=y
+CONFIG_SC_GPUCC_7280=m
+CONFIG_SC_GPUCC_8280XP=m
+CONFIG_SC_LPASSCC_8280XP=m
+CONFIG_SDM_CAMCC_845=m
+CONFIG_SDM_GPUCC_845=y
+CONFIG_SDM_VIDEOCC_845=y
+CONFIG_SDM_DISPCC_845=y
+CONFIG_SDM_LPASSCC_845=m
+CONFIG_SDX_GCC_75=y
+CONFIG_SM_CAMCC_8250=m
+CONFIG_SM_DISPCC_6115=m
+CONFIG_SM_DISPCC_8250=y
+CONFIG_SM_DISPCC_8450=m
+CONFIG_SM_DISPCC_8550=m
+CONFIG_SM_DISPCC_8650=m
+CONFIG_SM_GCC_4450=y
+CONFIG_SM_GCC_6115=y
+CONFIG_SM_GCC_8350=y
+CONFIG_SM_GCC_8450=y
+CONFIG_SM_GCC_8550=y
+CONFIG_SM_GCC_8650=y
+CONFIG_SM_GPUCC_6115=m
+CONFIG_SM_GPUCC_8150=y
+CONFIG_SM_GPUCC_8250=y
+CONFIG_SM_GPUCC_8350=m
+CONFIG_SM_GPUCC_8450=m
+CONFIG_SM_GPUCC_8550=m
+CONFIG_SM_GPUCC_8650=m
+CONFIG_SM_TCSRCC_8550=y
+CONFIG_SM_TCSRCC_8650=y
+CONFIG_SM_VIDEOCC_8250=y
+CONFIG_QCOM_HFPLL=y
+CONFIG_CLK_GFM_LPASS_SM8250=m
+CONFIG_CLK_RCAR_USB2_CLOCK_SEL=y
+CONFIG_HWSPINLOCK=y
+CONFIG_HWSPINLOCK_QCOM=y
+CONFIG_TEGRA186_TIMER=y
+CONFIG_RENESAS_OSTM=y
+CONFIG_ARM_MHU=y
+CONFIG_IMX_MBOX=y
+CONFIG_OMAP2PLUS_MBOX=m
+CONFIG_PLATFORM_MHU=y
+CONFIG_BCM2835_MBOX=y
+CONFIG_QCOM_APCS_IPC=y
+CONFIG_MTK_ADSP_MBOX=m
+CONFIG_QCOM_IPCC=y
+CONFIG_ROCKCHIP_IOMMU=y
+CONFIG_TEGRA_IOMMU_SMMU=y
+CONFIG_ARM_SMMU=y
+CONFIG_ARM_SMMU_V3=y
+CONFIG_MTK_IOMMU=y
+CONFIG_QCOM_IOMMU=y
+CONFIG_REMOTEPROC=y
+CONFIG_IMX_REMOTEPROC=y
+CONFIG_MTK_SCP=m
+CONFIG_QCOM_Q6V5_ADSP=m
+CONFIG_QCOM_Q6V5_MSS=m
+CONFIG_QCOM_Q6V5_PAS=m
+CONFIG_QCOM_SYSMON=m
+CONFIG_QCOM_WCNSS_PIL=m
+CONFIG_TI_K3_DSP_REMOTEPROC=m
+CONFIG_TI_K3_R5_REMOTEPROC=m
+CONFIG_RPMSG_CHAR=m
+CONFIG_RPMSG_CTRL=m
+CONFIG_RPMSG_QCOM_GLINK_RPM=y
+CONFIG_RPMSG_QCOM_GLINK_SMEM=m
+CONFIG_RPMSG_QCOM_SMD=y
+CONFIG_RPMSG_VIRTIO=y
+CONFIG_SOUNDWIRE=m
+CONFIG_SOUNDWIRE_QCOM=m
+CONFIG_FSL_DPAA=y
+CONFIG_FSL_MC_DPIO=y
+CONFIG_FSL_RCPM=y
+CONFIG_MTK_CMDQ=m
+CONFIG_MTK_DEVAPC=m
+CONFIG_MTK_PMIC_WRAP=y
+CONFIG_MTK_SVS=m
+CONFIG_QCOM_AOSS_QMP=y
+CONFIG_QCOM_COMMAND_DB=y
+CONFIG_QCOM_GENI_SE=y
+CONFIG_QCOM_LLCC=m
+CONFIG_QCOM_OCMEM=m
+CONFIG_QCOM_PMIC_GLINK=m
+CONFIG_QCOM_RMTFS_MEM=m
+CONFIG_QCOM_RPMH=y
+CONFIG_QCOM_SMEM=y
+CONFIG_QCOM_SMD_RPM=y
+CONFIG_QCOM_SMP2P=y
+CONFIG_QCOM_SMSM=y
+CONFIG_QCOM_SOCINFO=m
+CONFIG_QCOM_SPM=m
+CONFIG_QCOM_STATS=m
+CONFIG_QCOM_WCNSS_CTRL=m
+CONFIG_QCOM_APR=m
+CONFIG_QCOM_ICC_BWMON=m
+CONFIG_QCOM_PBS=m
+CONFIG_ARCH_R8A77995=y
+CONFIG_ARCH_R8A77990=y
+CONFIG_ARCH_R8A77951=y
+CONFIG_ARCH_R8A77965=y
+CONFIG_ARCH_R8A77960=y
+CONFIG_ARCH_R8A77961=y
+CONFIG_ARCH_R8A779F0=y
+CONFIG_ARCH_R8A77980=y
+CONFIG_ARCH_R8A77970=y
+CONFIG_ARCH_R8A779A0=y
+CONFIG_ARCH_R8A779G0=y
+CONFIG_ARCH_R8A779H0=y
+CONFIG_ARCH_R8A774C0=y
+CONFIG_ARCH_R8A774E1=y
+CONFIG_ARCH_R8A774A1=y
+CONFIG_ARCH_R8A774B1=y
+CONFIG_ARCH_R9A07G043=y
+CONFIG_ARCH_R9A07G044=y
+CONFIG_ARCH_R9A07G054=y
+CONFIG_ARCH_R9A08G045=y
+CONFIG_ARCH_R9A09G011=y
+CONFIG_ARCH_R9A09G057=y
+CONFIG_ROCKCHIP_IODOMAIN=y
+CONFIG_ARCH_TEGRA_132_SOC=y
+CONFIG_ARCH_TEGRA_210_SOC=y
+CONFIG_ARCH_TEGRA_186_SOC=y
+CONFIG_ARCH_TEGRA_194_SOC=y
+CONFIG_ARCH_TEGRA_234_SOC=y
+CONFIG_TI_PRUSS=m
+CONFIG_OWL_PM_DOMAINS=y
+CONFIG_RASPBERRYPI_POWER=y
+CONFIG_IMX_SCU_PD=y
+CONFIG_QCOM_CPR=y
+CONFIG_QCOM_RPMHPD=y
+CONFIG_QCOM_RPMPD=y
+CONFIG_ROCKCHIP_PM_DOMAINS=y
+CONFIG_TI_SCI_PM_DOMAINS=y
+CONFIG_ARM_IMX_BUS_DEVFREQ=y
+CONFIG_ARM_IMX8M_DDRC_DEVFREQ=m
+CONFIG_ARM_MEDIATEK_CCI_DEVFREQ=m
+CONFIG_EXTCON_PTN5150=m
+CONFIG_EXTCON_USB_GPIO=y
+CONFIG_EXTCON_USBC_CROS_EC=y
+CONFIG_RENESAS_RPCIF=m
+CONFIG_IIO=y
+CONFIG_EXYNOS_ADC=y
+CONFIG_IMX8QXP_ADC=m
+CONFIG_IMX93_ADC=m
+CONFIG_MAX9611=m
+CONFIG_MEDIATEK_MT6577_AUXADC=m
+CONFIG_QCOM_SPMI_VADC=m
+CONFIG_QCOM_SPMI_ADC5=m
+CONFIG_ROCKCHIP_SARADC=m
+CONFIG_RZG2L_ADC=m
+CONFIG_TI_ADS1015=m
+CONFIG_TI_AM335X_ADC=m
+CONFIG_IIO_CROS_EC_SENSORS_CORE=m
+CONFIG_IIO_CROS_EC_SENSORS=m
+CONFIG_IIO_ST_LSM6DSX=m
+CONFIG_IIO_CROS_EC_LIGHT_PROX=m
+CONFIG_SENSORS_ISL29018=m
+CONFIG_VCNL4000=m
+CONFIG_IIO_ST_MAGN_3AXIS=m
+CONFIG_IIO_CROS_EC_BARO=m
+CONFIG_MPL3115=m
+CONFIG_PWM=y
+CONFIG_PWM_ADP5585=m
+CONFIG_PWM_BCM2835=m
+CONFIG_PWM_BRCMSTB=m
+CONFIG_PWM_CROS_EC=m
+CONFIG_PWM_IMX27=m
+CONFIG_PWM_MESON=m
+CONFIG_PWM_MTK_DISP=m
+CONFIG_PWM_MEDIATEK=m
+CONFIG_PWM_RCAR=m
+CONFIG_PWM_RENESAS_TPU=m
+CONFIG_PWM_ROCKCHIP=y
+CONFIG_PWM_RZ_MTU3=m
+CONFIG_PWM_SAMSUNG=y
+CONFIG_PWM_SL28CPLD=m
+CONFIG_PWM_SUN4I=m
+CONFIG_PWM_TEGRA=m
+CONFIG_PWM_TIECAP=m
+CONFIG_PWM_TIEHRPWM=m
+CONFIG_PWM_VISCONTI=m
+CONFIG_SL28CPLD_INTC=y
+CONFIG_QCOM_PDC=y
+CONFIG_QCOM_MPM=y
+CONFIG_RESET_GPIO=m
+CONFIG_RESET_IMX7=y
+CONFIG_RESET_QCOM_AOSS=y
+CONFIG_RESET_QCOM_PDC=m
+CONFIG_RESET_RZG2L_USBPHY_CTRL=y
+CONFIG_RESET_TI_SCI=y
+CONFIG_PHY_XGENE=y
+CONFIG_PHY_CAN_TRANSCEIVER=m
+CONFIG_PHY_SUN4I_USB=y
+CONFIG_PHY_CADENCE_TORRENT=m
+CONFIG_PHY_CADENCE_DPHY_RX=m
+CONFIG_PHY_CADENCE_SIERRA=m
+CONFIG_PHY_CADENCE_SALVO=m
+CONFIG_PHY_MIXEL_MIPI_DPHY=m
+CONFIG_PHY_FSL_IMX8M_PCIE=y
+CONFIG_PHY_HI6220_USB=y
+CONFIG_PHY_HISTB_COMBPHY=y
+CONFIG_PHY_HISI_INNO_USB2=y
+CONFIG_PHY_MVEBU_CP110_COMPHY=y
+CONFIG_PHY_MTK_TPHY=y
+CONFIG_PHY_QCOM_EDP=m
+CONFIG_PHY_QCOM_PCIE2=m
+CONFIG_PHY_QCOM_QMP=m
+CONFIG_PHY_QCOM_QUSB2=m
+CONFIG_PHY_QCOM_SNPS_EUSB2=m
+CONFIG_PHY_QCOM_EUSB2_REPEATER=m
+CONFIG_PHY_QCOM_M31_USB=m
+CONFIG_PHY_QCOM_USB_HS=m
+CONFIG_PHY_QCOM_USB_SNPS_FEMTO_V2=m
+CONFIG_PHY_QCOM_USB_HS_28NM=m
+CONFIG_PHY_QCOM_USB_SS=m
+CONFIG_PHY_QCOM_SGMII_ETH=m
+CONFIG_PHY_R8A779F0_ETHERNET_SERDES=y
+CONFIG_PHY_RCAR_GEN3_PCIE=y
+CONFIG_PHY_RCAR_GEN3_USB2=y
+CONFIG_PHY_RCAR_GEN3_USB3=m
+CONFIG_PHY_ROCKCHIP_EMMC=y
+CONFIG_PHY_ROCKCHIP_INNO_HDMI=m
+CONFIG_PHY_ROCKCHIP_INNO_USB2=y
+CONFIG_PHY_ROCKCHIP_INNO_DSIDPHY=m
+CONFIG_PHY_ROCKCHIP_NANENG_COMBO_PHY=m
+CONFIG_PHY_ROCKCHIP_PCIE=m
+CONFIG_PHY_ROCKCHIP_SAMSUNG_HDPTX=m
+CONFIG_PHY_ROCKCHIP_SNPS_PCIE3=y
+CONFIG_PHY_ROCKCHIP_TYPEC=y
+CONFIG_PHY_ROCKCHIP_USBDP=m
+CONFIG_PHY_SAMSUNG_UFS=y
+CONFIG_PHY_UNIPHIER_USB2=y
+CONFIG_PHY_UNIPHIER_USB3=y
+CONFIG_PHY_TEGRA_XUSB=y
+CONFIG_PHY_AM654_SERDES=m
+CONFIG_PHY_J721E_WIZ=m
+CONFIG_ARM_CCI_PMU=m
+CONFIG_ARM_CCN=m
+CONFIG_ARM_CMN=m
+CONFIG_ARM_SMMU_V3_PMU=m
+CONFIG_ARM_DSU_PMU=m
+CONFIG_FSL_IMX8_DDR_PMU=m
+CONFIG_QCOM_L2_PMU=y
+CONFIG_QCOM_L3_PMU=y
+CONFIG_ARM_SPE_PMU=m
+CONFIG_ARM_DMC620_PMU=m
+CONFIG_HISI_PMU=y
+CONFIG_ARM_CORESIGHT_PMU_ARCH_SYSTEM_PMU=m
+CONFIG_NVIDIA_CORESIGHT_PMU_ARCH_SYSTEM_PMU=m
+CONFIG_MESON_DDR_PMU=m
+CONFIG_NVMEM_LAYOUT_SL28_VPD=m
+CONFIG_NVMEM_IMX_OCOTP=y
+CONFIG_NVMEM_IMX_OCOTP_ELE=m
+CONFIG_NVMEM_IMX_OCOTP_SCU=y
+CONFIG_NVMEM_LAYERSCAPE_SFP=m
+CONFIG_NVMEM_MESON_EFUSE=m
+CONFIG_NVMEM_MTK_EFUSE=y
+CONFIG_NVMEM_QCOM_QFPROM=y
+CONFIG_NVMEM_QCOM_SEC_QFPROM=m
+CONFIG_NVMEM_RMEM=m
+CONFIG_NVMEM_ROCKCHIP_EFUSE=y
+CONFIG_NVMEM_ROCKCHIP_OTP=y
+CONFIG_NVMEM_SNVS_LPGPR=y
+CONFIG_NVMEM_SPMI_SDAM=m
+CONFIG_NVMEM_SUNXI_SID=y
+CONFIG_NVMEM_UNIPHIER_EFUSE=y
+CONFIG_FPGA=y
+CONFIG_FPGA_MGR_ALTERA_CVP=m
+CONFIG_FPGA_MGR_STRATIX10_SOC=y
+CONFIG_FPGA_BRIDGE=y
+CONFIG_SOCFPGA_FPGA_BRIDGE=y
+#CONFIG_EDAC_DEBUG=y
+#CONFIG_EDAC_ALTERA=y
+#CONFIG_EDAC_ALTERA_IO96B=y
+CONFIG_ALTERA_FREEZE_BRIDGE=m
+CONFIG_OF_RESOLVE=y 
+CONFIG_FPGA_REGION=y
+CONFIG_OF_FPGA_REGION=y
+CONFIG_TEE=y
+CONFIG_OPTEE=y
+CONFIG_MUX_GPIO=m
+CONFIG_MUX_MMIO=y
+CONFIG_SLIMBUS=m
+CONFIG_SLIM_QCOM_CTRL=m
+CONFIG_SLIM_QCOM_NGD_CTRL=m
+CONFIG_INTERCONNECT=y
+CONFIG_INTERCONNECT_IMX=y
+CONFIG_INTERCONNECT_IMX8MM=m
+CONFIG_INTERCONNECT_IMX8MN=m
+CONFIG_INTERCONNECT_IMX8MQ=m
+CONFIG_INTERCONNECT_IMX8MP=y
+CONFIG_INTERCONNECT_QCOM=y
+CONFIG_INTERCONNECT_QCOM_MSM8916=m
+CONFIG_INTERCONNECT_QCOM_MSM8996=y
+CONFIG_INTERCONNECT_QCOM_OSM_L3=m
+CONFIG_INTERCONNECT_QCOM_QCM2290=y
+CONFIG_INTERCONNECT_QCOM_QCS404=m
+CONFIG_INTERCONNECT_QCOM_QDU1000=y
+CONFIG_INTERCONNECT_QCOM_SA8775P=y
+CONFIG_INTERCONNECT_QCOM_SC7180=y
+CONFIG_INTERCONNECT_QCOM_SC7280=y
+CONFIG_INTERCONNECT_QCOM_SC8180X=y
+CONFIG_INTERCONNECT_QCOM_SC8280XP=y
+CONFIG_INTERCONNECT_QCOM_SDM845=y
+CONFIG_INTERCONNECT_QCOM_SDX75=y
+CONFIG_INTERCONNECT_QCOM_SM6115=y
+CONFIG_INTERCONNECT_QCOM_SM8150=y
+CONFIG_INTERCONNECT_QCOM_SM8250=y
+CONFIG_INTERCONNECT_QCOM_SM8350=y
+CONFIG_INTERCONNECT_QCOM_SM8450=y
+CONFIG_INTERCONNECT_QCOM_SM8550=y
+CONFIG_INTERCONNECT_QCOM_SM8650=y
+CONFIG_INTERCONNECT_QCOM_X1E80100=y
+CONFIG_COUNTER=m
+CONFIG_RZ_MTU3_CNT=m
+CONFIG_HTE=y
+CONFIG_HTE_TEGRA194=y
+CONFIG_HTE_TEGRA194_TEST=m
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+CONFIG_BTRFS_FS=m
+CONFIG_BTRFS_FS_POSIX_ACL=y
+CONFIG_FANOTIFY=y
+CONFIG_FANOTIFY_ACCESS_PERMISSIONS=y
+CONFIG_QUOTA=y
+CONFIG_AUTOFS_FS=y
+CONFIG_FUSE_FS=m
+CONFIG_CUSE=m
+CONFIG_OVERLAY_FS=y
+CONFIG_OF_OVERLAY=y
+CONFIG_OF_CONFIGFS=y
+CONFIG_VFAT_FS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_HUGETLBFS=y
+CONFIG_CONFIGFS_FS=y
+CONFIG_EFIVAR_FS=y
+CONFIG_UBIFS_FS=y
+CONFIG_MTD_SPI_NOR_USE_4K_SECTORS=n
+CONFIG_SQUASHFS=y
+CONFIG_PSTORE_RAM=m
+CONFIG_NFS_FS=y
+CONFIG_NFS_V4=y
+CONFIG_NFS_V4_1=y
+CONFIG_NFS_V4_2=y
+CONFIG_ROOT_NFS=y
+CONFIG_NFSD=y
+CONFIG_9P_FS=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_SECURITY=y
+CONFIG_CRYPTO_USER=y
+CONFIG_CRYPTO_TEST=m
+CONFIG_CRYPTO_ECHAINIV=y
+CONFIG_CRYPTO_MICHAEL_MIC=m
+CONFIG_CRYPTO_ANSI_CPRNG=y
+CONFIG_CRYPTO_USER_API_RNG=m
+CONFIG_CRYPTO_CHACHA20_NEON=m
+CONFIG_CRYPTO_GHASH_ARM64_CE=y
+CONFIG_CRYPTO_SHA1_ARM64_CE=y
+CONFIG_CRYPTO_SHA2_ARM64_CE=y
+CONFIG_CRYPTO_SHA512_ARM64_CE=m
+CONFIG_CRYPTO_SHA3_ARM64=m
+CONFIG_CRYPTO_SM3_ARM64_CE=m
+CONFIG_CRYPTO_AES_ARM64_CE_BLK=y
+CONFIG_CRYPTO_AES_ARM64_BS=m
+CONFIG_CRYPTO_AES_ARM64_CE_CCM=y
+CONFIG_CRYPTO_CRCT10DIF_ARM64_CE=m
+CONFIG_CRYPTO_DEV_SUN8I_CE=m
+CONFIG_CRYPTO_DEV_FSL_CAAM=m
+CONFIG_CRYPTO_DEV_FSL_DPAA2_CAAM=m
+CONFIG_CRYPTO_DEV_QCE=m
+CONFIG_CRYPTO_DEV_QCOM_RNG=m
+CONFIG_CRYPTO_DEV_TEGRA=m
+CONFIG_CRYPTO_DEV_CCREE=m
+CONFIG_CRYPTO_DEV_HISI_SEC2=m
+CONFIG_CRYPTO_DEV_HISI_ZIP=m
+CONFIG_CRYPTO_DEV_HISI_HPRE=m
+CONFIG_CRYPTO_DEV_HISI_TRNG=m
+CONFIG_CRYPTO_DEV_SA2UL=m
+CONFIG_DMA_RESTRICTED_POOL=y
+CONFIG_CMA_SIZE_MBYTES=32
+CONFIG_PRINTK_TIME=y
+CONFIG_DEBUG_KERNEL=y
+CONFIG_DEBUG_INFO_DWARF_TOOLCHAIN_DEFAULT=y
+CONFIG_DEBUG_INFO_REDUCED=y
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_DEBUG_FS=y
+CONFIG_CORESIGHT=m
+CONFIG_CORESIGHT_LINK_AND_SINK_TMC=m
+CONFIG_CORESIGHT_CATU=m
+CONFIG_CORESIGHT_SINK_TPIU=m
+CONFIG_CORESIGHT_SINK_ETBV10=m
+CONFIG_CORESIGHT_STM=m
+CONFIG_CORESIGHT_CPU_DEBUG=m
+CONFIG_CORESIGHT_CTI=m
+CONFIG_MEMTEST=y
+CONFIG_CRYPTO_USER_API_HASH=m
+CONFIG_CRYPTO_USER_API_SKCIPHER=m
+CONFIG_CRYPTO_USER_API_AEAD=m
+CONFIG_ALTERA_SOCFPGA_FCS_HAL=m
+CONFIG_ALTERA_SOCFPGA_CONFIG=m
+CONFIG_CRYPTO_DEV_ALTERA_FCS=m
+CONFIG_I2C_ALTERA=y
+CONFIG_SENSORS_IIO_HWMON=y
diff -Naur '--exclude=.git' --no-dereference A/meta-iwave/recipes-kernel/linux/linux-socfpga-lts-ig58m_6.12.bb B/meta-iwave/recipes-kernel/linux/linux-socfpga-lts-ig58m_6.12.bb
--- A/meta-iwave/recipes-kernel/linux/linux-socfpga-lts-ig58m_6.12.bb	1970-01-01 05:30:00.000000000 +0530
+++ B/meta-iwave/recipes-kernel/linux/linux-socfpga-lts-ig58m_6.12.bb	2025-12-09 19:57:47.595926511 +0530
@@ -0,0 +1,64 @@
+DESCRIPTION = "Linux Kernel for Agilex5 based iG-RainboW-G58M SoM"
+LICENSE = "GPL-2.0-only"
+
+# Skip patch-status checks for this package
+INSANE_SKIP:${PN} += "patch-status"
+
+inherit kernel
+
+require ${WORKSPACE}/meta-intel-fpga/recipes-kernel/linux/linux-socfpga-lts_6.12.bb
+require conf/machine/include/ig58m.inc
+
+FILESEXTRAPATHS:prepend := "${THISDIR}/linux-socfpga-lts-ig58:"
+
+#PV = "6.12.11-lts"
+
+COMPATIBLE_MACHINE:agilex5_ig58m = "agilex5_ig58m"
+
+SRC_URI:append:${MACHINE} = " \
+    file://jffs2.scc \
+    file://gpio_sys.scc \
+    file://fit_kernel_agilex5_ig58m.its \
+    file://socfpga_agilex5_ig58m.cfg \
+    file://P01-iG-PRHSZ-SC-01-R2.0-REL0.1-SD2.0-Q25.1-Linux6.12.11.patch \
+"
+
+DEPENDS = "u-boot-mkimage-native dtc-native"
+
+LINUXDEPLOYDIR = "${WORKDIR}/deploy-${PN}"
+DTBDEPLOYDIR = "${DEPLOY_DIR_IMAGE}/devicetree"
+
+do_configure:prepend() {
+    cp ${THISDIR}/linux-socfpga-lts-ig58/fit_kernel_agilex5_ig58m.its ${WORKDIR}/
+}
+
+do_install:append() {
+    if [[ "${MACHINE}" == *"agilex5_ig58m"* ]]; then
+        install -d ${DTBDEPLOYDIR}
+        install -m 0644 ${B}/arch/arm64/boot/dts/intel/socfpga_agilex5_iG58m.dtb ${DTBDEPLOYDIR}/socfpga_agilex5_iG58m.dtb
+    fi
+}
+
+
+do_deploy:append() {
+    if [[ "${MACHINE}" == *"agilex5_ig58m"* ]]; then
+        install -d ${DTBDEPLOYDIR}
+        if [ -f "${B}/arch/arm64/boot/dts/intel/socfpga_agilex5_iG58m.dtb" ]; then
+            cp ${B}/arch/arm64/boot/dts/intel/socfpga_agilex5_iG58m.dtb ${DTBDEPLOYDIR}/socfpga_agilex5_iG58m.dtb
+        else
+            bbfatal "Device tree file socfpga_agilex5_iG58m.dtb not found in ${B}/arch/arm64/boot/dts/intel/"
+        fi
+        if [ -f "${WORKDIR}/fit_kernel_${MACHINE}.its" ]; then
+            cp ${WORKDIR}/fit_kernel_${MACHINE}.its ${B}
+        else
+            bbfatal "FIT image script fit_kernel_${MACHINE}.its not found in ${WORKDIR}"
+        fi
+        cp ${DTBDEPLOYDIR}/socfpga_agilex5_iG58m.dtb ${B}
+        cp ${LINUXDEPLOYDIR}/Image ${B}
+        xz --format=lzma ${B}/Image
+        mkimage -f ${B}/fit_kernel_${MACHINE}.its ${B}/kernel.itb
+        install -m 744 ${B}/fit_kernel_${MACHINE}.its ${DEPLOYDIR}
+        install -m 744 ${B}/kernel.itb ${DEPLOYDIR}
+        install -m 744 ${B}/Image.lzma ${DEPLOYDIR}
+    fi
+}
diff -Naur '--exclude=.git' --no-dereference A/meta-iwave/recipes-support/bootscript/bootscript.bb B/meta-iwave/recipes-support/bootscript/bootscript.bb
--- A/meta-iwave/recipes-support/bootscript/bootscript.bb	1970-01-01 05:30:00.000000000 +0530
+++ B/meta-iwave/recipes-support/bootscript/bootscript.bb	2025-12-09 19:57:47.567923120 +0530
@@ -0,0 +1,21 @@
+SUMMARY = "Bootscript for Agilex 5 SOCFPGA"
+LICENSE = "MIT"
+LIC_FILES_CHKSUM = "file://${COMMON_LICENSE_DIR}/MIT;md5=0835ade698e0bcf8506ecda2f7b4f302"
+
+SRC_URI = "file://bootscript"
+
+S = "${UNPACKDIR}"
+
+inherit update-rc.d
+
+INITSCRIPT_NAME = "bootscript"
+INITSCRIPT_PARAMS = "start 99 5 ."
+
+do_install() {
+    install -d ${D}${sysconfdir}/init.d
+    install -m 0755 ${S}/bootscript ${D}${sysconfdir}/init.d/bootscript
+}
+
+FILES_${PN} += "${sysconfdir}/init.d/bootscript"
+
+RDEPENDS_${PN} += "watchdog-init"
\ No newline at end of file
diff -Naur '--exclude=.git' --no-dereference A/meta-iwave/recipes-support/bootscript/files/bootscript B/meta-iwave/recipes-support/bootscript/files/bootscript
--- A/meta-iwave/recipes-support/bootscript/files/bootscript	1970-01-01 05:30:00.000000000 +0530
+++ B/meta-iwave/recipes-support/bootscript/files/bootscript	2025-12-09 19:57:47.568923240 +0530
@@ -0,0 +1,4 @@
+#!/bin/sh
+
+# Start watchdog for Agilex 5 SOCFPGA
+/etc/init.d/watchdog-init start_wdt
\ No newline at end of file
diff -Naur '--exclude=.git' --no-dereference A/meta-iwave/recipes-support/watchdog/files/watchdog-init B/meta-iwave/recipes-support/watchdog/files/watchdog-init
--- A/meta-iwave/recipes-support/watchdog/files/watchdog-init	1970-01-01 05:30:00.000000000 +0530
+++ B/meta-iwave/recipes-support/watchdog/files/watchdog-init	2025-12-09 19:57:47.572923725 +0530
@@ -0,0 +1,89 @@
+#!/bin/sh
+### BEGIN INIT INFO
+# Provides:          watchdog-init
+# Required-Start:    $local_fs $remote_fs
+# Required-Stop:     $local_fs $remote_fs
+# Default-Start:     2 3 4 5
+# Default-Stop:      0 1 6
+# Short-Description: Watchdog service for Agilex 5 SoC FPGA
+### END INIT INFO
+
+DESC="Watchdog for Agilex 5 SoC FPGA"
+WDT_DEVICE="/dev/watchdog"
+WDT_CONF="/etc/watchdog.conf"
+DAEMON="/usr/sbin/watchdog"
+WDT_PID="/var/run/watchdog-nokick.pid"
+
+wdt_start() {
+    [ -e "$WDT_DEVICE" ] || { echo "Error: $WDT_DEVICE not found"; exit 1; }
+
+    INTERVAL=1   # default kick interval
+    TIMEOUT=20   # default timeout
+
+    while [ $# -gt 0 ]; do
+        case "$1" in
+            --interval=*) INTERVAL="${1#*=}" ;;
+            --timeout=*)  TIMEOUT="${1#*=}" ;;
+            *) echo "Invalid argument: $1"; exit 1 ;;
+        esac
+        shift
+    done
+
+    echo "Starting watchdog: requested interval=${INTERVAL}s, requested timeout=${TIMEOUT}s"
+
+    if [ "$INTERVAL" -eq 0 ]; then
+        echo "No kicks will be sent (system will reset after ~${TIMEOUT}s)"
+        (
+            exec 3> "$WDT_DEVICE"
+            sleep infinity
+        ) &
+        echo $! > "$WDT_PID"
+    else
+        # Write configuration file for watchdog daemon
+        cat > "$WDT_CONF" <<EOF
+watchdog-device = $WDT_DEVICE
+watchdog-timeout = $TIMEOUT
+interval = $INTERVAL
+real-time = yes
+EOF
+        # Start watchdog daemon
+        $DAEMON -c "$WDT_CONF" -s -F &
+        sleep 1
+    fi
+}
+
+wdt_stop() {
+    echo "Stopping watchdog"
+    if [ -f "$WDT_PID" ]; then
+        kill "$(cat "$WDT_PID")" 2>/dev/null || true
+        rm -f "$WDT_PID"
+    fi
+    killall watchdog 2>/dev/null
+    echo V > "$WDT_DEVICE" 2>/dev/null || true
+}
+
+case "$1" in
+    start|start_wdt)
+        shift
+        wdt_start "$@"
+        ;;
+    stop|stop_wdt)
+        wdt_stop
+        ;;
+    restart)
+        wdt_stop
+        shift
+        wdt_start "$@"
+        ;;
+    status)
+        if pidof watchdog >/dev/null || [ -f "$WDT_PID" ]; then
+            echo "Watchdog is running"
+        else
+            echo "Watchdog is not running"
+        fi
+        ;;
+    *)
+        echo "Usage: $0 {start|start_wdt [--interval=N] [--timeout=N]|stop|stop_wdt|restart [--interval=N] [--timeout=N]|status}"
+        exit 1
+        ;;
+esac
\ No newline at end of file
diff -Naur '--exclude=.git' --no-dereference A/meta-iwave/recipes-support/watchdog/files/watchdog.service B/meta-iwave/recipes-support/watchdog/files/watchdog.service
--- A/meta-iwave/recipes-support/watchdog/files/watchdog.service	1970-01-01 05:30:00.000000000 +0530
+++ B/meta-iwave/recipes-support/watchdog/files/watchdog.service	2025-12-09 19:57:47.572923725 +0530
@@ -0,0 +1,14 @@
+[Unit]
+Description=Watchdog Service for Agilex 5 SOCFPGA
+After=local-fs.target
+Wants=local-fs.target
+
+[Service]
+Type=simple
+ExecStart=/usr/sbin/watchdog -s -F /dev/watchdog
+ExecStop=/bin/sh -c "echo V > /dev/watchdog"
+Restart=always
+TimeoutSec=60
+
+[Install]
+WantedBy=multi-user.target
\ No newline at end of file
diff -Naur '--exclude=.git' --no-dereference A/meta-iwave/recipes-support/watchdog/watchdog-init.bb B/meta-iwave/recipes-support/watchdog/watchdog-init.bb
--- A/meta-iwave/recipes-support/watchdog/watchdog-init.bb	1970-01-01 05:30:00.000000000 +0530
+++ B/meta-iwave/recipes-support/watchdog/watchdog-init.bb	2025-12-09 19:57:47.570923483 +0530
@@ -0,0 +1,18 @@
+# This file is the watchdog recipe.
+#
+
+SUMMARY = "Simple watchdog application"
+LICENSE = "MIT"
+LIC_FILES_CHKSUM = "file://${COMMON_LICENSE_DIR}/MIT;md5=0835ade698e0bcf8506ecda2f7b4f302"
+
+SRC_URI = "file://watchdog-init \
+    "
+
+S = "${UNPACKDIR}"
+
+do_install() {
+         install -d ${D}${sysconfdir}/init.d
+         install -m 0755 ${S}/watchdog-init ${D}${sysconfdir}/init.d/watchdog-init
+}
+FILES_${PN} += "${sysconfdir}/*"
+RDEPENDS:${PN} += "watchdog"
\ No newline at end of file
diff -Naur '--exclude=.git' --no-dereference A/meta-iwave/scripts/agilex5_ig58m-gsrd-build.sh B/meta-iwave/scripts/agilex5_ig58m-gsrd-build.sh
--- A/meta-iwave/scripts/agilex5_ig58m-gsrd-build.sh	1970-01-01 05:30:00.000000000 +0530
+++ B/meta-iwave/scripts/agilex5_ig58m-gsrd-build.sh	2025-12-09 19:57:47.477912219 +0530
@@ -0,0 +1,479 @@
+#!/usr/bin/env bash
+# Source this file by running:
+# 	$ . <machine>-<image>-build.sh
+
+arg0=$0
+test -n "$BASH" && arg0=$BASH_SOURCE[0]
+filename="${arg0##*/}"
+
+WORKSPACE=$(/bin/readlink -f $(dirname '${0}'))
+echo "[INFO] Build location = $WORKSPACE"
+if [ ! -d "$WORKSPACE" ]; then
+	mkdir $WORKSPACE
+fi
+
+echo -e "\n[INFO] Selected ingredient versions for this build"
+#------------------------------------------------------------------------------------------#
+# Set Machine variant
+#------------------------------------------------------------------------------------------#
+target=${filename%-*-*}
+if [ -n "${target}" -a "${target}" != "${filename}" ]; then
+	MACHINE=${target}
+fi
+if [ -z "${MACHINE}" ]; then
+	echo "MACHINE must be set before sourcing this script"
+	return
+fi
+echo "MACHINE              = $MACHINE"
+export $MACHINE
+#------------------------------------------------------------------------------------------#
+# Set IMAGE variant
+#------------------------------------------------------------------------------------------#
+image=$(cut -d- -f2 <<< "$filename")
+if [ -n "${image}" -a "${image}" != "${filename}" ]; then
+	IMAGE=${image}
+fi
+echo "VARIANT              = $IMAGE"
+export $IMAGE
+
+#------------------------------------------------------------------------------------------#
+# Set Linux Version
+#------------------------------------------------------------------------------------------#
+export LINUX_VER=6.12.11
+echo "LINUX_VERSION        = $LINUX_VER"
+LINUX_SOCFPGA_BRANCH=socfpga-$LINUX_VER-lts
+echo "LINUX_SOCFPGA_BRANCH = $LINUX_SOCFPGA_BRANCH"
+
+#------------------------------------------------------------------------------------------#
+# Set default U-Boot Version
+#------------------------------------------------------------------------------------------#
+export UBOOT_VER=v2025.01
+export UBOOT_REL=
+echo "UBOOT_VERSION        = $UBOOT_VER$UBOOT_REL"
+UBOOT_SOCFPGA_BRANCH=socfpga_$UBOOT_VER$UBOOT_REL
+echo "UBOOT_SOCFPGA_BRANCH = $UBOOT_SOCFPGA_BRANCH"
+
+#------------------------------------------------------------------------------------------#
+# Set UB_CONFIG for each of the configurations
+#------------------------------------------------------------------------------------------#
+if [[ "$MACHINE" == *"agilex"* || "$MACHINE" == *"stratix10"* ]]; then
+	if [[ "$MACHINE" == *"agilex7"* ]]; then
+		UB_CONFIG="agilex-socdk-atf"
+	elif [[ "$MACHINE" == "agilex5_dk_a5e"* ]]; then
+		if [[ "$IMAGE" == "nand" ]]; then
+			UB_CONFIG="$MACHINE-socdk-$IMAGE-atf"
+		else
+			UB_CONFIG="$MACHINE-socdk-atf"
+		fi
+	elif [[ "$MACHINE" == *"stratix10"* ]]; then
+		UB_CONFIG="stratix10-socdk-atf"
+	else
+		UB_CONFIG="$MACHINE-socdk-atf"
+	fi
+elif [[ "$MACHINE" == "arria10" || "$MACHINE" == "cyclone5" ]]; then
+	if [[ "$IMAGE" == "nand" || "$IMAGE" == "qspi" ]]; then
+		UB_CONFIG="$MACHINE-socdk-$IMAGE"
+	else
+		UB_CONFIG="$MACHINE-socdk"
+	fi
+fi
+echo "UBOOT_CONFIG         = $UB_CONFIG"
+
+#------------------------------------------------------------------------------------------#
+# Set Arm-Trusted-Firmware version
+#------------------------------------------------------------------------------------------#
+export ATF_VER=v2.12.0
+echo "ATF_VERSION          = $ATF_VER"
+ATF_BRANCH=socfpga_$ATF_VER
+echo "ATF_BRANCH           = $ATF_BRANCH"
+
+echo -e "\n[INFO] To build default GSRD Image:"
+echo -e "[INFO] Proceed with: build_default"
+echo -e "\n[INFO] To build default GSRD Image + eSDK:"
+echo -e "[INFO] Proceed with: build_esdk"
+echo -e "\n[INFO] To build step-by-step with customization:"
+echo -e "[INFO] Proceed with: build_setup"
+echo -e "\n[INFO] To build default GSRD Image + Xen Hypervisor:"
+echo -e "[INFO] Proceed with: build_hyp"
+echo -e "\n"
+
+#------------------------------------------------------------------------------------------#
+# Clean up the build workspace for subsequent build to happen smoothly
+#------------------------------------------------------------------------------------------#
+# Setup staging folder for binaries generated
+STAGING_FOLDER=$WORKSPACE/$MACHINE-$IMAGE-images
+
+build_setup() {
+	if [ -d "$WORKSPACE" ]; then
+		echo -e "\n[INFO] Cleanup the /tmp, /conf folders in the workspace for next build"
+		pushd $WORKSPACE > /dev/null
+			rm -rf $MACHINE-$IMAGE-rootfs/tmp/
+			rm -rf $MACHINE-$IMAGE-rootfs/conf/
+
+			if [ -d $MACHINE-$IMAGE-images ]; then
+				echo "[INFO] Cleanup images folder in the workspace for next build"
+				rm -rf $MACHINE-$IMAGE-images
+			fi
+		popd > /dev/null
+	fi
+
+	if [ ! -d $WORKSPACE/$MACHINE-$IMAGE-rootfs ]; then
+		echo -e "\n[INFO] Create build workspace"
+		mkdir -p $WORKSPACE/$MACHINE-$IMAGE-rootfs
+	fi
+	
+	if [ ! -d $WORKSPACE/$MACHINE-$IMAGE-images ]; then
+		echo -e "\n[INFO] Create image staging area"
+		mkdir -p $WORKSPACE/$MACHINE-$IMAGE-images
+	fi
+
+#------------------------------------------------------------------------------------------#
+# Update existing meta layers or clone a new one if it does not exists
+#------------------------------------------------------------------------------------------#
+	pushd $WORKSPACE > /dev/null
+		# Update submodules
+		git submodule update --init -r
+	popd > /dev/null
+
+#------------------------------------------------------------------------------------------#
+# Initialize Yocto build environment setup
+#------------------------------------------------------------------------------------------#
+	pushd $WORKSPACE > /dev/null
+		
+		# Setup Poky build environment
+		pushd meta-intel-fpga-refdes/recipes-bsp/ghrd > /dev/null
+			mkdir -p ./files
+		popd
+		echo -e "\n[INFO] Source poky/oe-init-build-env to initialize poky build environment"
+		source poky/oe-init-build-env $WORKSPACE/$MACHINE-$IMAGE-rootfs/
+
+		# Settings for bblayers.conf
+		echo -e "\n[INFO] Update bblayers.conf"
+		bitbake-layers add-layer ../meta-intel-fpga
+		bitbake-layers add-layer ../meta-intel-fpga-refdes
+		bitbake-layers add-layer ../meta-iwave
+		bitbake-layers add-layer ../meta-openembedded/meta-oe
+		bitbake-layers add-layer ../meta-openembedded/meta-python
+		bitbake-layers add-layer ../meta-openembedded/meta-networking
+		bitbake-layers add-layer ../meta-clang
+
+		# Show layers for checking purposes
+		echo -e "\n"
+		bitbake-layers show-layers
+		sleep 5
+		echo -e "\n"
+
+		# Settings for site.conf
+		echo -e "\n[INFO] Creating site.conf: User changes will not be saved"
+		echo "MACHINE = \"$MACHINE\"" >> conf/site.conf
+		echo "DL_DIR = \"$WORKSPACE/downloads\"" >> conf/site.conf
+		echo "SSTATE_DIR ?= \"$WORKSPACE/sstate_cache\"" >> conf/site.conf
+		echo "IMAGE_TYPE:${MACHINE} = \"$IMAGE\"" >> conf/site.conf
+		echo 'DISTRO_FEATURES:append = " systemd usrmerge"' >> conf/site.conf
+		echo 'VIRTUAL-RUNTIME_init_manager = "systemd"' >> conf/site.conf
+		echo "require conf/machine/$MACHINE-gsrd.conf" >> conf/site.conf
+		echo "WORKSPACE = \"$WORKSPACE\"" >> conf/site.conf
+		# Linux
+		echo 'PREFERRED_PROVIDER_virtual/kernel = "linux-socfpga-lts-ig58m"' >> conf/site.conf
+		echo "PREFERRED_VERSION_linux-socfpga-lts = \"`cut -d. -f1-2 <<< "$LINUX_VER"`%\"" >> conf/site.conf
+		echo "KBRANCH = \"$LINUX_SOCFPGA_BRANCH\"" >> conf/site.conf
+		# U-boot
+		echo 'PREFERRED_PROVIDER_virtual/bootloader = "u-boot-socfpga-ig58m"'>> conf/site.conf
+		echo "UBOOT_CONFIG:${MACHINE} = \"$UB_CONFIG\"" >> conf/site.conf
+		echo "PREFERRED_VERSION_u-boot-socfpga = \"$UBOOT_VER%\"" >> conf/site.conf
+		echo "UBOOT_BRANCH = \"$UBOOT_SOCFPGA_BRANCH\"" >> conf/site.conf
+		# ATF
+		echo 'PREFERRED_PROVIDER_arm-trusted-firmware = "arm-trusted-firmware-ig58m"'>> conf/site.conf
+		echo "PREFERRED_VERSION_arm-trusted-firmware = \"`cut -d. -f1-2 <<< "$ATF_VER"`\"" >> conf/site.conf
+		echo "ATF_BRANCH = \"$ATF_BRANCH\"" >> conf/site.conf
+		# Blacklist kernel-modules to prevent autoload from udev
+		echo 'KERNEL_MODULE_PROBECONF = "intel_fcs cfg80211"' >> conf/site.conf
+		echo 'module_conf_intel_fcs = "blacklist intel_fcs"' >> conf/site.conf
+		echo 'module_conf_cfg80211 = "blacklist cfg80211"' >> conf/site.conf
+		# Archive source file
+		echo 'INHERIT += "archiver"' >> conf/site.conf
+		echo 'ARCHIVER_MODE[src] = "original"' >> conf/site.conf
+
+		# Setting for Hypervisor build
+		if [[ "$HYP_BUILD" -eq 1 ]]; then
+			bitbake-layers add-layer ../meta-openembedded/meta-filesystems
+			bitbake-layers add-layer ../meta-virtualization
+
+			echo 'IMAGE_FSTYPES:append = " cpio cpio.gz cpio.gz.u-boot ext3 jffs2 tar.gz multiubi"' >> conf/site.conf
+			echo 'DISTRO_FEATURES:append = " virtualization xen"' >> conf/site.conf
+			echo 'IMAGE_INSTALL:append = " xen-tools"' >> conf/site.conf
+			echo 'HYP_BUILD = "1"' >> conf/site.conf
+		fi
+	popd > /dev/null
+
+	echo -e "\n[INFO] To build GSRD Image:"
+	echo -e "[INFO] Proceed with: bitbake_image"
+	echo -e "\n[INFO] To build GSRD Image + eSDK:"
+	echo -e "[INFO] Proceed with: bitbake_esdk"
+	echo -e "\n"
+}
+
+#------------------------------------------------------------------------------------------#
+# Clean Yocto build environment and start Bitbake process
+#------------------------------------------------------------------------------------------#
+bitbake_image() {
+	pushd $WORKSPACE/$MACHINE-$IMAGE-rootfs > /dev/null
+		echo -e "\n[INFO] Clean up previous kernel build if any"
+		bitbake virtual/kernel -c cleanall
+		echo -e "\n[INFO] Clean up previous u-boot build if any"
+		bitbake u-boot-socfpga-ig58m -c cleanall
+		echo -e "\n[INFO] Clean up previous ghrd build if any"
+		bitbake hw-ref-design -c cleanall
+		if [[ "$MACHINE" == *"agilex7_"* || "$MACHINE" == "stratix10" ]]; then
+			echo -e "\n[INFO] Clean up previous dtb build if any"
+			bitbake device-tree -c cleanall
+		fi
+
+		echo -e "\n[INFO] Start bitbake process for target config.."
+		bitbake console-image-minimal gsrd-console-image 2>&1
+
+		if [[ "$HYP_BUILD" -eq 1 ]]; then
+			bitbake xen-image-minimal console-image-minimal gsrd-console-image 2>&1
+		fi
+
+		if [ "$MACHINE" == "arria10" ]; then
+			bitbake xvfb-console-image 2>&1
+		fi
+	popd > /dev/null
+	
+	echo -e "\n[INFO] Proceed with: package"
+	echo -e "\n"
+}
+
+bitbake_esdk() {
+       pushd $WORKSPACE/$MACHINE-$IMAGE-rootfs > /dev/null
+               echo -e "\n[INFO] Clean up previous kernel build if any"
+               bitbake virtual/kernel -c cleanall
+               echo -e "\n[INFO] Clean up previous u-boot build if any"
+               bitbake u-boot-socfpga-ig58m -c cleanall
+               echo -e "\n[INFO] Clean up previous ghrd build if any"
+               bitbake hw-ref-design -c cleanall
+
+               echo -e "\n[INFO] Start bitbake process for target config.."
+               bitbake console-image-minimal gsrd-console-image -c populate_sdk_ext 2>&1
+               if [ "$MACHINE" == "arria10" ]; then
+                       bitbake xvfb-console-image -c populate_sdk_ext 2>&1
+               fi
+       popd > /dev/null
+
+       echo -e "\n[INFO] Proceed with: package"
+       echo -e "\n"
+}
+
+#------------------------------------------------------------------------------------------#
+# Package Yocto bitbake generated binaries
+#------------------------------------------------------------------------------------------#
+package() {
+	echo -e "\n[INFO] Copy the build output and store in $STAGING_FOLDER"
+	pushd $WORKSPACE/$MACHINE-$IMAGE-rootfs/tmp/deploy/images/$MACHINE/ > /dev/null
+
+		cp -vrL *-$MACHINE.rootfs.tar.gz $STAGING_FOLDER/	|| echo "[INFO] No tar.gz found."
+		cp -vrL *-$MACHINE.rootfs.jffs2 $STAGING_FOLDER/	|| echo "[INFO] No jffs2 found."
+		cp -vrL *-$MACHINE.rootfs.wic $STAGING_FOLDER/		|| echo "[INFO] No wic found."
+		cp -vrL *-${MACHINE}.rootfs_nand.ubifs $STAGING_FOLDER/       	|| echo "[INFO] No nand ubifs found."
+		cp -vrL *-${MACHINE}.rootfs_nor.ubifs $STAGING_FOLDER/       	|| echo "[INFO] No nor ubifs found."
+		cp -vrL *-$MACHINE.rootfs.cpio* $STAGING_FOLDER/	|| echo "[INFO] No .cpio found."
+		cp -vrL *-$MACHINE.rootfs.manifest $STAGING_FOLDER/	|| echo "[INFO] No manifest found."
+#		cp -vrL zImage $STAGING_FOLDER/			|| echo "[INFO] No zImage found."
+		cp -vrL Image $STAGING_FOLDER/			|| echo "[INFO] No Image found."
+		cp -vrL Image.lzma $STAGING_FOLDER/		|| echo "[INFO] No Image.lzma found."
+
+		pushd $STAGING_FOLDER
+			for file in *.rootfs*; do
+  				mv "$file" "${file/.rootfs/}"
+     		done
+		popd
+
+		if [ "$MACHINE" == "arria10" ]; then
+			cp -vrL *.itb $STAGING_FOLDER/		|| echo "[INFO] No .itb file found."
+		else
+			cp -vrL kernel.* $STAGING_FOLDER/	|| echo "[INFO] No .itb file found."
+		fi
+
+		if [[ "$MACHINE" == *"agilex5_"* || "$MACHINE" == *"agilex7_"* || "$MACHINE" == *"stratix10"* ]]; then
+			cp -vrL devicetree/* $STAGING_FOLDER/	|| echo "[INFO] No dtb found."
+		elif [[ "$MACHINE" == "arria10" && "$IMAGE" == "nand" ]]; then
+			cp -vrL socfpga_arria10_socdk_nand.dtb $STAGING_FOLDER/		|| echo "[INFO] No dtb found."
+		elif [[ "$MACHINE" == "arria10" && "$IMAGE" == "qspi" ]]; then
+			cp -vrL socfpga_arria10_socdk_qspi.dtb $STAGING_FOLDER/		|| echo "[INFO] No dtb found."
+		else
+			cp -vrL *.dtb $STAGING_FOLDER/	|| echo "[INFO] No dtb found."
+		fi
+	popd > /dev/null
+
+	if [[ "$MACHINE" == *"agilex"* || "$MACHINE" == *"stratix10"* ]]; then
+		mkdir -p $STAGING_FOLDER/u-boot-$MACHINE-socdk-$IMAGE-atf
+		ub_cp_destination=$STAGING_FOLDER/u-boot-$MACHINE-socdk-$IMAGE-atf
+	elif [[ "$MACHINE" == "arria10" || "$MACHINE" == "cyclone5" ]]; then
+		mkdir -p $STAGING_FOLDER/u-boot-$MACHINE-socdk-$IMAGE
+		ub_cp_destination=$STAGING_FOLDER/u-boot-$MACHINE-socdk-$IMAGE
+	fi
+
+	pushd $WORKSPACE/$MACHINE-$IMAGE-rootfs/tmp/work/$MACHINE-poky-*/u-boot-socfpga-ig58m/v20*/build/*defconfig/
+		cp -vL u-boot $ub_cp_destination
+		cp -vL u-boot-dtb.bin $ub_cp_destination
+		cp -vL u-boot-dtb.img $ub_cp_destination
+		cp -vL u-boot.dtb $ub_cp_destination
+		cp -vL u-boot.img $ub_cp_destination
+		cp -vL u-boot.map $ub_cp_destination
+		cp -vL u-boot.sym $ub_cp_destination
+		cp -vL System.map $ub_cp_destination
+		cp -vL spl/u-boot-spl $ub_cp_destination
+		cp -vL spl/u-boot-spl-dtb.bin $ub_cp_destination
+		cp -vL spl/u-boot-spl.dtb $ub_cp_destination
+		cp -vL spl/u-boot-spl.map $ub_cp_destination
+		cp -vL spl/u-boot-spl.bin $ub_cp_destination
+
+		if [[ "$MACHINE" == *"agilex"* || "$MACHINE" == *"stratix10"* ]]; then
+			cp -vL spl/u-boot-spl-dtb.hex $ub_cp_destination
+			cp -vL u-boot.itb $ub_cp_destination
+		elif [[ "$MACHINE" == "cyclone5" || "$MACHINE" == "arria10" ]]; then
+			cp -vL spl/u-boot-spl.sfp $ub_cp_destination
+			cp -vL spl/u-boot-splx4.sfp $ub_cp_destination
+		fi
+
+		if [ "$MACHINE" == "cyclone5" ]; then
+			cp -vL u-boot-with-spl.sfp $ub_cp_destination
+		fi
+	popd > /dev/null
+
+	pushd $ub_cp_destination > /dev/null
+		chmod 644 u-boot-dtb.img
+		chmod 644 u-boot.img
+		chmod 744 u-boot.itb || echo "[INFO] File u-boot.itb not found for this build configuration."
+	popd > /dev/null
+
+	# Copy u-boot script / extlinux.conf to u-boot staging folder
+	pushd $WORKSPACE/$MACHINE-$IMAGE-rootfs/tmp/deploy/images/$MACHINE/ > /dev/null
+		if [[ "$MACHINE" == *"agilex"* || "$MACHINE" == *"stratix10"* ]]; then
+			cp -vL u-boot.txt $ub_cp_destination
+			cp -vL boot.scr.* $ub_cp_destination
+			if [[ "$HYP_BUILD" -eq 1 ]]; then
+				cp -vL u-boot_xen.txt $STAGING_FOLDER/
+				cp -vL xen $STAGING_FOLDER/
+			fi
+		elif [[ "$MACHINE" == "arria10" && "$IMAGE" == "pr" ]]; then
+			cp -vL u-boot.txt $ub_cp_destination
+			cp -vL boot.scr $ub_cp_destination
+		elif [ "$MACHINE" == "cyclone5" ]; then
+			cp -vL u-boot.txt $ub_cp_destination
+			cp -vL u-boot.scr $ub_cp_destination
+		fi
+		if [[ "$MACHINE" == "arria10" || "$MACHINE" == "cyclone5" ]]; then
+			cp -vL extlinux.conf $STAGING_FOLDER
+		fi
+	popd > /dev/null
+
+	pushd $WORKSPACE/$MACHINE-$IMAGE-rootfs/tmp/deploy/images/$MACHINE/ > /dev/null
+		cp -vrL ${MACHINE}_${IMAGE}_ghrd/ $STAGING_FOLDER/. || echo "[INFO] File core.rbf not found for this build configuration."
+	popd > /dev/null
+
+	pushd $WORKSPACE/$MACHINE-$IMAGE-rootfs/tmp/deploy/ > /dev/null
+		cp -r sources $STAGING_FOLDER/.
+	popd > /dev/null
+
+	pushd $STAGING_FOLDER
+		if [ "$MACHINE" == "agilex7_dk_si_agf014ea" ]; then
+			for file in *_dk_si_agf014ea*; do
+				mv "$file" "${file/_dk_si_agf014ea/}"
+			done
+		elif [ "$MACHINE" == "agilex7_dk_si_agf014eb" ]; then
+			for file in *_dk_si_agf014eb*; do
+				mv "$file" "${file/_dk_si_agf014eb/}"
+			done
+		elif [ "$MACHINE" == "agilex7_dk_dev_agf027f1es" ]; then
+			for file in *_dk_dev_agf027f1es*; do
+				mv "$file" "${file/_dk_dev_agf027f1es/}"
+			done
+		elif [ "$MACHINE" == "agilex7_dk_si_agi027fb" ]; then
+			for file in *_dk_si_agi027fb*; do
+				mv "$file" "${file/_dk_si_agi027fb/}"
+			done
+		elif [ "$MACHINE" == "agilex7_dk_si_agi027fa" ]; then
+			for file in *_dk_si_agi027fa*; do
+				mv "$file" "${file/_dk_si_agi027fa/}"
+			done
+		elif [ "$MACHINE" == "agilex7_dk_si_agi027fc" ]; then
+			for file in *_dk_si_agi027fc*; do
+				mv "$file" "${file/_dk_si_agi027fc/}"
+			done
+		elif [ "$MACHINE" == "agilex7_dk_dev_agm039fes" ]; then
+			for file in *_dk_dev_agm039fes*; do
+				mv "$file" "${file/_dk_dev_agm039fes/}"
+			done
+		elif [ "$MACHINE" == "agilex5_dk_a5e065bb32aes1" ]; then
+			for file in *_dk_a5e065bb32aes1*; do
+				mv "$file" "${file/_dk_a5e065bb32aes1/}"
+			done
+		elif [ "$MACHINE" == "agilex5_dk_a5e013bb32aesi0" ]; then
+			for file in *_dk_a5e013bb32aesi0*; do
+				mv "$file" "${file/_dk_a5e013bb32aesi0/}"
+			done
+		elif [ "$MACHINE" == "agilex5_mk_a5e065bb32aes1" ]; then
+			for file in *_mk_a5e065bb32aes1*; do
+				mv "$file" "${file/_mk_a5e065bb32aes1/}"
+			done
+		elif [ "$MACHINE" == "stratix10_htile" ]; then
+			for file in *_htile*; do
+				mv "$file" "${file/_htile/}"
+			done
+		fi
+
+		# Generate sdimage.tar.gz
+	    	# Use name agilex7 for agilex7 devices
+	    	if [[ "$MACHINE" == *"agilex7_"* ]]; then
+	        	tar cvzf sdimage.tar.gz gsrd-console-image-agilex7.wic
+            		md5sum sdimage.tar.gz > sdimage.tar.gz.md5sum
+            		xz --best console-image-minimal-agilex7.wic
+	    	elif [[ "$MACHINE" == *"stratix10_"* ]]; then
+	        	tar cvzf sdimage.tar.gz gsrd-console-image-stratix10.wic
+            		md5sum sdimage.tar.gz > sdimage.tar.gz.md5sum
+            		xz --best console-image-minimal-stratix10.wic
+	    	elif [[ "$MACHINE" == *"agilex5_dk_"* || "$MACHINE" == *"agilex5_mk_"* ]]; then
+	        	tar cvzf sdimage.tar.gz gsrd-console-image-agilex5.wic
+            		md5sum sdimage.tar.gz > sdimage.tar.gz.md5sum
+            		xz --best console-image-minimal-agilex5.wic
+	    	else
+            		tar cvzf sdimage.tar.gz gsrd-console-image-$MACHINE.wic
+            		md5sum sdimage.tar.gz > sdimage.tar.gz.md5sum
+            		xz --best console-image-minimal-$MACHINE.wic
+	    	fi
+
+		if [ "$MACHINE" == "arria10" ]; then
+                    	xz --best xvfb-console-image-$MACHINE.wic
+	         fi
+    popd
+
+	# Deploy eSDK if it exist
+	if [[ -d $WORKSPACE/$MACHINE-$IMAGE-rootfs/tmp/deploy/sdk ]]; then
+		pushd $WORKSPACE/$MACHINE-$IMAGE-rootfs/tmp/deploy/sdk/ > /dev/null
+			mkdir -p $STAGING_FOLDER/esdk
+			cp -vL poky*.sh $STAGING_FOLDER/esdk/.
+		popd > /dev/null
+	fi
+
+	echo -e "\n[INFO] Completed: Binaries are store in $WORKSPACE/$MACHINE-$IMAGE-images"
+	echo -e "\n"
+}
+
+build_default() {
+	build_setup
+	bitbake_image
+	package
+}
+
+build_esdk() {
+	build_setup
+	bitbake_esdk
+	package
+}
+
+build_hyp() {
+	export HYP_BUILD=1
+	build_default
+}
